# Sequence Maker - Python Sandbox for Sequence Generation

This document explains the Python sandbox feature in Sequence Maker, which allows the LLM to generate and execute Python code for creating complex light sequences.

## Overview

The Python sandbox provides a secure environment for executing Python code generated by the LLM. This allows for more complex and dynamic light sequences than would be possible with the standard tools alone, while maintaining security through a restricted execution environment.

## Architecture

The sandbox implementation consists of the following components:

1. **SandboxManager**: A class that manages the secure execution of Python code.
2. **Safe Wrappers**: Functions that provide secure access to application functionality.
3. **Safe Utilities**: Helper functions for common operations like color manipulation.
4. **Restricted Execution**: Using RestrictedPython to limit what the code can do.

## Security Measures

The sandbox implements several security measures to prevent malicious code execution:

1. **Restricted Python Environment**: Uses RestrictedPython to compile and execute code in a restricted environment.
2. **Limited Access to Built-ins**: Only a minimal set of safe built-in functions are available.
3. **No Import Access**: The code cannot import modules, preventing access to system resources.
4. **Safe Wrappers**: All application functions are wrapped to validate inputs and prevent misuse.
5. **Timeout Mechanism**: Code execution is limited to a maximum time to prevent infinite loops.
6. **Memory Safety**: The sandbox runs in the same process but with restricted access to prevent memory issues.

## Available Functions

The following functions are available within the sandbox:

### Timeline Functions

- `create_segment(timeline_index, start_time, end_time, color)`: Creates a segment on the specified timeline.
  - `timeline_index`: Index of the timeline (0-based).
  - `start_time`: Start time of the segment in seconds.
  - `end_time`: End time of the segment in seconds.
  - `color`: RGB color as a list of 3 integers (0-255).

- `clear_timeline(timeline_index)`: Clears all segments from the specified timeline.
  - `timeline_index`: Index of the timeline (0-based).

- `modify_segment(timeline_index, segment_index, start_time=None, end_time=None, color=None)`: Modifies an existing segment.
  - `timeline_index`: Index of the timeline (0-based).
  - `segment_index`: Index of the segment in the timeline (0-based).
  - `start_time`: New start time in seconds (optional).
  - `end_time`: New end time in seconds (optional).
  - `color`: New RGB color as a list of 3 integers (0-255) (optional).

- `delete_segment(timeline_index, segment_index)`: Deletes a segment from the specified timeline.
  - `timeline_index`: Index of the timeline (0-based).
  - `segment_index`: Index of the segment in the timeline (0-based).

### Utility Functions

- `random_color()`: Generates a random RGB color.
  - Returns: A list of 3 integers (0-255).

- `random_float(min_val, max_val)`: Generates a random float between min_val and max_val.
  - `min_val`: Minimum value.
  - `max_val`: Maximum value.
  - Returns: A random float.

- `interpolate_color(color1, color2, factor)`: Interpolates between two colors.
  - `color1`: First RGB color as a list of 3 integers (0-255).
  - `color2`: Second RGB color as a list of 3 integers (0-255).
  - `factor`: Interpolation factor (0-1).
  - Returns: Interpolated RGB color as a list of 3 integers (0-255).

- `hsv_to_rgb(h, s, v)`: Converts HSV color to RGB.
  - `h`: Hue (0-360).
  - `s`: Saturation (0-1).
  - `v`: Value (0-1).
  - Returns: RGB color as a list of 3 integers (0-255).

- `rgb_to_hsv(r, g, b)`: Converts RGB color to HSV.
  - `r`: Red component (0-255).
  - `g`: Green component (0-255).
  - `b`: Blue component (0-255).
  - Returns: HSV color as a list of 3 values [h, s, v] where h is in degrees (0-360) and s, v are in range 0-1.

- `color_from_name(color_name)`: Converts a color name to RGB values.
  - `color_name`: Color name (e.g., "red", "green", "blue").
  - Returns: RGB color as a list of 3 integers (0-255).

- `print(...)`: Safe print function that logs to the application log.
  - Returns: The printed string.

### Available Data

The following data is available within the sandbox:

- `BEAT_TIMES`: List of beat timestamps in seconds.
- `NUM_BALLS`: Number of balls/timelines.
- `SONG_DURATION`: Duration of the song in seconds.

## Usage Examples

### Example 1: Simple Color Sequence

```python
# Create a simple alternating color sequence
colors = [
    [255, 0, 0],    # Red
    [0, 255, 0],    # Green
    [0, 0, 255]     # Blue
]

# Create segments for each beat
for i, beat_time in enumerate(BEAT_TIMES):
    # Get color (cycle through colors)
    color_index = i % len(colors)
    color = colors[color_index]
    
    # Create segment
    create_segment(0, beat_time, beat_time + 0.25, color)
```

### Example 2: Rainbow Pattern

```python
# Create a rainbow pattern across all beats
for i, beat_time in enumerate(BEAT_TIMES):
    # Calculate hue based on position in beat sequence
    hue = (i / len(BEAT_TIMES)) * 360
    
    # Create segments for each ball with different hue offsets
    for ball in range(NUM_BALLS):
        offset_hue = (hue + (ball * 30)) % 360
        ball_color = hsv_to_rgb(offset_hue, 1.0, 1.0)
        create_segment(ball, beat_time, beat_time + 0.25, ball_color)
```

### Example 3: Fade Pattern

```python
# Create a fade pattern
base_color = [255, 0, 0]  # Red

for i, beat_time in enumerate(BEAT_TIMES):
    # Skip the last beat
    if i == len(BEAT_TIMES) - 1:
        continue
    
    # Get current and next beat time
    current_beat = beat_time
    next_beat = BEAT_TIMES[i + 1]
    duration = next_beat - current_beat
    
    # Create fade segments
    steps = 5
    step_duration = duration / steps
    
    for step in range(steps):
        # Calculate fade factor (0 to 1)
        fade_factor = step / (steps - 1)
        
        # Interpolate between colors
        faded_color = interpolate_color(base_color, [0, 0, 0], fade_factor)
        
        # Calculate segment times
        start_time = current_beat + (step * step_duration)
        end_time = current_beat + ((step + 1) * step_duration)
        
        # Create segment
        create_segment(0, start_time, end_time, faded_color)
```

## Best Practices

When using the Python sandbox, follow these best practices:

1. **Keep Code Simple**: Write clear, concise code that focuses on the specific task.
2. **Validate Inputs**: Check that inputs are within valid ranges before using them.
3. **Handle Errors**: Use try/except blocks to handle potential errors gracefully.
4. **Limit Complexity**: Avoid overly complex algorithms that might time out.
5. **Use Available Data**: Leverage the provided context data (BEAT_TIMES, NUM_BALLS, etc.) for better integration.

## Limitations

The Python sandbox has the following limitations:

1. **No External Modules**: The code cannot import external modules.
2. **Limited Built-ins**: Only a subset of Python's built-in functions are available.
3. **Execution Time Limit**: Code execution is limited to a maximum time (default: 5 seconds).
4. **No File Access**: The code cannot read from or write to files.
5. **No Network Access**: The code cannot make network requests.

## Implementation Details

The sandbox is implemented using RestrictedPython, which compiles the code and traverses the Abstract Syntax Tree (AST) to enforce restrictions before execution. This prevents access to disallowed attributes and built-ins.

The SandboxManager class provides the following main methods:

- `execute_sandboxed_code(code_string, available_context)`: Executes the provided code in the sandbox.
- `_create_safe_wrappers()`: Creates safe wrappers for application functions.
- `_create_safe_utilities()`: Creates safe utility functions.
- `_create_sandbox_globals(safe_wrappers, safe_utilities, available_context)`: Creates the global environment for the sandbox.
- `_execute_with_timeout(code, globals_dict)`: Executes code with a timeout.

## Integration with LLM

The sandbox is integrated with the LLM through the `execute_sequence_code` tool in the LLMToolManager. When the LLM calls this tool, the code is executed in the sandbox and the result is returned to the LLM.

The LLM can use this tool when it needs to create complex light sequences that would be difficult or impossible to create with the standard tools.

## Security Considerations

While the sandbox is designed to be secure, it's important to be aware of potential security risks:

1. **Resource Consumption**: Malicious code could attempt to consume excessive CPU or memory resources.
2. **Sandbox Escape**: Sophisticated attacks might attempt to escape the sandbox.
3. **Logic Bombs**: Code might contain hidden logic that activates under certain conditions.

To mitigate these risks, the sandbox implements the security measures described above and is regularly tested for vulnerabilities.

## Troubleshooting

If you encounter issues with the Python sandbox, check the following:

1. **Syntax Errors**: Ensure the code has valid Python syntax.
2. **Runtime Errors**: Check for runtime errors like division by zero or index out of range.
3. **Timeout Errors**: If the code times out, simplify it or optimize algorithms.
4. **Missing Functions**: Ensure you're only using the functions and utilities available in the sandbox.
5. **Invalid Arguments**: Check that function arguments are valid (e.g., colors are RGB lists with values 0-255).

## Conclusion

The Python sandbox provides a powerful way to create complex and dynamic light sequences while maintaining security. By allowing the LLM to generate and execute Python code, it opens up new possibilities for creative sequence design that would be difficult to achieve with the standard tools alone.