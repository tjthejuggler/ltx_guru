"""
Sequence Maker - Sandbox Manager

This module defines the SandboxManager class for securely executing Python code
generated by the LLM for creating complex light sequences.
"""

import logging
import time
import threading
from typing import Dict, List, Any, Optional, Union, Tuple
import numpy as np

from RestrictedPython import compile_restricted
from RestrictedPython.Guards import safe_builtins, full_write_guard
from RestrictedPython.Eval import default_guarded_getiter
from RestrictedPython.Guards import guarded_iter_unpack_sequence, guarded_unpack_sequence

from utils.color_utils import (
    rgb_to_hsv, 
    hsv_to_rgb, 
    interpolate_color, 
    resolve_color_name
)


class SandboxManager:
    """
    Manages secure execution of Python code generated by the LLM.
    
    This class provides a restricted execution environment (sandbox) for running
    Python code that can create complex light sequences while maintaining security.
    """
    
    def __init__(self, app):
        """
        Initialize the sandbox manager.
        
        Args:
            app: The main application instance.
        """
        self.app = app
        self.logger = logging.getLogger("SequenceMaker.SandboxManager")
        self.logger.debug("Initializing SandboxManager")
        
        # Maximum execution time in seconds (temporarily increased for debugging)
        self.max_execution_time = 30.0  # Increased from 5.0 to 30.0 for debugging
        
    def execute_sandboxed_code(self, code_string: str, available_context: Dict[str, Any]) -> Dict[str, Any]:
        """
        Execute Python code in a restricted sandbox environment.
        
        Args:
            code_string: The Python code to execute.
            available_context: Dictionary containing read-only data the code might need.
            
        Returns:
            dict: Result of the execution, including success status and any errors.
        """
        try:
            self.logger.info("=== STARTING SANDBOX EXECUTION ===")
            self.logger.debug("Executing sandboxed code")
            self.logger.debug(f"Code to execute:\n{code_string}")
            self.logger.debug(f"Available context: {available_context}")
            
            # Create safe wrappers for application functions
            self.logger.debug("Creating safe wrappers")
            safe_wrappers = self._create_safe_wrappers()
            
            # Create safe utility functions
            self.logger.debug("Creating safe utilities")
            safe_utilities = self._create_safe_utilities()
            
            # Combine with available context
            self.logger.debug("Creating sandbox globals")
            sandbox_globals = self._create_sandbox_globals(safe_wrappers, safe_utilities, available_context)
            
            # Compile the code in restricted mode
            self.logger.debug("Compiling restricted code")
            try:
                restricted_byte_code = compile_restricted(
                    code_string,
                    filename='<llm_generated_code>',
                    mode='exec'
                )
                self.logger.debug("Code compiled successfully")
            except Exception as compile_error:
                self.logger.error(f"Compilation error: {compile_error}", exc_info=True)
                return {
                    "success": False,
                    "error_type": "CompilationError",
                    "error_message": str(compile_error)
                }
            
            # Execute the compiled code with timeout
            self.logger.debug("Executing compiled code with timeout")
            result = self._execute_with_timeout(restricted_byte_code, sandbox_globals)
            self.logger.info(f"=== SANDBOX EXECUTION COMPLETED === Result: {result}")
            
            return result
        except Exception as e:
            self.logger.error(f"Unexpected error in execute_sandboxed_code: {e}", exc_info=True)
            return {
                "success": False,
                "error_type": "UnexpectedError",
                "error_message": f"Unexpected error in sandbox execution: {str(e)}"
            }
    
    def _create_safe_wrappers(self) -> Dict[str, Any]:
        """
        Create safe wrappers for application functions.
        
        Returns:
            dict: Dictionary of safe wrapper functions.
        """
        safe_wrappers = {}
        
        # Safe wrapper for create_segment
        def safe_create_segment(timeline_index, start_time, end_time, color):
            # Argument validation
            if not isinstance(timeline_index, int):
                raise TypeError("timeline_index must be an integer")
            
            if timeline_index < 0 or (hasattr(self.app, 'timeline_manager') and 
                                     timeline_index >= len(self.app.timeline_manager.get_timelines())):
                raise ValueError(f"Invalid timeline_index: Must be between 0 and {len(self.app.timeline_manager.get_timelines())-1}")
            
            if not isinstance(start_time, (int, float)) or start_time < 0:
                raise ValueError("start_time must be a non-negative number")
            
            if not isinstance(end_time, (int, float)) or end_time <= start_time:
                raise ValueError("end_time must be a number greater than start_time")
            
            if not isinstance(color, (list, tuple)) or len(color) != 3 or not all(isinstance(c, int) and 0 <= c <= 255 for c in color):
                raise TypeError("color must be a list or tuple of 3 integers between 0 and 255")
            
            # Call the actual application function
            try:
                timeline = self.app.timeline_manager.get_timeline(timeline_index)
                if not timeline:
                    raise ValueError(f"Timeline with index {timeline_index} not found")
                
                segment = self.app.timeline_manager.add_segment(
                    timeline, 
                    start_time, 
                    end_time, 
                    tuple(color)
                )
                
                if segment:
                    return {
                        "segment_created": True,
                        "timeline_index": timeline_index,
                        "start_time": start_time,
                        "end_time": end_time,
                        "color": color
                    }
                else:
                    return {"segment_created": False, "error": "Failed to create segment"}
            except Exception as e:
                self.logger.error(f"Error in safe_create_segment: {e}")
                raise RuntimeError(f"Error creating segment: {str(e)}")
        
        # Safe wrapper for clear_timeline
        def safe_clear_timeline(timeline_index):
            # Argument validation
            if not isinstance(timeline_index, int):
                raise TypeError("timeline_index must be an integer")
            
            if timeline_index < 0 or (hasattr(self.app, 'timeline_manager') and 
                                     timeline_index >= len(self.app.timeline_manager.get_timelines())):
                raise ValueError(f"Invalid timeline_index: Must be between 0 and {len(self.app.timeline_manager.get_timelines())-1}")
            
            # Call the actual application function
            try:
                self.logger.debug(f"Clearing timeline with index {timeline_index}")
                timeline = self.app.timeline_manager.get_timeline(timeline_index)
                if not timeline:
                    raise ValueError(f"Timeline with index {timeline_index} not found")
                
                # Save the number of segments for reporting
                original_segment_count = len(timeline.segments)
                
                # Use the timeline's clear method directly
                timeline.clear()
                
                # Emit signal to notify UI of the change
                self.app.timeline_manager.timeline_modified.emit(timeline)
                
                self.logger.debug(f"Timeline {timeline_index} cleared, removed {original_segment_count} segments")
                return {
                    "timeline_cleared": True,
                    "timeline_index": timeline_index,
                    "segments_removed": original_segment_count
                }
            except Exception as e:
                self.logger.error(f"Error in safe_clear_timeline: {e}", exc_info=True)
                raise RuntimeError(f"Error clearing timeline: {str(e)}")
        
        # Safe wrapper for modify_segment
        def safe_modify_segment(timeline_index, segment_index, start_time=None, end_time=None, color=None):
            # Argument validation
            if not isinstance(timeline_index, int):
                raise TypeError("timeline_index must be an integer")
            
            if not isinstance(segment_index, int):
                raise TypeError("segment_index must be an integer")
            
            if start_time is not None and (not isinstance(start_time, (int, float)) or start_time < 0):
                raise ValueError("start_time must be a non-negative number")
            
            if end_time is not None and not isinstance(end_time, (int, float)):
                raise ValueError("end_time must be a number")
            
            if color is not None and (not isinstance(color, (list, tuple)) or len(color) != 3 or 
                                     not all(isinstance(c, int) and 0 <= c <= 255 for c in color)):
                raise TypeError("color must be a list or tuple of 3 integers between 0 and 255")
            
            # Call the actual application function
            try:
                timeline = self.app.timeline_manager.get_timeline(timeline_index)
                if not timeline:
                    raise ValueError(f"Timeline with index {timeline_index} not found")
                
                if segment_index < 0 or segment_index >= len(timeline.segments):
                    raise ValueError(f"Invalid segment_index: Must be between 0 and {len(timeline.segments)-1}")
                
                segment = timeline.segments[segment_index]
                
                # Ensure end_time > start_time if both are provided
                if start_time is not None and end_time is not None and end_time <= start_time:
                    raise ValueError("end_time must be greater than start_time")
                
                # If only one of start_time or end_time is provided, check against the existing value
                if start_time is not None and end_time is None and start_time >= segment.end_time:
                    raise ValueError(f"start_time ({start_time}) must be less than current end_time ({segment.end_time})")
                
                if end_time is not None and start_time is None and end_time <= segment.start_time:
                    raise ValueError(f"end_time ({end_time}) must be greater than current start_time ({segment.start_time})")
                
                result = self.app.timeline_manager.modify_segment(
                    timeline,
                    segment,
                    start_time=start_time,
                    end_time=end_time,
                    color=tuple(color) if color is not None else None
                )
                
                return {
                    "segment_modified": result,
                    "timeline_index": timeline_index,
                    "segment_index": segment_index,
                    "start_time": start_time if start_time is not None else segment.start_time,
                    "end_time": end_time if end_time is not None else segment.end_time,
                    "color": color if color is not None else list(segment.color)
                }
            except Exception as e:
                self.logger.error(f"Error in safe_modify_segment: {e}")
                raise RuntimeError(f"Error modifying segment: {str(e)}")
        
        # Safe wrapper for delete_segment
        def safe_delete_segment(timeline_index, segment_index):
            # Argument validation
            if not isinstance(timeline_index, int):
                raise TypeError("timeline_index must be an integer")
            
            if not isinstance(segment_index, int):
                raise TypeError("segment_index must be an integer")
            
            # Call the actual application function
            try:
                timeline = self.app.timeline_manager.get_timeline(timeline_index)
                if not timeline:
                    raise ValueError(f"Timeline with index {timeline_index} not found")
                
                if segment_index < 0 or segment_index >= len(timeline.segments):
                    raise ValueError(f"Invalid segment_index: Must be between 0 and {len(timeline.segments)-1}")
                
                segment = timeline.segments[segment_index]
                
                result = self.app.timeline_manager.remove_segment(timeline, segment)
                
                return {
                    "segment_deleted": result,
                    "timeline_index": timeline_index,
                    "segment_index": segment_index
                }
            except Exception as e:
                self.logger.error(f"Error in safe_delete_segment: {e}", exc_info=True)
                raise RuntimeError(f"Error deleting segment: {str(e)}")
        
        # Safe wrapper for get_word_timestamps
        def safe_get_word_timestamps(word, start_time=None, end_time=None, limit=None):
            # Argument validation
            if not isinstance(word, str):
                raise TypeError("word must be a string")
            
            if start_time is not None and not isinstance(start_time, (int, float)):
                raise TypeError("start_time must be a number")
            
            if end_time is not None and not isinstance(end_time, (int, float)):
                raise TypeError("end_time must be a number")
            
            if limit is not None and not isinstance(limit, int):
                raise TypeError("limit must be an integer")
            
            # Call the actual application function
            try:
                self.logger.debug(f"safe_get_word_timestamps called with word='{word}', start={start_time}, end={end_time}, limit={limit}")
                
                # Check if lyrics manager is available
                if not hasattr(self.app, 'lyrics_manager'):
                    self.logger.warning("Lyrics manager not available")
                    return []
                
                # Check if project has lyrics
                if not hasattr(self.app.project_manager, 'current_project') or not self.app.project_manager.current_project:
                    self.logger.warning("No project loaded")
                    return []
                
                project = self.app.project_manager.current_project
                if not hasattr(project, 'lyrics') or not project.lyrics:
                    self.logger.warning("No lyrics loaded")
                    return []
                
                lyrics = project.lyrics
                if not hasattr(lyrics, 'word_timestamps') or not lyrics.word_timestamps:
                    self.logger.warning("Lyrics do not have timestamps")
                    return []
                
                # Get word timestamps
                word_timestamps = []
                self.logger.debug(f"Searching for word '{word}' in {len(lyrics.word_timestamps)} word timestamps")
                for w in lyrics.word_timestamps:
                    if hasattr(w, 'word') and w.word.lower() == word.lower() and hasattr(w, 'start') and w.start is not None:
                        self.logger.debug(f"Found match: {w.word} at {w.start}-{w.end}")
                        # Apply time filtering if provided
                        if start_time is not None and w.start < start_time:
                            self.logger.debug(f"Skipping match at {w.start} (before start_time {start_time})")
                            continue
                        if end_time is not None and w.start > end_time:
                            self.logger.debug(f"Skipping match at {w.start} (after end_time {end_time})")
                            continue
                        
                        word_timestamps.append({
                            "word": w.word,
                            "start_time": w.start,
                            "end_time": w.end
                        })
                
                # Apply limit if provided
                if limit is not None and len(word_timestamps) > limit:
                    self.logger.debug(f"Limiting results from {len(word_timestamps)} to {limit}")
                    word_timestamps = word_timestamps[:limit]
                
                self.logger.debug(f"safe_get_word_timestamps returning {len(word_timestamps)} timestamps.")
                return word_timestamps
            except Exception as e:
                self.logger.error(f"Error inside safe_get_word_timestamps logic: {e}", exc_info=True)
                raise RuntimeError(f"Error getting word timestamps: {str(e)}")
        
        # Safe wrapper for get_lyrics_info
        def safe_get_lyrics_info():
            """Get information about the current lyrics."""
            try:
                if not hasattr(self.app, 'lyrics_manager'):
                    raise RuntimeError("Lyrics manager not available")
                
                # Check if the project has lyrics data
                if not hasattr(self.app.project_manager, 'current_project') or not self.app.project_manager.current_project:
                    raise RuntimeError("No project loaded")
                
                project = self.app.project_manager.current_project
                if not hasattr(project, 'lyrics') or not project.lyrics:
                    raise RuntimeError("No lyrics loaded")
                
                lyrics = project.lyrics
                
                # Get basic lyrics information
                lyrics_text = lyrics.text if hasattr(lyrics, 'text') else ""
                
                # Get word timestamps
                word_timestamps = []
                unique_words = set()  # Set of unique word strings
                if hasattr(lyrics, 'word_timestamps') and lyrics.word_timestamps:
                    for word in lyrics.word_timestamps:
                        if hasattr(word, 'word') and hasattr(word, 'start') and hasattr(word, 'end'):
                            word_str = word.word
                            unique_words.add(word_str)
                            word_timestamps.append({
                                "word": word_str,
                                "start_time": word.start,
                                "end_time": word.end,
                                "line_index": getattr(word, 'line_index', 0),
                                "word_index": getattr(word, 'word_index', 0)
                            })
                
                return {
                    "has_lyrics": True,
                    "text": lyrics_text,
                    "words": word_timestamps,
                    "word_count": len(word_timestamps),
                    "unique_words": list(unique_words)  # List of unique word strings
                }
            except Exception as e:
                self.logger.error(f"Error in safe_get_lyrics_info: {e}")
                raise RuntimeError(f"Error getting lyrics info: {str(e)}")
        
        # Safe wrapper for find_first_word
        def safe_find_first_word():
            """Find the first word in the lyrics."""
            try:
                if not hasattr(self.app, 'lyrics_manager'):
                    raise RuntimeError("Lyrics manager not available")
                
                # Check if the project has lyrics data
                if not hasattr(self.app.project_manager, 'current_project') or not self.app.project_manager.current_project:
                    raise RuntimeError("No project loaded")
                
                project = self.app.project_manager.current_project
                if not hasattr(project, 'lyrics') or not project.lyrics:
                    raise RuntimeError("No lyrics loaded")
                
                lyrics = project.lyrics
                
                # Find the first word with a timestamp
                first_word = None
                if hasattr(lyrics, 'word_timestamps') and lyrics.word_timestamps:
                    for word in lyrics.word_timestamps:
                        if hasattr(word, 'start') and word.start is not None:
                            first_word = word
                            break
                
                if first_word is None:
                    raise RuntimeError("No words with timestamps found")
                
                return {
                    "word": first_word.word if hasattr(first_word, 'word') else "",
                    "start_time": first_word.start,
                    "end_time": first_word.end,
                    "line_index": getattr(first_word, 'line_index', 0),
                    "word_index": getattr(first_word, 'word_index', 0)
                }
            except Exception as e:
                self.logger.error(f"Error in safe_find_first_word: {e}")
                raise RuntimeError(f"Error finding first word: {str(e)}")
        
        # Add wrappers to the dictionary
        safe_wrappers["create_segment"] = safe_create_segment
        safe_wrappers["clear_timeline"] = safe_clear_timeline
        safe_wrappers["modify_segment"] = safe_modify_segment
        safe_wrappers["delete_segment"] = safe_delete_segment
        safe_wrappers["get_word_timestamps"] = safe_get_word_timestamps
        safe_wrappers["get_lyrics_info"] = safe_get_lyrics_info
        safe_wrappers["find_first_word"] = safe_find_first_word
        
        return safe_wrappers
    
    def _create_safe_utilities(self) -> Dict[str, Any]:
        """
        Create safe utility functions for the sandbox.
        
        Returns:
            dict: Dictionary of safe utility functions.
        """
        safe_utilities = {}
        
        # Safe random color generator
        def safe_random_color():
            import random
            return [random.randint(0, 255), random.randint(0, 255), random.randint(0, 255)]
        
        # Safe random float generator
        def safe_random_float(min_val, max_val):
            import random
            if not isinstance(min_val, (int, float)) or not isinstance(max_val, (int, float)):
                raise TypeError("min_val and max_val must be numbers")
            if min_val >= max_val:
                raise ValueError("min_val must be less than max_val")
            return random.uniform(min_val, max_val)
        
        # Safe color interpolation
        def safe_interpolate_color(color1, color2, factor):
            if not isinstance(color1, (list, tuple)) or len(color1) != 3 or not all(isinstance(c, int) and 0 <= c <= 255 for c in color1):
                raise TypeError("color1 must be a list or tuple of 3 integers between 0 and 255")
            if not isinstance(color2, (list, tuple)) or len(color2) != 3 or not all(isinstance(c, int) and 0 <= c <= 255 for c in color2):
                raise TypeError("color2 must be a list or tuple of 3 integers between 0 and 255")
            if not isinstance(factor, (int, float)) or not 0 <= factor <= 1:
                raise ValueError("factor must be a number between 0 and 1")
            
            result = interpolate_color(color1, color2, factor)
            return list(result)
        
        # Safe HSV to RGB conversion
        def safe_hsv_to_rgb(h, s, v):
            if not isinstance(h, (int, float)) or not 0 <= h <= 360:
                raise ValueError("h must be a number between 0 and 360")
            if not isinstance(s, (int, float)) or not 0 <= s <= 1:
                raise ValueError("s must be a number between 0 and 1")
            if not isinstance(v, (int, float)) or not 0 <= v <= 1:
                raise ValueError("v must be a number between 0 and 1")
            
            result = hsv_to_rgb(h, s, v)
            return list(result)
        
        # Safe RGB to HSV conversion
        def safe_rgb_to_hsv(r, g, b):
            if not isinstance(r, int) or not 0 <= r <= 255:
                raise ValueError("r must be an integer between 0 and 255")
            if not isinstance(g, int) or not 0 <= g <= 255:
                raise ValueError("g must be an integer between 0 and 255")
            if not isinstance(b, int) or not 0 <= b <= 255:
                raise ValueError("b must be an integer between 0 and 255")
            
            result = rgb_to_hsv(r, g, b)
            return list(result)
        
        # Safe color name resolver
        def safe_color_from_name(color_name):
            if not isinstance(color_name, str):
                raise TypeError("color_name must be a string")
            
            result = resolve_color_name(color_name)
            return list(result)
        
        # Safe print function
        def safe_print(*args, **kwargs):
            try:
                # Convert all arguments to strings and join them
                output = " ".join(str(arg) for arg in args)
                self.logger.info(f"Sandbox print: {output}")
                return None  # Print should return None, not the output string
            except Exception as e:
                self.logger.error(f"Error in safe_print: {e}")
                return None
        
        # Add utilities to the dictionary
        safe_utilities["random_color"] = safe_random_color
        safe_utilities["random_float"] = safe_random_float
        safe_utilities["interpolate_color"] = safe_interpolate_color
        safe_utilities["hsv_to_rgb"] = safe_hsv_to_rgb
        safe_utilities["rgb_to_hsv"] = safe_rgb_to_hsv
        safe_utilities["color_from_name"] = safe_color_from_name
        safe_utilities["print"] = safe_print
        
        return safe_utilities
    
    def _create_sandbox_globals(self, safe_wrappers: Dict[str, Any], safe_utilities: Dict[str, Any], 
                               available_context: Dict[str, Any]) -> Dict[str, Any]:
        """
        Create the global environment for the sandbox.
        
        Args:
            safe_wrappers: Dictionary of safe wrapper functions.
            safe_utilities: Dictionary of safe utility functions.
            available_context: Dictionary of read-only data.
            
        Returns:
            dict: The global environment for the sandbox.
        """
        # Start with a minimal set of safe builtins
        sandbox_globals = safe_builtins.copy()
        
        # Add safe wrappers
        sandbox_globals.update(safe_wrappers)
        
        # Add safe utilities
        sandbox_globals.update(safe_utilities)
        
        # Note: We're not overriding RestrictedPython's internal print handler (_print_)
        # to avoid compatibility issues. Instead, we rely on the default safe implementation
        # provided by safe_builtins, while still providing our 'print' function for logging.
        
        # Add safe built-ins
        sandbox_globals.update({
            'range': range,
            'len': len,
            'list': list,
            'dict': dict,
            'tuple': tuple,
            'int': int,
            'float': float,
            'str': str,
            'bool': bool,
            'min': min,
            'max': max,
            'sum': sum,
            'abs': abs,
            'round': round,
            'enumerate': enumerate,  # Added enumerate for iteration
            'zip': zip,              # Added zip for iteration
            'isinstance': isinstance, # Added isinstance for type checking
            'None': None,
            'True': True,
            'False': False,
        })
        
        # Add math functions
        import math
        sandbox_globals.update({
            'sin': math.sin,
            'cos': math.cos,
            'tan': math.tan,
            'pi': math.pi,
            'sqrt': math.sqrt,
            'floor': math.floor,
            'ceil': math.ceil,
        })
        
        # Add read-only context data
        for key, value in available_context.items():
            # Make a copy of mutable objects to prevent modification
            if isinstance(value, list):
                sandbox_globals[key] = value.copy()
            elif isinstance(value, dict):
                sandbox_globals[key] = value.copy()
            else:
                sandbox_globals[key] = value
        
        return sandbox_globals
    
    def _execute_with_timeout(self, code, globals_dict: Dict[str, Any]) -> Dict[str, Any]:
        """
        Execute code with a timeout.
        
        Args:
            code: Compiled code to execute.
            globals_dict: Global environment for execution.
            
        Returns:
            dict: Result of the execution.
        """
        result = {
            "success": False,
            "result": None,
            "error_type": None,
            "error_message": None
        }
        
        # Create a dictionary to store execution results
        execution_result = {"completed": False, "exception": None}
        
        # Define the execution function
        def execute():
            try:
                # Set up the restricted environment
                restricted_locals = {}
                
                # Add guard functions directly to globals_dict
                # This is the key fix - we use globals_dict directly as the global namespace
                # instead of nesting it under '__builtins__'
                # Define a custom _getitem_ guard function
                def _getitem_(obj, key):
                    # This allows safe access to list and dictionary items
                    if isinstance(obj, (list, tuple)) and isinstance(key, int):
                        if 0 <= key < len(obj):
                            return obj[key]
                        else:
                            raise IndexError(f"Index {key} out of range for sequence of length {len(obj)}")
                    elif isinstance(obj, dict):
                        if key in obj:
                            return obj[key]
                        else:
                            raise KeyError(key)
                    else:
                        # For other types, just use standard item access
                        return obj[key]
                
                globals_dict['_getiter_'] = default_guarded_getiter
                globals_dict['_iter_unpack_sequence_'] = guarded_iter_unpack_sequence
                globals_dict['_unpack_sequence_'] = guarded_unpack_sequence
                globals_dict['_write_'] = full_write_guard
                globals_dict['_getitem_'] = _getitem_  # Add our custom item access guard
                # Print support is now handled in _create_sandbox_globals
                
                # Log the keys in globals_dict to verify our functions are accessible
                self.logger.debug(f"Sandbox globals keys: {list(globals_dict.keys())}")
                
                # Execute the code with globals_dict directly as the global namespace
                self.logger.debug("About to execute sandboxed code")
                exec(code, globals_dict, restricted_locals)
                self.logger.debug("Sandboxed code execution completed")
                
                # Store any results in the execution_result
                execution_result["completed"] = True
                execution_result["locals"] = restricted_locals
            except Exception as e:
                self.logger.error(f"Error in sandboxed code execution: {str(e)}", exc_info=True)
                execution_result["exception"] = e
                execution_result["error_details"] = {
                    "type": type(e).__name__,
                    "message": str(e)
                }
        
        # Create and start the execution thread
        execution_thread = threading.Thread(target=execute)
        execution_thread.daemon = True
        execution_thread.start()
        
        # Wait for the thread to complete or timeout
        execution_thread.join(self.max_execution_time)
        
        # Check if the execution completed or timed out
        if execution_thread.is_alive():
            # Execution timed out
            result["error_type"] = "TimeoutError"
            result["error_message"] = f"Execution timed out after {self.max_execution_time} seconds"
            self.logger.warning(f"Sandbox execution timed out after {self.max_execution_time} seconds")
        elif "exception" in execution_result and execution_result["exception"] is not None:
            # Execution raised an exception
            exception = execution_result["exception"]
            result["error_type"] = type(exception).__name__
            result["error_message"] = str(exception)
            
            # Include error details in the result if available
            if "error_details" in execution_result:
                result["error_details"] = execution_result["error_details"]
                self.logger.error(
                    f"Sandbox execution error: {execution_result['error_details']['type']}: {execution_result['error_details']['message']}",
                    exc_info=True
                )
            else:
                self.logger.error(f"Sandbox execution error: {type(exception).__name__}: {str(exception)}", exc_info=True)
        else:
            # Execution completed successfully
            result["success"] = True
            result["result"] = "Code executed successfully"
            
            # If there are locals, include them in the result
            if "locals" in execution_result and execution_result["locals"]:
                # Filter out private variables
                public_locals = {k: v for k, v in execution_result["locals"].items() if not k.startswith('_')}
                if public_locals:
                    result["variables"] = public_locals
            
            self.logger.debug("Sandbox execution completed successfully")
        
        return result