# Official LTX App PRG File Test Dumps and Analysis

**Last Updated:** 2025-06-01 10:58 UTC+7

This document records hex dumps from `.prg` files generated by the official LTX application. These serve as a ground truth for reverse-engineering and validating the PRG file format, especially for conditional header fields.

All examples below were generated with a 4-pixel setting and a 1Hz refresh rate, unless otherwise specified.

## Single Segment, 1Hz Refresh Rate Examples

These examples show how header fields `0x16` and `0x1E` behave for single-segment files with varying durations at a 1Hz PRG refresh rate.

**Common Header Values for N=1, 1Hz Refresh Rate, 4px:**
*   `0x00-0x07`: `50 52 03 49 4E 05 00 00` (Signature)
*   `0x08-0x09`: `00 04` (Default Pixels = 4, Big Endian)
*   `0x0A-0x0B`: `00 08` (Constant)
*   `0x0C-0x0D`: `01 00` (Refresh Rate = 1Hz, Little Endian)
*   `0x0E-0x0F`: `50 49` ('PI' Marker)
*   `0x10-0x13`: `15 00 00 00` (Pointer1 = 21, for N=1)
*   `0x14-0x15`: `01 00` (Segment Count N = 1)
*   `0x18-0x19`: `64 00` (RGB Data Repetition Count = 100)
*   `0x1A-0x1B`: `33 00` (RGB Data Start Offset = 51, for N=1)
*   `0x1C-0x1D`: `00 00` (Constant)

### 1s (Duration `Dur0Units_actual` = 1)
```
0000:0000 | 50 52 03 49  4E 05 00 00  00 04 00 08  01 00 50 49 | PR.IN.........PI
0000:0010 | 15 00 00 00  01 00 00 00  64 00 33 00  00 00 01 00 | ........d.3.....
```
*   `0x16-0x17`: `00 00` (Field 0x16 Value = 0)
*   `0x1E-0x1F`: `01 00` (Field 0x1E Value = 1)

### 2s (Duration `Dur0Units_actual` = 2)
```
0000:0000 | 50 52 03 49  4E 05 00 00  00 04 00 08  01 00 50 49 | PR.IN.........PI
0000:0010 | 15 00 00 00  01 00 00 00  64 00 33 00  00 00 02 00 | ........d.3.....
```
*   `0x16-0x17`: `00 00` (Field 0x16 Value = 0)
*   `0x1E-0x1F`: `02 00` (Field 0x1E Value = 2)

### 10s (Duration `Dur0Units_actual` = 10)
```
0000:0000 | 50 52 03 49  4E 05 00 00  00 04 00 08  01 00 50 49 | PR.IN.........PI
0000:0010 | 15 00 00 00  01 00 00 00  64 00 33 00  00 00 0A 00 | ........d.3.....
```
*   `0x16-0x17`: `00 00` (Field 0x16 Value = 0)
*   `0x1E-0x1F`: `0A 00` (Field 0x1E Value = 10)

### 50s (Duration `Dur0Units_actual` = 50)
```
0000:0000 | 50 52 03 49  4E 05 00 00  00 04 00 08  01 00 50 49 | PR.IN.........PI
0000:0010 | 15 00 00 00  01 00 00 00  64 00 33 00  00 00 32 00 | ........d.3...2.
```
*   `0x16-0x17`: `00 00` (Field 0x16 Value = 0)
*   `0x1E-0x1F`: `32 00` (Field 0x1E Value = 50)

### 99s (Duration `Dur0Units_actual` = 99)
```
0000:0000 | 50 52 03 49  4E 05 00 00  00 04 00 08  01 00 50 49 | PR.IN.........PI
0000:0010 | 15 00 00 00  01 00 00 00  64 00 33 00  00 00 63 00 | ........d.3...c.
```
*   `0x16-0x17`: `00 00` (Field 0x16 Value = 0)
*   `0x1E-0x1F`: `63 00` (Field 0x1E Value = 99)

### 100s (Duration `Dur0Units_actual` = 100)
```
0000:0000 | 50 52 03 49  4E 05 00 00  00 04 00 08  01 00 50 49 | PR.IN.........PI
0000:0010 | 15 00 00 00  01 00 01 00  64 00 33 00  00 00 00 00 | ........d.3.....
```
*   `0x16-0x17`: `01 00` (Field 0x16 Value = 1)
*   `0x1E-0x1F`: `00 00` (Field 0x1E Value = 0)

### 101s (Duration `Dur0Units_actual` = 101)
```
0000:0000 | 50 52 03 49  4E 05 00 00  00 04 00 08  01 00 50 49 | PR.IN.........PI
0000:0010 | 15 00 00 00  01 00 01 00  64 00 33 00  00 00 01 00 | ........d.3.....
```
*   `0x16-0x17`: `01 00` (Field 0x16 Value = 1)
*   `0x1E-0x1F`: `01 00` (Field 0x1E Value = 1)

### 200s (Duration `Dur0Units_actual` = 200)
```
0000:0000 | 50 52 03 49  4E 05 00 00  00 04 00 08  01 00 50 49 | PR.IN.........PI
0000:0010 | 15 00 00 00  01 00 02 00  64 00 33 00  00 00 00 00 | ........d.3.....
```
*   `0x16-0x17`: `02 00` (Field 0x16 Value = 2)
*   `0x1E-0x1F`: `00 00` (Field 0x1E Value = 0)

## Multi-Segment, 1Hz Refresh Rate Examples

### red_1s_blue_1s_1r.prg (N=2, Dur0Units_actual=1)
```
0000:0000 | 50 52 03 49  4E 05 00 00  00 04 00 08  01 00 50 49 | PR.IN.........PI
0000:0010 | 28 00 00 00  02 00 00 00  64 00 46 00  00 00 01 00 | (.......d.F.....
0000:0020 | 04 00 01 00  00 01 00 00  00 00 00 64  00 72 01 00 | ...........d.r..
0000:0030 | 00 01 00 04  00 01 00 00  01 00 00 00  43 44 5C 02 | ............CD\.
```
*   `0x14-0x15`: `02 00` (Segment Count N = 2)
*   `0x16-0x17`: `00 00` (Field 0x16 Value = 0)
*   `0x1E-0x1F`: `01 00` (Field 0x1E Value = 1)

### red_1s_blue_1s_green_1s_1r.prg (N=3, Dur0Units_actual=1)
```
0000:0000 | 50 52 03 49  4E 05 00 00  00 04 00 08  01 00 50 49 | PR.IN.........PI
0000:0010 | 3B 00 00 00  03 00 00 00  64 00 59 00  00 00 01 00 | ;.......d.Y.....
0000:0020 | 04 00 01 00  00 01 00 00  00 00 00 64  00 85 01 00 | ...........d....
```
*   `0x14-0x15`: `03 00` (Segment Count N = 3)
*   `0x16-0x17`: `00 00` (Field 0x16 Value = 0)
*   `0x1E-0x1F`: `01 00` (Field 0x1E Value = 1)

### red_1s_blue_2s_1r.prg (N=2, Dur0Units_actual=1)
Same header as `red_1s_blue_1s_1r.prg` for fields 0x16 and 0x1E.
```
0000:0000 | 50 52 03 49  4E 05 00 00  00 04 00 08  01 00 50 49 | PR.IN.........PI
0000:0010 | 28 00 00 00  02 00 00 00  64 00 46 00  00 00 01 00 | (.......d.F.....
```
*   `0x16-0x17`: `00 00`
*   `0x1E-0x1F`: `01 00`

### red_50s_blue_50s_1r.prg (N=2, Dur0Units_actual=50)
```
0000:0000 | 50 52 03 49  4E 05 00 00  00 04 00 08  01 00 50 49 | PR.IN.........PI
0000:0010 | 28 00 00 00  02 00 00 00  64 00 46 00  00 00 32 00 | (.......d.F...2.
```
*   `0x16-0x17`: `00 00` (Field 0x16 Value = 0)
*   `0x1E-0x1F`: `32 00` (Field 0x1E Value = 50)

### red_100s_blue_50s_1r.prg (N=2, Dur0Units_actual=100)
```
0000:0000 | 50 52 03 49  4E 05 00 00  00 04 00 08  01 00 50 49 | PR.IN.........PI
0000:0010 | 28 00 00 00  02 00 01 00  64 00 46 00  00 00 00 00 | (.......d.F.....
```
*   `0x16-0x17`: `01 00` (Field 0x16 Value = 1)
*   `0x1E-0x1F`: `00 00` (Field 0x1E Value = 0)


## Deduced Logic for Header Fields 0x16 and 0x1E

Let:
*   `Dur0Units_actual`: The duration of the first PRG segment in PRG time units.
*   `N_prg`: The total number of PRG segments in the file.
*   `val_0x16_dec`: The decimal value calculated for field `0x16`.

**Field `0x16` (Header First Segment Info):**
1.  If `N_prg == 1`:
    *   `val_0x16_dec = floor(Dur0Units_actual / 100)`
2.  Else (`N_prg > 1`):
    *   If `Dur0Units_actual == 100`: `val_0x16_dec = 1`
    *   Else (`Dur0Units_actual != 100`): `val_0x16_dec = 0`
*   The byte value written to the file is `struct.pack('<H', val_0x16_dec)`.

**Field `0x1E` (Header First Segment Duration (Conditional)):**
1.  If `N_prg == 1`:
    *   `val_0x1E_dec = Dur0Units_actual - (val_0x16_dec * 100)`
      (Note: `val_0x16_dec` is the decimal value calculated for field `0x16` above)
2.  Else (`N_prg > 1`):
    *   If `Dur0Units_actual == 100`: `val_0x1E_dec = 0`
    *   Else (`Dur0Units_actual != 100`): `val_0x1E_dec = Dur0Units_actual`
*   The byte value written to the file is `struct.pack('<H', val_0x1E_dec & 0xFFFF)`.

This logic appears consistent with all provided 1Hz examples.

---

## Important Finding: 1Hz PRG with 100 Color Slots Experiment (Failed)

**Date:** 2025-06-01

An experiment was conducted using a modified generator (`prg_generator_new.py`) that produced PRG files with a 1Hz master refresh rate. The intention was to use the 100 RGB color data slots within each 1-second PRG segment to achieve 0.01s granularity.

**Observation:** The LTX ball firmware appears to **only use the first RGB color** from the 300-byte (100x3 RGB) color data block when the PRG file's refresh rate is 1Hz. The remaining 99 color slots are ignored for display purposes in this mode.

**Example JSON that resulted in solid yellow (not yellow then black):**
```json
{
  "default_pixels": 4,
  "color_format": "rgb",
  "refresh_rate": 100,
  "end_time": 100,
  "sequence": {
    "0": {"color": [255, 255, 0], "pixels": 4},    // Yellow
    "1": {"color": [0, 0, 0], "pixels": 4}         // Black (intended for 0.01s later)
  }
}
```
Resulting PRG (1Hz) showed solid yellow for 1 second.

**Example JSON that resulted in solid red (not red then blue):**
```json
{
  "default_pixels": 4,
  "color_format": "rgb",
  "refresh_rate": 100,
  "end_time": 100,
  "sequence": {
    "0": {"color": [255, 0, 0], "pixels": 4},     // Red
    "50": {"color": [0, 0, 255], "pixels": 4}    // Blue (intended for 0.5s later)
  }
}
```
Resulting PRG (1Hz) showed solid red for 1 second.

**Conclusion:** High-frequency color changes cannot be achieved by manipulating the 100 sub-color slots within a 1Hz PRG segment. A higher PRG refresh rate (e.g., 100Hz or 1000Hz) is necessary for fine-grained temporal resolution.

---

## 1000Hz Refresh Rate Examples (PRG Refresh Rate = 1000)

These examples use a PRG file refresh rate of 1000Hz (`03E8` Little Endian).
All are 4-pixel.

**Common Header Values for 1000Hz Refresh Rate, 4px:**
*   `0x00-0x07`: `50 52 03 49 4E 05 00 00` (Signature)
*   `0x08-0x09`: `00 04` (Default Pixels = 4, Big Endian)
*   `0x0A-0x0B`: `00 08` (Constant)
*   `0x0C-0x0D`: `E8 03` (Refresh Rate = 1000Hz, Little Endian)
*   `0x0E-0x0F`: `50 49` ('PI' Marker)
*   `0x18-0x19`: `64 00` (RGB Data Repetition Count = 100)
*   `0x1C-0x1D`: `00 00` (Constant)

### red_.01s_1000r.prg (N=1, Dur0Units_actual = 10)
*Actual Hex:*
```
0000:0000 | 50 52 03 49  4E 05 00 00  00 04 00 08  E8 03 50 49 | PR.IN.......è.PI
0000:0010 | 15 00 00 00  01 00 00 00  64 00 33 00  00 00 0A 00 | ........d.3.....
```
*   `0x16-0x17`: `00 00` (Value 0)
*   `0x1E-0x1F`: `0A 00` (Value 10)

### red_.1s_1000r.prg (N=1, Dur0Units_actual = 100)
*Actual Hex:*
```
0000:0000 | 50 52 03 49  4E 05 00 00  00 04 00 08  E8 03 50 49 | PR.IN.......è.PI
0000:0010 | 15 00 00 00  01 00 01 00  64 00 33 00  00 00 00 00 | ........d.3.....
```
*   `0x16-0x17`: `01 00` (Value 1)
*   `0x1E-0x1F`: `00 00` (Value 0)

### red_0.5s_1000r.prg (N=1, Dur0Units_actual = 500)
*Actual Hex:*
```
0000:0000 | 50 52 03 49  4E 05 00 00  00 04 00 08  E8 03 50 49 | PR.IN.......è.PI
0000:0010 | 15 00 00 00  01 00 05 00  64 00 33 00  00 00 F4 01 | ........d.3...ô.
```
*   `0x16-0x17`: `05 00` (Value 5)
*   `0x1E-0x1F`: `F4 01` (Value 500)

### red_1s_1000r.prg (N=1, Dur0Units_actual = 1000)
*Actual Hex:*
```
0000:0000 | 50 52 03 49  4E 05 00 00  00 04 00 08  E8 03 50 49 | PR.IN.......è.PI
0000:0010 | 15 00 00 00  01 00 0A 00  64 00 33 00  00 00 E8 03 | ........d.3...è.
```
*   `0x16-0x17`: `0A 00` (Value 10)
*   `0x1E-0x1F`: `E8 03` (Value 1000)

### red_5s_1000r.prg (N=1, Dur0Units_actual = 5000)
*Actual Hex:*
```
0000:0000 | 50 52 03 49  4E 05 00 00  00 04 00 08  E8 03 50 49 | PR.IN.......è.PI
0000:0010 | 15 00 00 00  01 00 32 00  64 00 33 00  00 00 88 13 | ......2.d.3.....
```
*   `0x16-0x17`: `32 00` (Value 50)
*   `0x1E-0x1F`: `88 13` (Value 5000)


### red_10s_1000r.prg (N=1, Dur0Units_actual = 10000)
*Actual Hex:*
```
0000:0000 | 50 52 03 49  4E 05 00 00  00 04 00 08  E8 03 50 49 | PR.IN.......è.PI
0000:0010 | 15 00 00 00  01 00 64 00  64 00 33 00  00 00 10 27 | ......d.d.3....'
```
*   `0x16-0x17`: `64 00` (Value 100)
*   `0x1E-0x1F`: `10 27` (Value 10000)

### red_0.1s_blue_0.1s_1000r.prg (N=2, Dur0Units_actual=100)
*Actual Hex:*
```
0000:0000 | 50 52 03 49  4E 05 00 00  00 04 00 08  E8 03 50 49 | PR.IN.......è.PI
0000:0010 | 28 00 00 00  02 00 01 00  64 00 46 00  00 00 00 00 | (.......d.F.....
```
*   `0x14-0x15` (N): `02 00` (2)
*   `0x16-0x17` (Field 0x16, from Dur0=100): `01 00` (Value 1)
*   `0x1E-0x1F` (Field 0x1E, from Dur0=100): `00 00` (Value 0)


### red_1s_blue_.5s_1000r.prg (N=2, Dur0Units_actual=1000)
*Actual Hex:*
```
0000:0000 | 50 52 03 49  4E 05 00 00  00 04 00 08  E8 03 50 49 | PR.IN.......è.PI
0000:0010 | 28 00 00 00  02 00 0A 00  64 00 46 00  00 00 E8 03 | (.......d.F...è.
```
*   `0x14-0x15` (N): `02 00` (2)
*   `0x16-0x17` (Field 0x16, from Dur0=1000): `0A 00` (Value 10)
*   `0x1E-0x1F` (Field 0x1E, from Dur0=1000): `E8 03` (Value 1000)


## Deduced Logic for Header Fields 0x16 and 0x1E (Hypothesis 8 - Current Best as of 2025-06-01 10:25)

This logic applies universally across different PRG refresh rates and segment counts, based on all provided official app samples.

It's also important to note the structure of certain fields within **Intermediate Duration Blocks** (i.e., not the last duration block):

*   **Field `+0x09` (Segment Index & Duration) (Revised 2025-06-01):**
    This 4-byte field consists of two 2-byte Little Endian values:
    1.  `field_09_part1`:
        *   If it's the first duration block (`current_block_index == 0`): This is `1` (`01 00`).
        *   If `current_block_index > 0` AND `CurrentSegmentDurationUnits == PreviousSegmentDurationUnits`: This value is `CurrentSegmentDurationUnits`.
        *   Else (`current_block_index > 0` AND `CurrentSegmentDurationUnits != PreviousSegmentDurationUnits`): This value is `current_block_index + 1`.
    2.  `field_09_part2`: This is always `CurrentSegmentDurationUnits`.

*   **Field `+0x11` (Next Segment Info) (Revised 2025-06-01):**
    Let `Dur_k` be current segment's duration, `Dur_k+1` be next segment's duration.
    1.  If `Dur_k+1 < 100`: value is `Dur_k+1`.
    2.  Else if `Dur_k+1 == 100`:
        *   If `Dur_k == 100`: value is `Dur_k+1` (i.e., 100).
        *   Else (`Dur_k != 100`): value is `0`.
    3.  Else (`Dur_k+1 > 100`): value is `Dur_k+1`.

This was refined based on the `R0.1_B0.1_G10_1000hz.prg` comparison on 2025-06-01.

Let:
*   `Dur0Units_actual`: The duration of the first PRG segment (Segment 0) in PRG time units.
*   `NominalBase = 100`. This constant is used in the calculations.
*   `val_0x16_dec`: The decimal value calculated for field `0x16`.
*   `val_0x1E_dec`: The decimal value calculated for field `0x1E`.

**Field `0x16` (Header First Segment Info):**
  `val_0x16_dec = floor(Dur0Units_actual / NominalBase)`

**Field `0x1E` (Header First Segment Duration (Conditional)):**
  `val_0x16_for_0x1E_calc = floor(Dur0Units_actual / NominalBase)` (This is the same as `val_0x16_dec`)
  `calculated_remainder = Dur0Units_actual - (val_0x16_for_0x1E_calc * NominalBase)`

  If `calculated_remainder == 0`:
    If `Dur0Units_actual == NominalBase` (i.e., `Dur0Units_actual` is exactly 100):
      `val_0x1E_dec = 0`
    Else (`Dur0Units_actual` is a multiple of 100, but not 100 itself, e.g., 200, 500, 1000):
      `val_0x1E_dec = Dur0Units_actual`
  Else (`calculated_remainder != 0`):
    `val_0x1E_dec = calculated_remainder`

The byte values written to the file are `struct.pack('<H', val_0x16_dec)` and `struct.pack('<H', val_0x1E_dec & 0xFFFF)`.

This logic correctly predicts header fields `0x16` and `0x1E` for all 1Hz and 1000Hz examples provided by the user.

(Old analysis based on Hypothesis 4 removed for clarity)