# Official LTX App PRG File Test Dumps and Analysis

**Last Updated:** 2025-06-02 14:34 UTC+7

This document records hex dumps from `.prg` files generated by the official LTX application. These serve as a ground truth for reverse-engineering and validating the PRG file format, especially for conditional header fields.

All examples below were generated with a 4-pixel setting and a 1Hz refresh rate, unless otherwise specified.

## Single Segment, 1Hz Refresh Rate Examples

These examples show how header fields `0x16` and `0x1E` behave for single-segment files with varying durations at a 1Hz PRG refresh rate.

**Common Header Values for N=1, 1Hz Refresh Rate, 4px:**
*   `0x00-0x07`: `50 52 03 49 4E 05 00 00` (Signature)
*   `0x08-0x09`: `00 04` (Default Pixels = 4, Big Endian)
*   `0x0A-0x0B`: `00 08` (Constant)
*   `0x0C-0x0D`: `01 00` (Refresh Rate = 1Hz, Little Endian)
*   `0x0E-0x0F`: `50 49` ('PI' Marker)
*   `0x10-0x13`: `15 00 00 00` (Pointer1 = 21, for N=1)
*   `0x14-0x15`: `01 00` (Segment Count N = 1)
*   `0x18-0x19`: `64 00` (RGB Data Repetition Count = 100)
*   `0x1A-0x1B`: `33 00` (RGB Data Start Offset = 51, for N=1)
*   `0x1C-0x1D`: `00 00` (Constant)

### 1s (Duration `Dur0Units_actual` = 1)
```
0000:0000 | 50 52 03 49  4E 05 00 00  00 04 00 08  01 00 50 49 | PR.IN.........PI
0000:0010 | 15 00 00 00  01 00 00 00  64 00 33 00  00 00 01 00 | ........d.3.....
```
*   `0x16-0x17`: `00 00` (Field 0x16 Value = 0)
*   `0x1E-0x1F`: `01 00` (Field 0x1E Value = 1)

### 2s (Duration `Dur0Units_actual` = 2)
```
0000:0000 | 50 52 03 49  4E 05 00 00  00 04 00 08  01 00 50 49 | PR.IN.........PI
0000:0010 | 15 00 00 00  01 00 00 00  64 00 33 00  00 00 02 00 | ........d.3.....
```
*   `0x16-0x17`: `00 00` (Field 0x16 Value = 0)
*   `0x1E-0x1F`: `02 00` (Field 0x1E Value = 2)

### 10s (Duration `Dur0Units_actual` = 10)
```
0000:0000 | 50 52 03 49  4E 05 00 00  00 04 00 08  01 00 50 49 | PR.IN.........PI
0000:0010 | 15 00 00 00  01 00 00 00  64 00 33 00  00 00 0A 00 | ........d.3.....
```
*   `0x16-0x17`: `00 00` (Field 0x16 Value = 0)
*   `0x1E-0x1F`: `0A 00` (Field 0x1E Value = 10)

### 50s (Duration `Dur0Units_actual` = 50)
```
0000:0000 | 50 52 03 49  4E 05 00 00  00 04 00 08  01 00 50 49 | PR.IN.........PI
0000:0010 | 15 00 00 00  01 00 00 00  64 00 33 00  00 00 32 00 | ........d.3...2.
```
*   `0x16-0x17`: `00 00` (Field 0x16 Value = 0)
*   `0x1E-0x1F`: `32 00` (Field 0x1E Value = 50)

### 99s (Duration `Dur0Units_actual` = 99)
```
0000:0000 | 50 52 03 49  4E 05 00 00  00 04 00 08  01 00 50 49 | PR.IN.........PI
0000:0010 | 15 00 00 00  01 00 00 00  64 00 33 00  00 00 63 00 | ........d.3...c.
```
*   `0x16-0x17`: `00 00` (Field 0x16 Value = 0)
*   `0x1E-0x1F`: `63 00` (Field 0x1E Value = 99)

### 100s (Duration `Dur0Units_actual` = 100)
```
0000:0000 | 50 52 03 49  4E 05 00 00  00 04 00 08  01 00 50 49 | PR.IN.........PI
0000:0010 | 15 00 00 00  01 00 01 00  64 00 33 00  00 00 00 00 | ........d.3.....
```
*   `0x16-0x17`: `01 00` (Field 0x16 Value = 1)
*   `0x1E-0x1F`: `00 00` (Field 0x1E Value = 0)

### 101s (Duration `Dur0Units_actual` = 101)
```
0000:0000 | 50 52 03 49  4E 05 00 00  00 04 00 08  01 00 50 49 | PR.IN.........PI
0000:0010 | 15 00 00 00  01 00 01 00  64 00 33 00  00 00 01 00 | ........d.3.....
```
*   `0x16-0x17`: `01 00` (Field 0x16 Value = 1)
*   `0x1E-0x1F`: `01 00` (Field 0x1E Value = 1)

### 200s (Duration `Dur0Units_actual` = 200)
```
0000:0000 | 50 52 03 49  4E 05 00 00  00 04 00 08  01 00 50 49 | PR.IN.........PI
0000:0010 | 15 00 00 00  01 00 02 00  64 00 33 00  00 00 00 00 | ........d.3.....
```
*   `0x16-0x17`: `02 00` (Field 0x16 Value = 2)
*   `0x1E-0x1F`: `00 00` (Field 0x1E Value = 0)

## Multi-Segment, 1Hz Refresh Rate Examples

### red_1s_blue_1s_1r.prg (N=2, Dur0Units_actual=1)
```
0000:0000 | 50 52 03 49  4E 05 00 00  00 04 00 08  01 00 50 49 | PR.IN.........PI
0000:0010 | 28 00 00 00  02 00 00 00  64 00 46 00  00 00 01 00 | (.......d.F.....
0000:0020 | 04 00 01 00  00 01 00 00  00 00 00 64  00 72 01 00 | ...........d.r..
0000:0030 | 00 01 00 04  00 01 00 00  01 00 00 00  43 44 5C 02 | ............CD\.
```
*   `0x14-0x15`: `02 00` (Segment Count N = 2)
*   `0x16-0x17`: `00 00` (Field 0x16 Value = 0)
*   `0x1E-0x1F`: `01 00` (Field 0x1E Value = 1)

### red_1s_blue_1s_green_1s_1r.prg (N=3, Dur0Units_actual=1)
```
0000:0000 | 50 52 03 49  4E 05 00 00  00 04 00 08  01 00 50 49 | PR.IN.........PI
0000:0010 | 3B 00 00 00  03 00 00 00  64 00 59 00  00 00 01 00 | ;.......d.Y.....
0000:0020 | 04 00 01 00  00 01 00 00  00 00 00 64  00 85 01 00 | ...........d....
```
*   `0x14-0x15`: `03 00` (Segment Count N = 3)
*   `0x16-0x17`: `00 00` (Field 0x16 Value = 0)
*   `0x1E-0x1F`: `01 00` (Field 0x1E Value = 1)

### red_1s_blue_2s_1r.prg (N=2, Dur0Units_actual=1)
Same header as `red_1s_blue_1s_1r.prg` for fields 0x16 and 0x1E.
```
0000:0000 | 50 52 03 49  4E 05 00 00  00 04 00 08  01 00 50 49 | PR.IN.........PI
0000:0010 | 28 00 00 00  02 00 00 00  64 00 46 00  00 00 01 00 | (.......d.F.....
```
*   `0x16-0x17`: `00 00`
*   `0x1E-0x1F`: `01 00`

### red_50s_blue_50s_1r.prg (N=2, Dur0Units_actual=50)
```
0000:0000 | 50 52 03 49  4E 05 00 00  00 04 00 08  01 00 50 49 | PR.IN.........PI
0000:0010 | 28 00 00 00  02 00 00 00  64 00 46 00  00 00 32 00 | (.......d.F...2.
```
*   `0x16-0x17`: `00 00` (Field 0x16 Value = 0)
*   `0x1E-0x1F`: `32 00` (Field 0x1E Value = 50)

### red_100s_blue_50s_1r.prg (N=2, Dur0Units_actual=100)
```
0000:0000 | 50 52 03 49  4E 05 00 00  00 04 00 08  01 00 50 49 | PR.IN.........PI
0000:0010 | 28 00 00 00  02 00 01 00  64 00 46 00  00 00 00 00 | (.......d.F.....
```
*   `0x16-0x17`: `01 00` (Field 0x16 Value = 1)
*   `0x1E-0x1F`: `00 00` (Field 0x1E Value = 0)


## Deduced Logic for Header Fields 0x16 and 0x1E

Let:
*   `Dur0Units_actual`: The duration of the first PRG segment in PRG time units.
*   `N_prg`: The total number of PRG segments in the file.
*   `val_0x16_dec`: The decimal value calculated for field `0x16`.

**Field `0x16` (Header First Segment Info):**
1.  If `N_prg == 1`:
    *   `val_0x16_dec = floor(Dur0Units_actual / 100)`
2.  Else (`N_prg > 1`):
    *   If `Dur0Units_actual == 100`: `val_0x16_dec = 1`
    *   Else (`Dur0Units_actual != 100`): `val_0x16_dec = 0`
*   The byte value written to the file is `struct.pack('<H', val_0x16_dec)`.

**Field `0x1E` (Header First Segment Duration (Conditional)):**
1.  If `N_prg == 1`:
    *   `val_0x1E_dec = Dur0Units_actual - (val_0x16_dec * 100)`
      (Note: `val_0x16_dec` is the decimal value calculated for field `0x16` above)
2.  Else (`N_prg > 1`):
    *   If `Dur0Units_actual == 100`: `val_0x1E_dec = 0`
    *   Else (`Dur0Units_actual != 100`): `val_0x1E_dec = Dur0Units_actual`
*   The byte value written to the file is `struct.pack('<H', val_0x1E_dec & 0xFFFF)`.

This logic appears consistent with all provided 1Hz examples.

---

## Important Finding: 1Hz PRG with 100 Color Slots Experiment (Failed)

**Date:** 2025-06-01

An experiment was conducted using a modified generator (`prg_generator_new.py`) that produced PRG files with a 1Hz master refresh rate. The intention was to use the 100 RGB color data slots within each 1-second PRG segment to achieve 0.01s granularity.

**Observation:** The LTX ball firmware appears to **only use the first RGB color** from the 300-byte (100x3 RGB) color data block when the PRG file's refresh rate is 1Hz. The remaining 99 color slots are ignored for display purposes in this mode.

**Example JSON that resulted in solid yellow (not yellow then black):**
```json
{
  "default_pixels": 4,
  "color_format": "rgb",
  "refresh_rate": 100,
  "end_time": 100,
  "sequence": {
    "0": {"color": [255, 255, 0], "pixels": 4},    // Yellow
    "1": {"color": [0, 0, 0], "pixels": 4}         // Black (intended for 0.01s later)
  }
}
```
Resulting PRG (1Hz) showed solid yellow for 1 second.

**Example JSON that resulted in solid red (not red then blue):**
```json
{
  "default_pixels": 4,
  "color_format": "rgb",
  "refresh_rate": 100,
  "end_time": 100,
  "sequence": {
    "0": {"color": [255, 0, 0], "pixels": 4},     // Red
    "50": {"color": [0, 0, 255], "pixels": 4}    // Blue (intended for 0.5s later)
  }
}
```
Resulting PRG (1Hz) showed solid red for 1 second.

**Conclusion:** High-frequency color changes cannot be achieved by manipulating the 100 sub-color slots within a 1Hz PRG segment. A higher PRG refresh rate (e.g., 100Hz or 1000Hz) is necessary for fine-grained temporal resolution.

---

## 1000Hz Refresh Rate Examples (PRG Refresh Rate = 1000)

These examples use a PRG file refresh rate of 1000Hz (`03E8` Little Endian).
All are 4-pixel.

**Common Header Values for 1000Hz Refresh Rate, 4px:**
*   `0x00-0x07`: `50 52 03 49 4E 05 00 00` (Signature)
*   `0x08-0x09`: `00 04` (Default Pixels = 4, Big Endian)
*   `0x0A-0x0B`: `00 08` (Constant)
*   `0x0C-0x0D`: `E8 03` (Refresh Rate = 1000Hz, Little Endian)
*   `0x0E-0x0F`: `50 49` ('PI' Marker)
*   `0x18-0x19`: `64 00` (RGB Data Repetition Count = 100)
*   `0x1C-0x1D`: `00 00` (Constant)

### red_.01s_1000r.prg (N=1, Dur0Units_actual = 10)
*Actual Hex:*
```
0000:0000 | 50 52 03 49  4E 05 00 00  00 04 00 08  E8 03 50 49 | PR.IN.......è.PI
0000:0010 | 15 00 00 00  01 00 00 00  64 00 33 00  00 00 0A 00 | ........d.3.....
```
*   `0x16-0x17`: `00 00` (Value 0)
*   `0x1E-0x1F`: `0A 00` (Value 10)

### red_.1s_1000r.prg (N=1, Dur0Units_actual = 100)
*Actual Hex:*
```
0000:0000 | 50 52 03 49  4E 05 00 00  00 04 00 08  E8 03 50 49 | PR.IN.......è.PI
0000:0010 | 15 00 00 00  01 00 01 00  64 00 33 00  00 00 00 00 | ........d.3.....
```
*   `0x16-0x17`: `01 00` (Value 1)
*   `0x1E-0x1F`: `00 00` (Value 0)

### red_0.5s_1000r.prg (N=1, Dur0Units_actual = 500)
*Actual Hex:*
```
0000:0000 | 50 52 03 49  4E 05 00 00  00 04 00 08  E8 03 50 49 | PR.IN.......è.PI
0000:0010 | 15 00 00 00  01 00 05 00  64 00 33 00  00 00 F4 01 | ........d.3...ô.
```
*   `0x16-0x17`: `05 00` (Value 5)
*   `0x1E-0x1F`: `F4 01` (Value 500)

### red_1s_1000r.prg (N=1, Dur0Units_actual = 1000)
*Actual Hex:*
```
0000:0000 | 50 52 03 49  4E 05 00 00  00 04 00 08  E8 03 50 49 | PR.IN.......è.PI
0000:0010 | 15 00 00 00  01 00 0A 00  64 00 33 00  00 00 E8 03 | ........d.3...è.
```
*   `0x16-0x17`: `0A 00` (Value 10)
*   `0x1E-0x1F`: `E8 03` (Value 1000)

### red_5s_1000r.prg (N=1, Dur0Units_actual = 5000)
*Actual Hex:*
```
0000:0000 | 50 52 03 49  4E 05 00 00  00 04 00 08  E8 03 50 49 | PR.IN.......è.PI
0000:0010 | 15 00 00 00  01 00 32 00  64 00 33 00  00 00 88 13 | ......2.d.3.....
```
*   `0x16-0x17`: `32 00` (Value 50)
*   `0x1E-0x1F`: `88 13` (Value 5000)


### red_10s_1000r.prg (N=1, Dur0Units_actual = 10000)
*Actual Hex:*
```
0000:0000 | 50 52 03 49  4E 05 00 00  00 04 00 08  E8 03 50 49 | PR.IN.......è.PI
0000:0010 | 15 00 00 00  01 00 64 00  64 00 33 00  00 00 10 27 | ......d.d.3....'
```
*   `0x16-0x17`: `64 00` (Value 100)
*   `0x1E-0x1F`: `10 27` (Value 10000)

### red_0.1s_blue_0.1s_1000r.prg (N=2, Dur0Units_actual=100)
*Actual Hex:*
```
0000:0000 | 50 52 03 49  4E 05 00 00  00 04 00 08  E8 03 50 49 | PR.IN.......è.PI
0000:0010 | 28 00 00 00  02 00 01 00  64 00 46 00  00 00 00 00 | (.......d.F.....
```
*   `0x14-0x15` (N): `02 00` (2)
*   `0x16-0x17` (Field 0x16, from Dur0=100): `01 00` (Value 1)
*   `0x1E-0x1F` (Field 0x1E, from Dur0=100): `00 00` (Value 0)


### red_1s_blue_.5s_1000r.prg (N=2, Dur0Units_actual=1000)
*Actual Hex:*
```
0000:0000 | 50 52 03 49  4E 05 00 00  00 04 00 08  E8 03 50 49 | PR.IN.......è.PI
0000:0010 | 28 00 00 00  02 00 0A 00  64 00 46 00  00 00 E8 03 | (.......d.F...è.
```
*   `0x14-0x15` (N): `02 00` (2)
*   `0x16-0x17` (Field 0x16, from Dur0=1000): `0A 00` (Value 10)
*   `0x1E-0x1F` (Field 0x1E, from Dur0=1000): `E8 03` (Value 1000)


---

### High Segment Count (N > 255) at 1000Hz Refresh Rate Examples

**Date:** 2025-06-01

These examples are to investigate how the PRG format handles segment counts exceeding 255.
All files have a 0.1s segment duration and 1000Hz refresh rate.
This means each segment has `Dur0Units_actual = 0.1 * 1000 = 100`.
The common header values for Refresh Rate (`E8 03` at `0x0C-0x0D`), Field `0x16` (`01 00` at `0x16-0x17`), and Field `0x1E` (`00 00` at `0x1E-0x1F`) are consistent with `Dur0Units_actual=100` according to Hypothesis 8.

#### N253_.1s_1000r.prg (Actual N=253, Dur0Units_actual=100)
*Actual Hex (first 256 bytes):*
```
0000:0000 | 50 52 03 49  4E 05 00 00  00 04 00 08  E8 03 50 49 | PR.IN.......è.PI
0000:0010 | C9 12 00 00  FD 00 01 00  64 00 E7 12  00 00 00 00 | É...ý...d.ç.....
0000:0020 | 04 00 01 00  00 64 00 00  00 01 00 64  00 13 14 00 | .....d.....d....
0000:0030 | 00 00 00 04  00 01 00 00  64 00 00 00  01 00 64 00 | ........d.....d.
0000:0040 | 3F 15 00 00  00 00 04 00  01 00 00 64  00 00 00 01 | ?..........d....
0000:0050 | 00 64 00 6B  16 00 00 00  00 04 00 01  00 00 64 00 | .d.k..........d.
0000:0060 | 00 00 01 00  64 00 97 17  00 00 00 00  04 00 01 00 | ....d...........
0000:0070 | 00 64 00 00  00 01 00 64  00 C3 18 00  00 00 00 04 | .d.....d.Ã......
0000:0080 | 00 01 00 00  64 00 00 00  01 00 64 00  EF 19 00 00 | ....d.....d.ï...
0000:0090 | 00 00 04 00  01 00 00 64  00 00 00 01  00 64 00 1B | .......d.....d..
0000:00A0 | 1B 00 00 00  00 04 00 01  00 00 64 00  00 00 01 00 | ..........d.....
0000:00B0 | 64 00 47 1C  00 00 00 00  04 00 01 00  00 64 00 00 | d.G..........d..
0000:00C0 | 00 01 00 64  00 73 1D 00  00 00 00 04  00 01 00 00 | ...d.s..........
0000:00D0 | 64 00 00 00  01 00 64 00  9F 1E 00 00  00 00 04 00 | d.....d.........
0000:00E0 | 01 00 00 64  00 00 00 01  00 64 00 CB  1F 00 00 00 | ...d.....d.Ë....
0000:00F0 | 00 04 00 01  00 00 64 00  00 00 01 00  64 00 F7 20 | ......d.....d.÷
0000:0100 | 00 00 00 00  04 00 01 00  00 64 00 00  00 01 00 64 | .........d.....d
```
*   `0x10-0x13` (Pointer1): `C9 12 00 00` (`0x12C9` = 4809). Formula `21 + 19*(253-1) = 21 + 19*252 = 21 + 4788 = 4809`. Matches.
*   `0x14-0x15` (Segment Count N): `FD 00` (`0x00FD` = 253). Matches.
*   `0x1A-0x1B` (RGB Data Start Offset): `E7 12` (`0x12E7` = 4839). Formula `32 + 253*19 = 32 + 4807 = 4839`. Matches.

#### N257_.1s_1000r.prg (Actual N=257, Dur0Units_actual=100)
**Note:** Filename has been corrected to match actual segment count. Header fields consistently point to N=257.
*Actual Hex (first 256 bytes):*
```
0000:0000 | 50 52 03 49  4E 05 00 00  00 04 00 08  E8 03 50 49 | PR.IN.......è.PI
0000:0010 | 15 13 00 00  01 01 01 00  64 00 33 13  00 00 00 00 | ........d.3.....
0000:0020 | 04 00 01 00  00 64 00 00  00 01 00 64  00 5F 14 00 | .....d.....d._..
0000:0030 | 00 00 00 04  00 01 00 00  64 00 00 00  01 00 64 00 | ........d.....d.
0000:0040 | 8B 15 00 00  00 00 04 00  01 00 00 64  00 00 00 01 | ...........d....
0000:0050 | 00 64 00 B7  16 00 00 00  00 04 00 01  00 00 64 00 | .d.·..........d.
0000:0060 | 00 00 01 00  64 00 E3 17  00 00 00 00  04 00 01 00 | ....d.ã.........
0000:0070 | 00 64 00 00  00 01 00 64  00 0F 19 00  00 00 00 04 | .d.....d........
0000:0080 | 00 01 00 00  64 00 00 00  01 00 64 00  3B 1A 00 00 | ....d.....d.;...
0000:0090 | 00 00 04 00  01 00 00 64  00 00 00 01  00 64 00 67 | .......d.....d.g
0000:00A0 | 1B 00 00 00  00 04 00 01  00 00 64 00  00 00 01 00 | ..........d.....
0000:00B0 | 64 00 93 1C  00 00 00 00  04 00 01 00  00 64 00 00 | d............d..
0000:00C0 | 00 01 00 64  00 BF 1D 00  00 00 00 04  00 01 00 00 | ...d.¿..........
0000:00D0 | 64 00 00 00  01 00 64 00  EB 1E 00 00  00 00 04 00 | d.....d.ë.......
0000:00E0 | 01 00 00 64  00 00 00 01  00 64 00 17  20 00 00 00 | ...d.....d.. ...
0000:00F0 | 00 04 00 01  00 00 64 00  00 00 01 00  64 00 43 21 | ......d.....d.C!
0000:0100 | 00 00 00 00  04 00 01 00  00 64 00 00  00 01 00 64 | .........d.....d
```
*   `0x10-0x13` (Pointer1): `15 13 00 00` (`0x1315` = 4885). Formula `21 + 19*(257-1) = 21 + 19*256 = 21 + 4864 = 4885`. Matches N=257.
*   `0x14-0x15` (Segment Count N): `01 01` (`0x0101` = 257). Matches N=257.
*   `0x1A-0x1B` (RGB Data Start Offset): `33 13` (`0x1333` = 4915). Formula `32 + 257*19 = 32 + 4883 = 4915`. Matches N=257.

#### N258_.1s_1000r.prg (Actual N=258, Dur0Units_actual=100)
**Note:** Filename has been corrected to match actual segment count. Header fields consistently point to N=258.
*Actual Hex (first 256 bytes):*
```
0000:0000 | 50 52 03 49  4E 05 00 00  00 04 00 08  E8 03 50 49 | PR.IN.......è.PI
0000:0010 | 28 13 00 00  02 01 01 00  64 00 46 13  00 00 00 00 | (.......d.F.....
0000:0020 | 04 00 01 00  00 64 00 00  00 01 00 64  00 72 14 00 | .....d.....d.r..
0000:0030 | 00 00 00 04  00 01 00 00  64 00 00 00  01 00 64 00 | ........d.....d.
0000:0040 | 9E 15 00 00  00 00 04 00  01 00 00 64  00 00 00 01 | ...........d....
0000:0050 | 00 64 00 CA  16 00 00 00  00 04 00 01  00 00 64 00 | .d.Ê..........d.
0000:0060 | 00 00 01 00  64 00 F6 17  00 00 00 00  04 00 01 00 | ....d.ö.........
0000:0070 | 00 64 00 00  00 01 00 64  00 22 19 00  00 00 00 04 | .d.....d."......
0000:0080 | 00 01 00 00  64 00 00 00  01 00 64 00  4E 1A 00 00 | ....d.....d.N...
0000:0090 | 00 00 04 00  01 00 00 64  00 00 00 01  00 64 00 7A | .......d.....d.z
0000:00A0 | 1B 00 00 00  00 04 00 01  00 00 64 00  00 00 01 00 | ..........d.....
0000:00B0 | 64 00 A6 1C  00 00 00 00  04 00 01 00  00 64 00 00 | d.¦..........d..
0000:00C0 | 00 01 00 64  00 D2 1D 00  00 00 00 04  00 01 00 00 | ...d.Ò..........
0000:00D0 | 64 00 00 00  01 00 64 00  FE 1E 00 00  00 00 04 00 | d.....d.þ.......
0000:00E0 | 01 00 00 64  00 00 00 01  00 64 00 2A  20 00 00 00 | ...d.....d.* ...
0000:00F0 | 00 04 00 01  00 00 64 00  00 00 01 00  64 00 56 21 | ......d.....d.V!
0000:0100 | 00 00 00 00  04 00 01 00  00 64 00 00  00 01 00 64 | .........d.....d
```
*Additional hex dump for official `N258_.1s_1000r.prg` (offsets `0x0470-0x04F0`):*
```
0000:0470 | 01 00 00 64  00 00 00 00  00 64 00 6A  58 00 00 5F | ...d.....d.jX.._
0000:0480 | 00 04 00 01  00 00 5F 00  00 00 01 00  64 00 96 59 | ......_.....d..Y
0000:0490 | 00 00 00 00  04 00 01 00  00 64 00 00  00 01 00 64 | .........d.....d
0000:04A0 | 00 C2 5A 00  00 00 00 04  00 01 00 00  64 00 00 00 | .ÂZ.........d...
0000:04B0 | 01 00 64 00  EE 5B 00 00  00 00 04 00  01 00 00 64 | ..d.î[.........d
0000:04C0 | 00 00 00 00  00 64 00 1A  5D 00 00 55  00 04 00 01 | .....d..]..U....
0000:04D0 | 00 00 55 00  00 00 01 00  64 00 46 5E  00 00 00 00 | ..U.....d.F^....
0000:04E0 | 04 00 01 00  00 64 00 00  00 01 00 64  00 72 5F 00 | .....d.....d.r_.
0000:04F0 | 00 00 00 04  00 01 00 00  64 00 00 00  01 00 64 00 | ........d.....d.
```
*   `0x10-0x13` (Pointer1): `28 13 00 00` (`0x1328` = 4904). Formula `21 + 19*(258-1) = 21 + 19*257 = 21 + 4883 = 4904`. Matches N=258.
*   `0x14-0x15` (Segment Count N): `02 01` (`0x0102` = 258). Matches N=258.
*   `0x1A-0x1B` (RGB Data Start Offset): `46 13` (`0x1346` = 4934). Formula `32 + 258*19 = 32 + 4902 = 4934`. Matches N=258.
*   Duration Block Analysis (e.g., First block at `0x0020` for Segment 0, Second block at `0x0033` for Segment 1):
*   `+0x05` Current Segment Duration is `64 00` (100 units) for all segments.
*   `+0x09` (Field `+0x09`):
    *   For Block 0 (idx=0): `01 00 64 00` (`field_09_part1=1`, `field_09_part2=100`). `part1` is `idx+1`.
    *   For Block 1 (idx=1, CurrentDur=100, PrevDur=100): `01 00 64 00` (`field_09_part1=1`, `field_09_part2=100`). `part1` is `1` because durations are equal. This supports "Hypothesis I" for `field_09_part1`.
*   `+0x11` Next Segment Info (Dur of next segment): `00 00` (0 units) for initial blocks when the next segment's duration is 100ms. This supports the re-confirmed "Hypothesis F" (where `Field+0x11 = 0` if `Dur_k+1 == 100`).
    *   **Further Analysis & Exceptions for N=258 (Official App):**
        *   **Segment Duration Change:** Segment 59 (idx=59) has an actual duration of 95ms (`5F 00` at offset `0x0486`) in the official PRG, deviating from an input of 100ms.
        *   **Block 58 (idx=58):**
            *   `+0x09` (`field_09_part1`, at `0x477`): Official is `00 00` (0). Current Hypothesis I (`1`) is incorrect here.
            *   `+0x11` (NextSegInfo for Seg 59, at `0x47F`): Official is `5F 00` (95). This matches the altered duration of Seg 59 (95ms), so Hypothesis F (`value = Dur_k+1` if `Dur_k+1 < 100`) correctly predicts this *if* it knows Seg 59's duration is 95.
        *   **Block 62 (idx=62):**
            *   `+0x09` (`field_09_part1`, at `0x04BA+9=0x04C3`): Official is `00 00` (0). Current Hypothesis I (`1`) is incorrect here.
            *   `+0x11` (NextSegInfo for Seg 63, at `0x04BA+17=0x04CB`): Official is `55 00` (85). Assuming Seg 63 intended duration is 100ms, Hypothesis F (`0`) is incorrect.
        *   These discrepancies indicate highly specific behavior for N=258 around these indices, not covered by current general hypotheses.
    *   **Additional Discrepancies for N=258 (Official App, from `0x0D60` onwards as provided 2025-06-01):**
        *   Hex dump section for official `N258_.1s_1000r.prg` starting `0x0D60`:
        ```
        0000:0D60 | 00 64 00 0A  E5 00 00 00  00 04 00 01  00 00 64 00 | .d..å.........d.
        0000:0D70 | 00 00 01 00  64 00 36 E6  00 00 03 00  04 00 01 00 | ....d.6æ........
        0000:0D80 | 00 67 00 00  00 01 00 64  00 62 E7 00  00 00 00 04 | .g.....d.bç.....
        0000:0D90 | 00 01 00 00  64 00 00 00  01 00 64 00  8E E8 00 00 | ....d.....d..è..
        0000:0DA0 | 00 00 04 00  01 00 00 64  00 00 00 01  00 64 00 BA | .......d.....d.º
        0000:0DB0 | E9 00 00 00  00 04 00 01  00 00 64 00  00 00 01 00 | é.........d.....
        0000:0DC0 | 64 00 E6 EA  00 00 00 00  04 00 01 00  00 64 00 00 | d.æê.........d..
        0000:0DD0 | 00 01 00 64  00 12 EC 00  00 00 00 04  00 01 00 00 | ...d..ì.........
        0000:0DE0 | 64 00 00 00  01 00 64 00  3E ED 00 00  00 00 04 00 | d.....d.>í......
        0000:0DF0 | 01 00 00 64  00 00 00 01  00 64 00 6A  EE 00 00 00 | ...d.....d.jî...
        0000:0E00 | 00 04 00 01  00 00 64 00  00 00 01 00  64 00 96 EF | ......d.....d..ï
        0000:0E10 | 00 00 00 00  04 00 01 00  00 64 00 00  00 01 00 64 | .........d.....d
        0000:0E20 | 00 C2 F0 00  00 00 00 04  00 01 00 00  64 00 00 00 | .Âð.........d...
        0000:0E30 | 01 00 64 00  EE F1 00 00  00 00 04 00  01 00 00 64 | ..d.îñ.........d
        0000:0E40 | 00 00 00 01  00 64 00 1A  F3 00 00 00  00 04 00 01 | .....d..ó.......
        0000:0E50 | 00 00 64 00  00 00 01 00  64 00 46 F4  00 00 00 00 | ..d.....d.Fô....
        0000:0E60 | 04 00 01 00  00 64 00 00  00 01 00 64  00 72 F5 00 | .....d.....d.rõ.
        0000:0E70 | 00 02 00 04  00 01 00 00  66 00 00 00  01 00 64 00 | ........f.....d.
        ```
        *   **Block 179 (idx=179, starts `0xD69`):** `Field +0x11` (NextSegInfo, at `0xD7A`) is `03 00` (value 3). Current Hypothesis F for `Field +0x11` would predict `0` if Seg 180's duration is 100ms.
        *   **Segment 180 (idx=180, its block starts `0xD7C`):** Its own duration (`+0x05` field, at `0xD81`) is `67 00` (103ms). The input JSON implies 100ms.
        *   **Block 192 (idx=192, its block starts `0xE6D`):**
            *   Its own duration (`+0x05` field, at `0xE78`) is `66 00` (102ms). The input JSON implies 100ms.
            *   `field_09_part1` (`+0x09` field LSBs, at `0xE76`) is `02 00` (value 2). Current Hypothesis I for `field_09_part1` would predict `1` (if previous segment had same duration) or `193` (if different).
        *   These observations further confirm that the official app's generation logic for `N=258` includes dynamic adjustments to segment durations and related duration block fields that are not yet captured by our general hypotheses or current patches.


#### N259_.1s_1000r.prg (Actual N=259, Dur0Units_actual=100, Official App)
*Actual Hex (first 256 bytes, from Official App):*
```
0000:0000 | 50 52 03 49  4E 05 00 00  00 04 00 08  E8 03 50 49 | PR.IN.......è.PI
0000:0010 | 3B 13 00 00  03 01 01 00  64 00 59 13  00 00 00 00 | ;.......d.Y.....
0000:0020 | 04 00 01 00  00 64 00 00  00 01 00 64  00 85 14 00 | .....d.....d....
0000:0030 | 00 00 00 04  00 01 00 00  64 00 00 00  01 00 64 00 | ........d.....d.
0000:0040 | B1 15 00 00  00 00 04 00  01 00 00 64  00 00 00 01 | ±..........d....
0000:0050 | 00 64 00 DD  16 00 00 00  00 04 00 01  00 00 64 00 | .d.Ý..........d.
0000:0060 | 00 00 01 00  64 00 09 18  00 00 00 00  04 00 01 00 | ....d...........
0000:0070 | 00 64 00 00  00 01 00 64  00 35 19 00  00 00 00 04 | .d.....d.5......
0000:0080 | 00 01 00 00  64 00 00 00  01 00 64 00  61 1A 00 00 | ....d.....d.a...
0000:0090 | 00 00 04 00  01 00 00 64  00 00 00 01  00 64 00 8D | .......d.....d..
0000:00A0 | 1B 00 00 00  00 04 00 01  00 00 64 00  00 00 01 00 | ..........d.....
0000:00B0 | 64 00 B9 1C  00 00 00 00  04 00 01 00  00 64 00 00 | d.¹..........d..
0000:00C0 | 00 01 00 64  00 E5 1D 00  00 00 00 04  00 01 00 00 | ...d.å..........
0000:00D0 | 64 00 00 00  01 00 64 00  11 1F 00 00  00 00 04 00 | d.....d.........
0000:00E0 | 01 00 00 64  00 00 00 01  00 64 00 3D  20 00 00 00 | ...d.....d.= ...
0000:00F0 | 00 04 00 01  00 00 64 00  00 00 01 00  64 00 69 21 | ......d.....d.i!
0000:0100 | 00 00 00 00  04 00 01 00  00 64 00 00  00 01 00 64 | .........d.....d
```
*   Header Analysis (all segments 0.1s = 100 units @ 1000Hz):
    *   `0x10-0x13` (Pointer1): `3B 13 00 00` (`0x133B` = 4923). Formula `21 + 19*(259-1) = 21 + 19*258 = 21 + 4902 = 4923`. Matches.
    *   `0x14-0x15` (Segment Count N): `03 01` (`0x0103` = 259). Matches.
    *   `0x16-0x17` (Field 0x16 from Dur0=100): `01 00` (Value 1). Matches Hypothesis 8.
    *   `0x1A-0x1B` (RGB Data Start Offset): `59 13` (`0x1359` = 4953). Formula `32 + 259*19 = 32 + 4921 = 4953`. Matches.
    *   `0x1E-0x1F` (Field 0x1E from Dur0=100): `00 00` (Value 0). Matches Hypothesis 8.
*   Duration Block Analysis (e.g., First block at `0x0020` for Segment 0, Second block at `0x0033` for Segment 1):
    *   `+0x00` Pixel Count: `04 00` (4 pixels).
    *   `+0x05` Current Segment Duration is `64 00` (100 units) for all segments.
    *   `+0x09` (Field `+0x09`):
        *   For Block 0 (idx=0): `01 00 64 00` (`field_09_part1=1`, `field_09_part2=100`). `part1` is `idx+1`.
        *   For Block 1 (idx=1, CurrentDur=100, PrevDur=100): `01 00 64 00` (`field_09_part1=1`, `field_09_part2=100`). `part1` is `1` because durations are equal. This supports "Hypothesis I" for `field_09_part1`.
    *   `+0x11` Next Segment Info (Dur of next segment): `00 00` (0 units) for initial blocks when the next segment's duration is 100ms. This supports the re-confirmed "Hypothesis F" (where `Field+0x11 = 0` if `Dur_k+1 == 100`).
*   Observation: This official app file appears to contain 259 segments, each 100 units (100ms) long, without inserted black gaps.

## Field[+0x09] and Field[+0x11] Investigation (1000Hz Refresh Rate)

**Date:** 2025-06-02

The following tests were conducted using the official LTX app with a PRG refresh rate of 1000Hz (1 unit = 1ms) to understand the dynamic behavior of `Field[+0x09]` (specifically `field_09_part1` and `field_09_part2`) and `Field[+0x11]` within the intermediate duration blocks. All PRG hex dumps are truncated.

### Test A: N=3 segments. Durations: 1240, 470, 1930 units

*Input Durations:*
*   Segment 0: 1240 units
*   Segment 1: 470 units
*   Segment 2: 1930 units

*Hex Dump (TestA.prg):*
```
0000:0000 | 50 52 03 49  4E 05 00 00  00 04 00 08  E8 03 50 49 | PR.IN.......è.PI
0000:0010 | 3B 00 00 00  03 00 0C 00  64 00 59 00  00 00 28 00 | ;.......d.Y...(.
0000:0020 | 04 00 01 00  00 D8 04 00  00 04 00 64  00 85 01 00 | .....Ø.....d....
0000:0030 | 00 46 00 04  00 01 00 00  D6 01 00 00  13 00 64 00 | .F......Ö.....d.
0000:0040 | B1 02 00 00  1E 00 04 00  01 00 00 8A  07 00 00 43 | ±..............C
0000:0050 | 44 88 03 00  00 2C 01 00  00 FF 00 00  FF 00 00 FF | D....,...ÿ..ÿ..ÿ
```

*Header Analysis (Offsets `0x16`, `0x1E`):*
*   `Dur0Units_actual` = 1240
*   Field `0x16`: `0C 00` (12). `floor(1240 / 100) = 12`. Matches.
*   Field `0x1E`: `28 00` (40). `1240 % 100 = 40`. Matches (using simplified rule `Dur0 % 100`).

*Duration Block Analysis:*
*   **Block 0 (Segment 0, offset `0x20`):**
    *   `+0x05` CurrentSegmentDurationUnits: `D8 04` (1240). Correct.
    *   `+0x09` Field[+0x09]: `04 00 64 00` -> `field_09_part1 = 4`, `field_09_part2 = 100`.
    *   `+0x11` NextSegmentInfo (for Dur_1=470): `D6 01` (470). Hypothesis F: `Dur_k+1`(470) > 100, `Dur_k`(1240) != 100 -> val=470. Matches.
*   **Block 1 (Segment 1, offset `0x33`):**
    *   `+0x05` CurrentSegmentDurationUnits: `D6 01` (470). Correct.
    *   `+0x09` Field[+0x09]: `13 00 64 00` -> `field_09_part1 = 19`, `field_09_part2 = 100`.
        *   Observation: `field_09_part2` is 100, despite `CurrentSegmentDurationUnits` being 470.
    *   `+0x11` NextSegmentInfo (for Dur_2=1930): `1E 00` (30). **DISCREPANCY.** Expected 1930 (`8A 07`) by Hypothesis F. Actual dump shows 30.
*   **Block 2 (Segment 2, Last Block, offset `0x46`):**
    *   `+0x05` CurrentSegmentDurationUnits: `8A 07` (1930). Correct.
    *   `+0x09` Field[+0x09]: `43 44` ('CD'). Standard for last block.

### Test B: N=3 segments. Durations: 500, 80, 500 units

*Input Durations:*
*   Segment 0: 500 units
*   Segment 1: 80 units
*   Segment 2: 500 units

*Hex Dump (TestB.prg):*
```
0000:0000 | 50 52 03 49  4E 05 00 00  00 04 00 08  E8 03 50 49
0000:0010 | 3B 00 00 00  03 00 05 00  64 00 59 00  00 00 00 00
0000:0020 | 04 00 01 00  00 F4 01 00  00 00 00 64  00 85 01 00
0000:0030 | 00 50 00 04  00 01 00 00  50 00 00 00  05 00 64 00
0000:0040 | B1 02 00 00  00 00 04 00  01 00 00 F4  01 00 00 43
0000:0050 | 44 88 03 00  00 2C 01 00  00 FF 00 00  FF 00 00 FF
```

*Header Analysis (Offsets `0x16`, `0x1E`):*
*   `Dur0Units_actual` = 500
*   Field `0x16`: `05 00` (5). `floor(500 / 100) = 5`. Matches.
*   Field `0x1E`: `00 00` (0). `500 % 100 = 0`. Matches (using simplified rule `Dur0 % 100`).

*Duration Block Analysis:*
*   **Block 0 (Segment 0, offset `0x20`):**
    *   `+0x05` CurrentSegmentDurationUnits: `F4 01` (500). Correct.
    *   `+0x09` Field[+0x09]: `00 00 64 00` -> `field_09_part1 = 0`, `field_09_part2 = 100`.
    *   `+0x11` NextSegmentInfo (for Dur_1=80): `50 00` (80). Hypothesis F: `Dur_k+1`(80) < 100 -> val=80. Matches.
*   **Block 1 (Segment 1, offset `0x33`):**
    *   `+0x05` CurrentSegmentDurationUnits: `50 00` (80). Correct.
    *   `+0x09` Field[+0x09]: `05 00 64 00` -> `field_09_part1 = 5`, `field_09_part2 = 100`.
        *   Observation: `field_09_part2` is 100, despite `CurrentSegmentDurationUnits` (80) < 100.
    *   `+0x11` NextSegmentInfo (for Dur_2=500): `F4 01` (500). Hypothesis F: `Dur_k+1`(500) > 100, `Dur_k`(80) != 100 -> val=500. Matches.
*   **Block 2 (Segment 2, Last Block, offset `0x46`):**
    *   `+0x05` CurrentSegmentDurationUnits: `F4 01` (500). Correct.
    *   `+0x09` Field[+0x09]: `43 44` ('CD'). Standard for last block.

### Test C: N=3 segments. Durations: 500, 120, 500 units

*Input Durations:*
*   Segment 0: 500 units
*   Segment 1: 120 units
*   Segment 2: 500 units

*Hex Dump (TestC.prg):*
```
0000:0000 | 50 52 03 49  4E 05 00 00  00 04 00 08  E8 03 50 49
0000:0010 | 3B 00 00 00  03 00 05 00  64 00 59 00  00 00 00 00
0000:0020 | 04 00 01 00  00 F4 01 00  00 01 00 64  00 85 01 00
0000:0030 | 00 14 00 04  00 01 00 00  78 00 00 00  05 00 64 00
0000:0040 | B1 02 00 00  00 00 04 00  01 00 00 F4  01 00 00 43
0000:0050 | 44 88 03 00  00 2C 01 00  00 FF 00 00  FF 00 00 FF
```

*Header Analysis (Offsets `0x16`, `0x1E`):*
*   `Dur0Units_actual` = 500
*   Field `0x16`: `05 00` (5). `floor(500 / 100) = 5`. Matches.
*   Field `0x1E`: `00 00` (0). `500 % 100 = 0`. Matches (using simplified rule `Dur0 % 100`).

*Duration Block Analysis:*
*   **Block 0 (Segment 0, offset `0x20`):**
    *   `+0x05` CurrentSegmentDurationUnits: `F4 01` (500). Correct.
    *   `+0x09` Field[+0x09]: `01 00 64 00` -> `field_09_part1 = 1`, `field_09_part2 = 100`.
    *   `+0x11` NextSegmentInfo (for Dur_1=120): `78 00` (120). Hypothesis F: `Dur_k+1`(120) > 100, `Dur_k`(500) != 100 -> val=120. Matches.
*   **Block 1 (Segment 1, offset `0x33`):**
    *   `+0x05` CurrentSegmentDurationUnits: `78 00` (120). Correct.
    *   `+0x09` Field[+0x09]: `05 00 64 00` -> `field_09_part1 = 5`, `field_09_part2 = 100`.
        *   Observation: `field_09_part2` is 100, despite `CurrentSegmentDurationUnits` (120) > 100.
    *   `+0x11` NextSegmentInfo (for Dur_2=500): `F4 01` (500). Hypothesis F: `Dur_k+1`(500) > 100, `Dur_k`(120) != 100 -> val=500. Matches.
*   **Block 2 (Segment 2, Last Block, offset `0x46`):**
    *   `+0x05` CurrentSegmentDurationUnits: `F4 01` (500). Correct.
    *   `+0x09` Field[+0x09]: `43 44` ('CD'). Standard for last block.
## Deduced Logic for Header Fields 0x16 and 0x1E (Hypothesis 8 - Current Best as of 2025-06-01 10:25)

This logic applies universally across different PRG refresh rates and segment counts, based on all provided official app samples.

It's also important to note the structure of certain fields within **Intermediate Duration Blocks** (i.e., not the last duration block):

*   **Field `+0x09` (Segment Index & Duration) (Revised 2025-06-01):**
    This 4-byte field consists of two 2-byte Little Endian values:
    1.  `field_09_part1`:
        *   If it's the first duration block (`current_block_index == 0`): This is `1` (`01 00`).
        *   If `current_block_index > 0` AND `CurrentSegmentDurationUnits == PreviousSegmentDurationUnits`: This value is `CurrentSegmentDurationUnits`.
        *   Else (`current_block_index > 0` AND `CurrentSegmentDurationUnits != PreviousSegmentDurationUnits`): This value is `current_block_index + 1`.
    2.  `field_09_part2`: This is always `CurrentSegmentDurationUnits`.

*   **Field `+0x11` (Next Segment Info) (Revised 2025-06-01):**
    Let `Dur_k` be current segment's duration, `Dur_k+1` be next segment's duration.
    1.  If `Dur_k+1 < 100`: value is `Dur_k+1`.
### Test D: N=4 segments. All durations: 75 units

*Input Durations:* 75, 75, 75, 75 units.

*Hex Dump (TestD.prg):*
```
0000:0000 | 50 52 03 49  4E 05 00 00  00 04 00 08  E8 03 50 49 | PR.IN.......è.PI
0000:0010 | 4E 00 00 00  04 00 00 00  64 00 6C 00  00 00 4B 00 | N.......d.l...K.
0000:0020 | 04 00 01 00  00 4B 00 00  00 00 00 64  00 98 01 00 | .....K.....d....
0000:0030 | 00 4B 00 04  00 01 00 00  4B 00 00 00  00 00 64 00 | .K......K.....d.
0000:0040 | C4 02 00 00  4B 00 04 00  01 00 00 4B  00 00 00 00 | Ä...K......K....
0000:0050 | 00 64 00 F0  03 00 00 4B  00 04 00 01  00 00 4B 00 | .d.ð...K......K.
0000:0060 | 00 00 43 44  B4 04 00 00  90 01 00 00  FF 00 00 FF | ..CD´.......ÿ..ÿ
```

*Header Analysis (Offsets `0x16`, `0x1E`):*
*   `Dur0Units_actual` = 75
*   Field `0x16`: `00 00` (0). `floor(75/100)=0`. Matches.
*   Field `0x1E`: `4B 00` (75). `75 % 100 = 75`. Matches simplified rule.

*Duration Block Analysis (all segments 75 units):*
*   **Block 0 (Seg 0, offset `0x20`):** Dur=75. `Field[+0x09]`: `00 00 64 00` (`part1=0`, `part2=100`). `Field[+0x11]` (for Dur_1=75): `4B 00` (75). Matches HypF.
*   **Block 1 (Seg 1, offset `0x33`):** Dur=75. `Field[+0x09]`: `00 00 64 00` (`part1=0`, `part2=100`). `Field[+0x11]` (for Dur_2=75): `4B 00` (75). Matches HypF.
*   **Block 2 (Seg 2, offset `0x46`):** Dur=75. `Field[+0x09]`: `00 00 64 00` (`part1=0`, `part2=100`). `Field[+0x11]` (for Dur_3=75): `4B 00` (75). Matches HypF.
*   **Block 3 (Seg 3, Last Block, offset `0x59`):** Dur=75. `Field[+0x09]`: `43 44`. Standard.

### Test E: N=4 segments. All durations: 100 units

*Input Durations:* 100, 100, 100, 100 units.

*Hex Dump (TestE.prg):*
```
0000:0000 | 50 52 03 49  4E 05 00 00  00 04 00 08  E8 03 50 49
0000:0010 | 4E 00 00 00  04 00 01 00  64 00 6C 00  00 00 00 00
0000:0020 | 04 00 01 00  00 64 00 00  00 01 00 64  00 98 01 00
0000:0030 | 00 00 00 04  00 01 00 00  64 00 00 00  01 00 64 00
0000:0040 | C4 02 00 00  00 00 04 00  01 00 00 64  00 00 00 01
0000:0050 | 00 64 00 F0  03 00 00 00  00 04 00 01  00 00 64 00
0000:0060 | 00 00 43 44  B4 04 00 00  90 01 00 00  FF 00 00 FF
```

*Header Analysis (Offsets `0x16`, `0x1E`):*
*   `Dur0Units_actual` = 100
*   Field `0x16`: `01 00` (1). `floor(100/100)=1`. Matches.
*   Field `0x1E`: `00 00` (0). `100 % 100 = 0`. Matches simplified rule.

*Duration Block Analysis (all segments 100 units):*
*   **Block 0 (Seg 0, offset `0x20`):** Dur=100. `Field[+0x09]`: `01 00 64 00` (`part1=1`, `part2=100`). `Field[+0x11]` (for Dur_1=100): `00 00` (0). Matches HypF.
*   **Block 1 (Seg 1, offset `0x33`):** Dur=100. `Field[+0x09]`: `01 00 64 00` (`part1=1`, `part2=100`). `Field[+0x11]` (for Dur_2=100): `00 00` (0). Matches HypF.
*   **Block 2 (Seg 2, offset `0x46`):** Dur=100. `Field[+0x09]`: `01 00 64 00` (`part1=1`, `part2=100`). `Field[+0x11]` (for Dur_3=100): `00 00` (0). Matches HypF.
*   **Block 3 (Seg 3, Last Block, offset `0x59`):** Dur=100. `Field[+0x09]`: `43 44`. Standard.

### Test F: N=4 segments. Alternating durations: 70, 120, 70, 120 units

*Input Durations:* 70, 120, 70, 120 units.

*Hex Dump (TestF.prg):*
```
0000:0000 | 50 52 03 49  4E 05 00 00  00 04 00 08  E8 03 50 49
0000:0010 | 4E 00 00 00  04 00 00 00  64 00 6C 00  00 00 46 00
0000:0020 | 04 00 01 00  00 46 00 00  00 01 00 64  00 98 01 00
0000:0030 | 00 14 00 04  00 01 00 00  78 00 00 00  00 00 64 00
0000:0040 | C4 02 00 00  46 00 04 00  01 00 00 46  00 00 00 01
0000:0050 | 00 64 00 F0  03 00 00 14  00 04 00 01  00 00 78 00
0000:0060 | 00 00 43 44  B4 04 00 00  90 01 00 00  FF 00 00 FF
```

*Header Analysis (Offsets `0x16`, `0x1E`):*
*   `Dur0Units_actual` = 70
*   Field `0x16`: `00 00` (0). `floor(70/100)=0`. Matches.
*   Field `0x1E`: `46 00` (70). `70 % 100 = 70`. Matches simplified rule.

*Duration Block Analysis:*
*   **Block 0 (Seg 0, Dur=70, offset `0x20`):** `Field[+0x09]`: `01 00 64 00` (`part1=1`, `part2=100`). `Field[+0x11]` (for Dur_1=120): `78 00` (120). Matches HypF.
*   **Block 1 (Seg 1, Dur=120, offset `0x33`):** `Field[+0x09]`: `00 00 64 00` (`part1=0`, `part2=100`). `Field[+0x11]` (for Dur_2=70): `46 00` (70). Matches HypF.
*   **Block 2 (Seg 2, Dur=70, offset `0x46`):** `Field[+0x09]`: `01 00 64 00` (`part1=1`, `part2=100`). `Field[+0x11]` (for Dur_3=120): `78 00` (120). Matches HypF.
*   **Block 3 (Seg 3, Dur=120, Last Block, offset `0x59`):** `Field[+0x09]`: `43 44`. Standard.

### Test G: N=5 segments. Durations: 70, 70, 120, 120, 70 units

*Input Durations:* 70, 70, 120, 120, 70 units.

*Hex Dump (TestG.prg):*
```
0000:0000 | 50 52 03 49  4E 05 00 00  00 04 00 08  E8 03 50 49
0000:0010 | 61 00 00 00  05 00 00 00  64 00 7F 00  00 00 46 00
0000:0020 | 04 00 01 00  00 46 00 00  00 00 00 64  00 AB 01 00
0000:0030 | 00 46 00 04  00 01 00 00  46 00 00 00  01 00 64 00
0000:0040 | D7 02 00 00  14 00 04 00  01 00 00 78  00 00 00 01
0000:0050 | 00 64 00 03  04 00 00 14  00 04 00 01  00 00 78 00
0000:0060 | 00 00 00 00  64 00 2F 05  00 00 46 00  04 00 01 00
0000:0070 | 00 46 00 00  00 43 44 E0  05 00 00 F4  01 00 00 FF
```

*Header Analysis (Offsets `0x16`, `0x1E`):*
*   `Dur0Units_actual` = 70
*   Field `0x16`: `00 00` (0). `floor(70/100)=0`. Matches.
*   Field `0x1E`: `46 00` (70). `70 % 100 = 70`. Matches simplified rule.

*Duration Block Analysis:*
*   **Block 0 (Seg 0, Dur=70, offset `0x20`):** `Field[+0x09]`: `00 00 64 00` (`part1=0`, `part2=100`). `Field[+0x11]` (for Dur_1=70): `46 00` (70). Matches HypF.
*   **Block 1 (Seg 1, Dur=70, offset `0x33`):** `Field[+0x09]`: `01 00 64 00` (`part1=1`, `part2=100`). `Field[+0x11]` (for Dur_2=120): `78 00` (120). Matches HypF.
*   **Block 2 (Seg 2, Dur=120, offset `0x46`):** `Field[+0x09]`: `01 00 64 00` (`part1=1`, `part2=100`). `Field[+0x11]` (for Dur_3=120): `78 00` (120). Matches HypF.
*   **Block 3 (Seg 3, Dur=120, offset `0x59`):** `Field[+0x09]`: `00 00 64 00` (`part1=0`, `part2=100`). `Field[+0x11]` (for Dur_4=70): `46 00` (70). Matches HypF.
*   **Block 4 (Seg 4, Dur=70, Last Block, offset `0x6C`):** `Field[+0x09]`: `43 44`. Standard.

---

## Further Field[+0x09] and Field[+0x11] Investigation - H & J Series (1000Hz)

**Date:** 2025-06-02 (following analysis of Tests A-G)

These tests further probe `Field[+0x09].part1` and the `Field[+0x11]` anomaly using N=3 segments at 1000Hz.

### Test H1: N=3 segments. Durations: 50, 50, 50 units

*Hex Dump (H1.prg):*
```
0000:0000 | 50 52 03 49  4E 05 00 00  00 04 00 08  E8 03 50 49
0000:0010 | 3B 00 00 00  03 00 00 00  64 00 59 00  00 00 32 00
0000:0020 | 04 00 01 00  00 32 00 00  00 00 00 64  00 85 01 00
0000:0030 | 00 32 00 04  00 01 00 00  32 00 00 00  00 00 64 00
0000:0040 | B1 02 00 00  32 00 04 00  01 00 00 32  00 00 00 43
0000:0050 | 44 88 03 00  00 2C 01 00  00 FF 00 00  FF 00 00 FF
```
*Header (Dur0=50):* `0x16=0000` (0), `0x1E=3200` (50). Matches.
*Block 0 (Dur=50):* `+0x09=00006400` (p1=0, p2=100). `+0x11` (for Dur1=50) = `3200` (50). Matches HypF.
*Block 1 (Dur=50):* `+0x09=00006400` (p1=0, p2=100). `+0x11` (for Dur2=50) = `3200` (50). Matches HypF.
*Block 2 (Dur=50, Last):* Standard.

### Test H2: N=3 segments. Durations: 150, 150, 150 units

*Hex Dump (H2.prg):*
```
0000:0000 | 50 52 03 49  4E 05 00 00  00 04 00 08  E8 03 50 49
0000:0010 | 3B 00 00 00  03 00 01 00  64 00 59 00  00 00 32 00
0000:0020 | 04 00 01 00  00 96 00 00  00 01 00 64  00 85 01 00
0000:0030 | 00 32 00 04  00 01 00 00  96 00 00 00  01 00 64 00
0000:0040 | B1 02 00 00  32 00 04 00  01 00 00 96  00 00 00 43
0000:0050 | 44 88 03 00  00 2C 01 00  00 FF 00 00  FF 00 00 FF
```
*Header (Dur0=150):* `0x16=0100` (1), `0x1E=3200` (50). Matches.
*Block 0 (Dur=150):* `+0x09=01006400` (p1=1, p2=100). `+0x11` (for Dur1=150) = `9600` (150). Matches HypF.
*Block 1 (Dur=150):* `+0x09=01006400` (p1=1, p2=100). `+0x11` (for Dur2=150) = `9600` (150). Matches HypF.
*Block 2 (Dur=150, Last):* Standard.

### Test H3: N=3 segments. Durations: 50, 100, 150 units

*Hex Dump (H3.prg):*
```
0000:0000 | 50 52 03 49  4E 05 00 00  00 04 00 08  E8 03 50 49
0000:0010 | 3B 00 00 00  03 00 00 00  64 00 59 00  00 00 32 00
0000:0020 | 04 00 01 00  00 32 00 00  00 01 00 64  00 85 01 00
0000:0030 | 00 00 00 04  00 01 00 00  64 00 00 00  01 00 64 00
0000:0040 | B1 02 00 00  32 00 04 00  01 00 00 96  00 00 00 43
0000:0050 | 44 88 03 00  00 2C 01 00  00 FF 00 00  FF 00 00 FF
```
*Header (Dur0=50):* `0x16=0000` (0), `0x1E=3200` (50). Matches.
*Block 0 (Dur=50):* `+0x09=01006400` (p1=1, p2=100). `+0x11` (for Dur1=100) = `0000` (0). Matches HypF.
*Block 1 (Dur=100):* `+0x09=01006400` (p1=1, p2=100). `+0x11` (for Dur2=150) = `9600` (150). **DISCREPANCY** with refined HypF rule 3.a (expected 0 if Dur_k=100).
*Block 2 (Dur=150, Last):* Standard.

### Test H4: N=3 segments. Durations: 150, 100, 50 units

*Hex Dump (H4.prg):*
```
0000:0000 | 50 52 03 49  4E 05 00 00  00 04 00 08  E8 03 50 49
0000:0010 | 3B 00 00 00  03 00 01 00  64 00 59 00  00 00 32 00
0000:0020 | 04 00 01 00  00 96 00 00  00 01 00 64  00 85 01 00
0000:0030 | 00 00 00 04  00 01 00 00  64 00 00 00  00 00 64 00
0000:0040 | B1 02 00 00  32 00 04 00  01 00 00 32  00 00 00 43
0000:0050 | 44 88 03 00  00 2C 01 00  00 FF 00 00  FF 00 00 FF
```
*Header (Dur0=150):* `0x16=0100` (1), `0x1E=3200` (50). Matches.
*Block 0 (Dur=150):* `+0x09=01006400` (p1=1, p2=100). `+0x11` (for Dur1=100) = `0000` (0). Matches HypF.
*Block 1 (Dur=100):* `+0x09=00006400` (p1=0, p2=100). `+0x11` (for Dur2=50) = `3200` (50). Matches HypF.
*Block 2 (Dur=50, Last):* Standard.

### Test H5: N=3 segments. Durations: 80, 120, 80 units

*Hex Dump (H5.prg):*
```
0000:0000 | 50 52 03 49  4E 05 00 00  00 04 00 08  E8 03 50 49
0000:0010 | 3B 00 00 00  03 00 00 00  64 00 59 00  00 00 50 00
0000:0020 | 04 00 01 00  00 50 00 00  00 01 00 64  00 85 01 00
0000:0030 | 00 14 00 04  00 01 00 00  78 00 00 00  00 00 64 00
0000:0040 | B1 02 00 00  50 00 04 00  01 00 00 50  00 00 00 43
0000:0050 | 44 88 03 00  00 2C 01 00  00 FF 00 00  FF 00 00 FF
```
*Header (Dur0=80):* `0x16=0000` (0), `0x1E=5000` (80). Matches.
*Block 0 (Dur=80):* `+0x09=01006400` (p1=1, p2=100). `+0x11` (for Dur1=120) = `7800` (120). Matches HypF.
*Block 1 (Dur=120):* `+0x09=00006400` (p1=0, p2=100). `+0x11` (for Dur2=80) = `5000` (80). Matches HypF.
*Block 2 (Dur=80, Last):* Standard.

### Test J1: N=3 segments. Durations: 1240, 470, 1930 units (Repeat of Test A)

*Hex Dump (J1.prg - identical to TestA.prg):*
```
0000:0000 | 50 52 03 49  4E 05 00 00  00 04 00 08  E8 03 50 49
0000:0010 | 3B 00 00 00  03 00 0C 00  64 00 59 00  00 00 28 00
0000:0020 | 04 00 01 00  00 D8 04 00  00 04 00 64  00 85 01 00
0000:0030 | 00 46 00 04  00 01 00 00  D6 01 00 00  13 00 64 00
0000:0040 | B1 02 00 00  1E 00 04 00  01 00 00 8A  07 00 00 43
0000:0050 | 44 88 03 00  00 2C 01 00  00 FF 00 00  FF 00 00 FF
```
*Analysis:* Identical to Test A. Block 1 `+0x11` (for Dur2=1930) is `1E00` (30). Anomaly reproduced.

### Test J2: N=3 segments. Durations: 1240, 470, 1800 units

*Hex Dump (J2.prg):*
```
0000:0000 | 50 52 03 49  4E 05 00 00  00 04 00 08  E8 03 50 49
0000:0010 | 3B 00 00 00  03 00 0C 00  64 00 59 00  00 00 28 00
0000:0020 | 04 00 01 00  00 D8 04 00  00 04 00 64  00 85 01 00
0000:0030 | 00 46 00 04  00 01 00 00  D6 01 00 00  12 00 64 00
0000:0040 | B1 02 00 00  00 00 04 00  01 00 00 08  07 00 00 43
0000:0050 | 44 88 03 00  00 2C 01 00  00 FF 00 00  FF 00 00 FF
```
*Header (Dur0=1240):* Same as J1.
*Block 0 (Dur=1240):* `+0x09=04006400` (p1=4, p2=100). `+0x11` (for Dur1=470) = `D601` (470). Matches HypF.
*Block 1 (Dur=470):* `+0x09=12006400` (p1=18, p2=100). `+0x11` (for Dur2=1800) = `0807` (1800). **Matches HypF! Anomaly gone.**
*Block 2 (Dur=1800, Last):* Standard.

### Test J3: N=3 segments. Durations: 1240, 450, 1930 units

*Hex Dump (J3.prg):*
```
0000:0000 | 50 52 03 49  4E 05 00 00  00 04 00 08  E8 03 50 49
0000:0010 | 3B 00 00 00  03 00 0C 00  64 00 59 00  00 00 28 00
0000:0020 | 04 00 01 00  00 D8 04 00  00 04 00 64  00 85 01 00
0000:0030 | 00 32 00 04  00 01 00 00  C2 01 00 00  13 00 64 00
0000:0040 | B1 02 00 00  1E 00 04 00  01 00 00 8A  07 00 00 43
0000:0050 | 44 88 03 00  00 2C 01 00  00 FF 00 00  FF 00 00 FF
```
*Header (Dur0=1240):* Same as J1.
*Block 0 (Dur=1240):* `+0x09=04006400` (p1=4, p2=100). `+0x11` (for Dur1=450) = `C201` (450). Matches HypF.
*Block 1 (Dur=450):* `+0x09=13006400` (p1=19, p2=100). `+0x11` (for Dur2=1930) = `1E00` (30). **Anomaly persists.**
*Block 2 (Dur=1930, Last):* Standard.

### Test J4: N=3 segments. Durations: 1240, 500, 1930 units

*Hex Dump (J4.prg):*
```
0000:0000 | 50 52 03 49  4E 05 00 00  00 04 00 08  E8 03 50 49
0000:0010 | 3B 00 00 00  03 00 0C 00  64 00 59 00  00 00 28 00
0000:0020 | 04 00 01 00  00 D8 04 00  00 05 00 64  00 85 01 00
0000:0030 | 00 00 00 04  00 01 00 00  F4 01 00 00  13 00 64 00
0000:0040 | B1 02 00 00  1E 00 04 00  01 00 00 8A  07 00 00 43
0000:0050 | 44 88 03 00  00 2C 01 00  00 FF 00 00  FF 00 00 FF
```
*Header (Dur0=1240):* Same as J1.
*Block 0 (Dur=1240):* `+0x09=05006400` (p1=5, p2=100). `+0x11` (for Dur1=500) = `F401` (500). Matches HypF.
*Block 1 (Dur=500):* `+0x09=13006400` (p1=19, p2=100). `+0x11` (for Dur2=1930) = `1E00` (30). **Anomaly persists.**
*Block 2 (Dur=1930, Last):* Standard.

### Test J5: N=3 segments. Durations: 1240, 80, 1930 units

*Hex Dump (J5.prg):*
```
0000:0000 | 50 52 03 49  4E 05 00 00  00 04 00 08  E8 03 50 49
0000:0010 | 3B 00 00 00  03 00 0C 00  64 00 59 00  00 00 28 00
0000:0020 | 04 00 01 00  00 D8 04 00  00 00 00 64  00 85 01 00
0000:0030 | 00 50 00 04  00 01 00 00  50 00 00 00  13 00 64 00
0000:0040 | B1 02 00 00  1E 00 04 00  01 00 00 8A  07 00 00 43
0000:0050 | 44 88 03 00  00 2C 01 00  00 FF 00 00  FF 00 00 FF
```
*Header (Dur0=1240):* Same as J1.
*Block 0 (Dur=1240):* `+0x09=00006400` (p1=0, p2=100). `+0x11` (for Dur1=80) = `5000` (80). Matches HypF.
*Block 1 (Dur=80):* `+0x09=13006400` (p1=19, p2=100). `+0x11` (for Dur2=1930) = `1E00` (30). **Anomaly persists.**
*Block 2 (Dur=1930, Last):* Standard.

---

---

## Field[+0x09].part1 and "1930 Anomaly" Deep Dive - K & L Series (1000Hz)

**Date:** 2025-06-02 (following analysis of Tests H & J)

These N=3 segment tests (1000Hz) further probe `Field[+0x09].part1` and the conditions for the `Field[+0x11]` "1930 Anomaly".

### Set K: Probing `Field[+0x09].field_09_part1`

**Test K1: Durations: 70, 70, 100 units**
*Hex Dump (K1.prg):*
```
0000:0000 | 50 52 03 49  4E 05 00 00  00 04 00 08  E8 03 50 49
0000:0010 | 3B 00 00 00  03 00 00 00  64 00 59 00  00 00 46 00
0000:0020 | 04 00 01 00  00 46 00 00  00 00 00 64  00 85 01 00
0000:0030 | 00 46 00 04  00 01 00 00  46 00 00 00  01 00 64 00
0000:0040 | B1 02 00 00  00 00 04 00  01 00 00 64  00 00 00 43
0000:0050 | 44 88 03 00  00 2C 01 00  00 FF 00 00  FF 00 00 FF
```
*Header (Dur0=70):* `0x16=0000` (0), `0x1E=4600` (70). Matches.
*Block 0 (Dur0=70, Dur1=70):* `+0x09=00006400` (p1=0, p2=100). `+0x11` (for Dur1=70) = `4600` (70). Matches HypF.
*Block 1 (Dur1=70, Dur2=100):* `+0x09=01006400` (p1=1, p2=100). `+0x11` (for Dur2=100) = `0000` (0). Matches HypF.

**Test K2: Durations: 70, 100, 70 units**
*Hex Dump (K2.prg):*
```
0000:0000 | 50 52 03 49  4E 05 00 00  00 04 00 08  E8 03 50 49
0000:0010 | 3B 00 00 00  03 00 00 00  64 00 59 00  00 00 46 00
0000:0020 | 04 00 01 00  00 46 00 00  00 01 00 64  00 85 01 00
0000:0030 | 00 00 00 04  00 01 00 00  64 00 00 00  00 00 64 00
0000:0040 | B1 02 00 00  46 00 04 00  01 00 00 46  00 00 00 43
0000:0050 | 44 88 03 00  00 2C 01 00  00 FF 00 00  FF 00 00 FF
```
*Header (Dur0=70):* `0x16=0000` (0), `0x1E=4600` (70). Matches.
*Block 0 (Dur0=70, Dur1=100):* `+0x09=01006400` (p1=1, p2=100). `+0x11` (for Dur1=100) = `0000` (0). Matches HypF.
*Block 1 (Dur1=100, Dur2=70):* `+0x09=00006400` (p1=0, p2=100). `+0x11` (for Dur2=70) = `4600` (70). Matches HypF.

**Test K3: Durations: 100, 70, 70 units**
*Hex Dump (K3.prg):*
```
0000:0000 | 50 52 03 49  4E 05 00 00  00 04 00 08  E8 03 50 49
0000:0010 | 3B 00 00 00  03 00 01 00  64 00 59 00  00 00 00 00
0000:0020 | 04 00 01 00  00 64 00 00  00 00 00 64  00 85 01 00
0000:0030 | 00 46 00 04  00 01 00 00  46 00 00 00  00 00 64 00
0000:0040 | B1 02 00 00  46 00 04 00  01 00 00 46  00 00 00 43
0000:0050 | 44 88 03 00  00 2C 01 00  00 FF 00 00  FF 00 00 FF
```
*Header (Dur0=100):* `0x16=0100` (1), `0x1E=0000` (0). Matches.
*Block 0 (Dur0=100, Dur1=70):* `+0x09=00006400` (p1=0, p2=100). `+0x11` (for Dur1=70) = `4600` (70). Matches HypF.
*Block 1 (Dur1=70, Dur2=70):* `+0x09=00006400` (p1=0, p2=100). `+0x11` (for Dur2=70) = `4600` (70). Matches HypF.

**Test K4: Durations: 120, 120, 100 units**
*Hex Dump (K4.prg):*
```
0000:0000 | 50 52 03 49  4E 05 00 00  00 04 00 08  E8 03 50 49
0000:0010 | 3B 00 00 00  03 00 01 00  64 00 59 00  00 00 14 00
0000:0020 | 04 00 01 00  00 78 00 00  00 01 00 64  00 85 01 00
0000:0030 | 00 14 00 04  00 01 00 00  78 00 00 00  01 00 64 00
0000:0040 | B1 02 00 00  00 00 04 00  01 00 00 64  00 00 00 43
0000:0050 | 44 88 03 00  00 2C 01 00  00 FF 00 00  FF 00 00 FF
```
*Header (Dur0=120):* `0x16=0100` (1), `0x1E=1400` (20). Matches.
*Block 0 (Dur0=120, Dur1=120):* `+0x09=01006400` (p1=1, p2=100). `+0x11` (for Dur1=120) = `7800` (120). Matches HypF.
*Block 1 (Dur1=120, Dur2=100):* `+0x09=01006400` (p1=1, p2=100). `+0x11` (for Dur2=100) = `0000` (0). Matches HypF.

**Test K5: Durations: 120, 100, 120 units**
*Hex Dump (K5.prg):*
```
0000:0000 | 50 52 03 49  4E 05 00 00  00 04 00 08  E8 03 50 49
0000:0010 | 3B 00 00 00  03 00 01 00  64 00 59 00  00 00 14 00
0000:0020 | 04 00 01 00  00 78 00 00  00 01 00 64  00 85 01 00
0000:0030 | 00 00 00 04  00 01 00 00  64 00 00 00  01 00 64 00
0000:0040 | B1 02 00 00  14 00 04 00  01 00 00 78  00 00 00 43
0000:0050 | 44 88 03 00  00 2C 01 00  00 FF 00 00  FF 00 00 FF
```
*Header (Dur0=120):* `0x16=0100` (1), `0x1E=1400` (20). Matches.
*Block 0 (Dur0=120, Dur1=100):* `+0x09=01006400` (p1=1, p2=100). `+0x11` (for Dur1=100) = `0000` (0). Matches HypF.
*Block 1 (Dur1=100, Dur2=120):* `+0x09=01006400` (p1=1, p2=100). `+0x11` (for Dur2=120) = `7800` (120). Matches HypF (rule 2c, Dur_k=100).

**Test K6: Durations: 100, 120, 120 units**
*Hex Dump (K6.prg):*
```
0000:0000 | 50 52 03 49  4E 05 00 00  00 04 00 08  E8 03 50 49
0000:0010 | 3B 00 00 00  03 00 01 00  64 00 59 00  00 00 00 00
0000:0020 | 04 00 01 00  00 64 00 00  00 01 00 64  00 85 01 00
0000:0030 | 00 14 00 04  00 01 00 00  78 00 00 00  01 00 64 00
0000:0040 | B1 02 00 00  14 00 04 00  01 00 00 78  00 00 00 43
0000:0050 | 44 88 03 00  00 2C 01 00  00 FF 00 00  FF 00 00 FF
```
*Header (Dur0=100):* `0x16=0100` (1), `0x1E=0000` (0). Matches.
*Block 0 (Dur0=100, Dur1=120):* `+0x09=01006400` (p1=1, p2=100). `+0x11` (for Dur1=120) = `7800` (120). Matches HypF (rule 2c, Dur_k=100).
*Block 1 (Dur1=120, Dur2=120):* `+0x09=01006400` (p1=1, p2=100). `+0x11` (for Dur2=120) = `7800` (120). Matches HypF.

**Test K7: Durations: 70, 120, 150 units**
*Hex Dump (K7.prg):*
```
0000:0000 | 50 52 03 49  4E 05 00 00  00 04 00 08  E8 03 50 49
0000:0010 | 3B 00 00 00  03 00 00 00  64 00 59 00  00 00 46 00
0000:0020 | 04 00 01 00  00 46 00 00  00 01 00 64  00 85 01 00
0000:0030 | 00 14 00 04  00 01 00 00  78 00 00 00  01 00 64 00
0000:0040 | B1 02 00 00  32 00 04 00  01 00 00 96  00 00 00 43
0000:0050 | 44 88 03 00  00 2C 01 00  00 FF 00 00  FF 00 00 FF
```
*Header (Dur0=70):* `0x16=0000` (0), `0x1E=4600` (70). Matches.
*Block 0 (Dur0=70, Dur1=120):* `+0x09=01006400` (p1=1, p2=100). `+0x11` (for Dur1=120) = `7800` (120). Matches HypF.
*Block 1 (Dur1=120, Dur2=150):* `+0x09=01006400` (p1=1, p2=100). `+0x11` (for Dur2=150) = `9600` (150). Matches HypF.

**Test K8: Durations: 150, 120, 70 units**
*Hex Dump (K8.prg):*
```
0000:0000 | 50 52 03 49  4E 05 00 00  00 04 00 08  E8 03 50 49
0000:0010 | 3B 00 00 00  03 00 01 00  64 00 59 00  00 00 32 00
0000:0020 | 04 00 01 00  00 96 00 00  00 01 00 64  00 85 01 00
0000:0030 | 00 14 00 04  00 01 00 00  78 00 00 00  00 00 64 00
0000:0040 | B1 02 00 00  46 00 04 00  01 00 00 46  00 00 00 43
0000:0050 | 44 88 03 00  00 2C 01 00  00 FF 00 00  FF 00 00 FF
```
*Header (Dur0=150):* `0x16=0100` (1), `0x1E=3200` (50). Matches.
*Block 0 (Dur0=150, Dur1=120):* `+0x09=01006400` (p1=1, p2=100). `+0x11` (for Dur1=120) = `7800` (120). Matches HypF.
*Block 1 (Dur1=120, Dur2=70):* `+0x09=00006400` (p1=0, p2=100). `+0x11` (for Dur2=70) = `4600` (70). Matches HypF.

### Set L: Mapping the "1930 Anomaly" for `Field[+0x11]`
*(Dur0 = 1000 units for these tests)*

**Test L1: Durations: 1000, 70, 1930 units**
*Hex Dump (L1.prg):*
```
0000:0000 | 50 52 03 49  4E 05 00 00  00 04 00 08  E8 03 50 49
0000:0010 | 3B 00 00 00  03 00 0A 00  64 00 59 00  00 00 00 00
0000:0020 | 04 00 01 00  00 E8 03 00  00 00 00 64  00 85 01 00
0000:0030 | 00 46 00 04  00 01 00 00  46 00 00 00  13 00 64 00
0000:0040 | B1 02 00 00  1E 00 04 00  01 00 00 8A  07 00 00 43
0000:0050 | 44 88 03 00  00 2C 01 00  00 FF 00 00  FF 00 00 FF
```
*Header (Dur0=1000):* `0x16=0A00` (10), `0x1E=0000` (0). Matches.
*Block 0 (Dur0=1000, Dur1=70):* `+0x09=00006400` (p1=0, p2=100). `+0x11` (for Dur1=70) = `4600` (70). Matches HypF.
*Block 1 (Dur1=70, Dur2=1930):* `+0x09=13006400` (p1=19, p2=100). `+0x11` (for Dur2=1930) = `1E00` (30). **Anomaly present.**

**Test L2: Durations: 1000, 100, 1930 units**
*Hex Dump (L2.prg):*
```
0000:0000 | 50 52 03 49  4E 05 00 00  00 04 00 08  E8 03 50 49
0000:0010 | 3B 00 00 00  03 00 0A 00  64 00 59 00  00 00 00 00
0000:0020 | 04 00 01 00  00 E8 03 00  00 01 00 64  00 85 01 00
0000:0030 | 00 00 00 04  00 01 00 00  64 00 00 00  13 00 64 00
0000:0040 | B1 02 00 00  1E 00 04 00  01 00 00 8A  07 00 00 43
0000:0050 | 44 88 03 00  00 2C 01 00  00 FF 00 00  FF 00 00 FF
```
*Header (Dur0=1000):* Same as L1.
*Block 0 (Dur0=1000, Dur1=100):* `+0x09=01006400` (p1=1, p2=100). `+0x11` (for Dur1=100) = `0000` (0). Matches HypF.
*Block 1 (Dur1=100, Dur2=1930):* `+0x09=13006400` (p1=19, p2=100). `+0x11` (for Dur2=1930) = `1E00` (30). **Anomaly present.**

**Test L3: Durations: 1000, 490, 1930 units**
*Hex Dump (L3.prg):*
```
0000:0000 | 50 52 03 49  4E 05 00 00  00 04 00 08  E8 03 50 49
0000:0010 | 3B 00 00 00  03 00 0A 00  64 00 59 00  00 00 00 00
0000:0020 | 04 00 01 00  00 E8 03 00  00 04 00 64  00 85 01 00
0000:0030 | 00 5A 00 04  00 01 00 00  EA 01 00 00  13 00 64 00
0000:0040 | B1 02 00 00  1E 00 04 00  01 00 00 8A  07 00 00 43
0000:0050 | 44 88 03 00  00 2C 01 00  00 FF 00 00  FF 00 00 FF
```
*Header (Dur0=1000):* Same as L1.
*Block 0 (Dur0=1000, Dur1=490):* `+0x09=04006400` (p1=4, p2=100). `+0x11` (for Dur1=490) = `EA01` (490). Matches HypF.
*Block 1 (Dur1=490, Dur2=1930):* `+0x09=13006400` (p1=19, p2=100). `+0x11` (for Dur2=1930) = `1E00` (30). **Anomaly present.**

**Test L4: Durations: 1000, 510, 1930 units**
*Hex Dump (L4.prg):*
```
0000:0000 | 50 52 03 49  4E 05 00 00  00 04 00 08  E8 03 50 49
0000:0010 | 3B 00 00 00  03 00 0A 00  64 00 59 00  00 00 00 00
0000:0020 | 04 00 01 00  00 E8 03 00  00 05 00 64  00 85 01 00
0000:0030 | 00 0A 00 04  00 01 00 00  FE 01 00 00  13 00 64 00
0000:0040 | B1 02 00 00  1E 00 04 00  01 00 00 8A  07 00 00 43
0000:0050 | 44 88 03 00  00 2C 01 00  00 FF 00 00  FF 00 00 FF
```
*Header (Dur0=1000):* Same as L1.
*Block 0 (Dur0=1000, Dur1=510):* `+0x09=05006400` (p1=5, p2=100). `+0x11` (for Dur1=510) = `FE01` (510). Matches HypF.
*Block 1 (Dur1=510, Dur2=1930):* `+0x09=13006400` (p1=19, p2=100). `+0x11` (for Dur2=1930) = `1E00` (30). **Anomaly present.**

**Test L5: Durations: 1000, 600, 1930 units**
*Hex Dump (L5.prg):*
```
0000:0000 | 50 52 03 49  4E 05 00 00  00 04 00 08  E8 03 50 49
0000:0010 | 3B 00 00 00  03 00 0A 00  64 00 59 00  00 00 00 00
0000:0020 | 04 00 01 00  00 E8 03 00  00 06 00 64  00 85 01 00
0000:0030 | 00 00 00 04  00 01 00 00  58 02 00 00  13 00 64 00
0000:0040 | B1 02 00 00  1E 00 04 00  01 00 00 8A  07 00 00 43
0000:0050 | 44 88 03 00  00 2C 01 00  00 FF 00 00  FF 00 00 FF
```
*Header (Dur0=1000):* Same as L1.
*Block 0 (Dur0=1000, Dur1=600):* `+0x09=06006400` (p1=6, p2=100). `+0x11` (for Dur1=600) = `5802` (600). Matches HypF.
*Block 1 (Dur1=600, Dur2=1930):* `+0x09=13006400` (p1=19, p2=100). `+0x11` (for Dur2=1930) = `1E00` (30). **Anomaly present.**

**Test L6: Durations: 1000, 1000, 1930 units**
*Hex Dump (L6.prg):*
```
0000:0000 | 50 52 03 49  4E 05 00 00  00 04 00 08  E8 03 50 49
0000:0010 | 3B 00 00 00  03 00 0A 00  64 00 59 00  00 00 00 00
0000:0020 | 04 00 01 00  00 E8 03 00  00 0A 00 64  00 85 01 00
0000:0030 | 00 00 00 04  00 01 00 00  E8 03 00 00  13 00 64 00
0000:0040 | B1 02 00 00  1E 00 04 00  01 00 00 8A  07 00 00 43
0000:0050 | 44 88 03 00  00 2C 01 00  00 FF 00 00  FF 00 00 FF
```
*Header (Dur0=1000):* Same as L1.
*Block 0 (Dur0=1000, Dur1=1000):* `+0x09=0A006400` (p1=10, p2=100). `+0x11` (for Dur1=1000) = `E803` (1000). Matches HypF.
*Block 1 (Dur1=1000, Dur2=1930):* `+0x09=13006400` (p1=19, p2=100). `+0x11` (for Dur2=1930) = `1E00` (30). **Anomaly present.**

**Test L7: Durations: 1000, 1929, 1930 units**
*Hex Dump (L7.prg):*
```
0000:0000 | 50 52 03 49  4E 05 00 00  00 04 00 08  E8 03 50 49
0000:0010 | 3B 00 00 00  03 00 0A 00  64 00 59 00  00 00 00 00
0000:0020 | 04 00 01 00  00 E8 03 00  00 13 00 64  00 85 01 00
0000:0030 | 00 1D 00 04  00 01 00 00  89 07 00 00  13 00 64 00
0000:0040 | B1 02 00 00  1E 00 04 00  01 00 00 8A  07 00 00 43
0000:0050 | 44 88 03 00  00 2C 01 00  00 FF 00 00  FF 00 00 FF
```
*Header (Dur0=1000):* Same as L1.
*Block 0 (Dur0=1000, Dur1=1929):* `+0x09=13006400` (p1=19, p2=100). `+0x11` (for Dur1=1929) = `8907` (1929). Matches HypF.
*Block 1 (Dur1=1929, Dur2=1930):* `+0x09=13006400` (p1=19, p2=100). `+0x11` (for Dur2=1930) = `1E00` (30). **Anomaly present.**

---

## Deduced Logic and Hypotheses (as of 2025-06-02, after K & L series)

This section summarizes the current understanding based on all analyzed PRG files, including Tests A-L.

### Header Fields `0x16` and `0x1E`

Let:
*   `Dur0Units_actual`: The duration of the first PRG segment (Segment 0) in PRG time units.
*   `N_prg`: The total number of PRG segments in the file.
*   `NominalBase = 100`.
*   `val_0x16_dec`: The decimal value for field `0x16`.
*   `val_0x1E_dec`: The decimal value for field `0x1E`.

**Field `0x16` (Header First Segment Info):**
  `val_0x16_dec = floor(Dur0Units_actual / NominalBase)`
  *This logic holds universally across all tests (A-L, N=1 and N>1, various refresh rates).*

**Field `0x1E` (Header First Segment Duration (Conditional)):**
Refined Hypothesis for Header Field 0x1E:
Let NominalBase = 100.

    If N_prg == 1:
        If Dur0Units_actual % NominalBase == 0: (Dur0 is a multiple of 100)
            If RefreshRate == 1 OR Dur0Units_actual == NominalBase: val_0x1E_dec = 0.
            Else (RefreshRate != 1 AND Dur0Units_actual != NominalBase): val_0x1E_dec = Dur0Units_actual.
        Else (Dur0Units_actual % NominalBase != 0):
            val_0x1E_dec = Dur0Units_actual % NominalBase.

    If N_prg > 1:
        If Dur0Units_actual == NominalBase (i.e., 100): val_0x1E_dec = 0.
        Else: val_0x1E_dec = Dur0Units_actual.

    Justification for N=1 refinement: This handles the 1Hz, Dur0=200 case (0x1E=0) and the 1000Hz, Dur0=500/1000 cases (0x1E=Dur0).

    Justification for N>1 refinement: This handles red_1s_blue_.5s_1000r.prg (Dur0=1000, 0x1E=1000) and other N>1 cases correctly. The key is that for N>1, if Dur0 is not 100, 0x1E seems to just be Dur0Units_actual.
The byte values written to the file are `struct.pack('<H', val_0x16_dec)` and `struct.pack('<H', val_0x1E_dec & 0xFFFF)`.
*This logic for header fields 0x16 and 0x1E appears consistent across all known tests (A-L).*

### Intermediate Duration Block Fields (Segments 0 to N-2)

**Field `+0x09` (Segment Index & Duration):**
This 4-byte field consists of two 2-byte Little Endian values: `field_09_part1` and `field_09_part2`.

*   **`field_09_part2` (Consistent Observation from Tests A-L):**
    *   For all intermediate duration blocks (segments 0 to N-2) observed in Tests A-L (1000Hz refresh rate), `field_09_part2` is consistently `64 00` (decimal 100). This holds true irrespective of the `CurrentSegmentDurationUnits` of the block or surrounding blocks.

*   **`field_09_part1` (Strong Hypothesis based on Tests A-L):**
    *   For an intermediate duration block `k` (representing segment `k`), if the *next* segment (segment `k+1`) has duration `Dur_k+1`:
        **`field_09_part1 (for block k) = floor(Dur_k+1 / 100)`**
    *   This hypothesis correctly predicts `field_09_part1` for **all intermediate blocks in all official app tests A-L**.
    *   The `prg_generator.py` currently uses a static `00 00` for this part. Implementing this new dynamic hypothesis is strongly recommended to align more closely with official app behavior.

**Field `+0x11` (Next Segment Info) (Revised Hypothesis F, based on A-L tests):**
Let `Dur_k` be current segment's duration (in PRG time units), `Dur_k+1` be next segment's duration.

1.  **Special Override Case ("1930 Anomaly"):**
    *   If `Dur_k+1 == 1930`: `Field[+0x11]` for Block `k` (which describes segment `k`) is `1E 00` (decimal 30).
    *   The L-series tests (L1-L7) show this override triggers if `Dur_k+1` is 1930, *regardless of the value of `Dur_k`* (tested for `Dur_k` from 70 to 1929).

2.  **General Rules (if not overridden by the 1930 anomaly):**
    a.  If `Dur_k+1 < 100`: `Field[+0x11] = Dur_k+1`.
    b.  Else if `Dur_k+1 == 100`: `Field[+0x11] = 0`.
    c.  Else (`Dur_k+1 > 100`): `Field[+0x11] = Dur_k+1`.
        *   This simplified rule (2.c) is supported by Test H3 (Dur_k=100, Dur_k+1=150, Field[+0x11]=150) and other K-series tests. The previous idea that `Field[+0x11]` would be 0 if `Dur_k=100` and `Dur_k+1 > 100` (and not 1930) was shown to be an over-complication.

*The `prg_generator.py` should be updated to reflect this refined general logic for `Field[+0x11]`. The "1930 Anomaly" appears to be a straightforward override when `Dur_k+1 == 1930`.*
The model for `field_09_part1` is now very strong and recommended for implementation.