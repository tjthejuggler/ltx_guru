# Official LTX App PRG File Test Dumps and Analysis

**Last Updated:** 2025-06-02 16:25 UTC+7

This document records hex dumps from `.prg` files generated by the official LTX application. These serve as a ground truth for reverse-engineering and validating the PRG file format, especially for conditional header fields.

All examples below were generated with a 4-pixel setting and a 1Hz refresh rate, unless otherwise specified.

## Single Segment, 1Hz Refresh Rate Examples

These examples show how header fields `0x16` and `0x1E` behave for single-segment files with varying durations at a 1Hz PRG refresh rate.

**Common Header Values for N=1, 1Hz Refresh Rate, 4px:**
*   `0x00-0x07`: `50 52 03 49 4E 05 00 00` (Signature)
*   `0x08-0x09`: `00 04` (Default Pixels = 4, Big Endian)
*   `0x0A-0x0B`: `00 08` (Constant)
*   `0x0C-0x0D`: `01 00` (Refresh Rate = 1Hz, Little Endian)
*   `0x0E-0x0F`: `50 49` ('PI' Marker)
*   `0x10-0x13`: `15 00 00 00` (Pointer1 = 21, for N=1)
*   `0x14-0x15`: `01 00` (Segment Count N = 1)
*   `0x18-0x19`: `64 00` (RGB Data Repetition Count = 100)
*   `0x1A-0x1B`: `33 00` (RGB Data Start Offset = 51, for N=1)
*   `0x1C-0x1D`: `00 00` (Constant)

### 1s (Duration `Dur0Units_actual` = 1)
```
0000:0000 | 50 52 03 49  4E 05 00 00  00 04 00 08  01 00 50 49 | PR.IN.........PI
0000:0010 | 15 00 00 00  01 00 00 00  64 00 33 00  00 00 01 00 | ........d.3.....
```
*   `0x16-0x17`: `00 00` (Field 0x16 Value = 0)
*   `0x1E-0x1F`: `01 00` (Field 0x1E Value = 1)

### 2s (Duration `Dur0Units_actual` = 2)
```
0000:0000 | 50 52 03 49  4E 05 00 00  00 04 00 08  01 00 50 49 | PR.IN.........PI
0000:0010 | 15 00 00 00  01 00 00 00  64 00 33 00  00 00 02 00 | ........d.3.....
```
*   `0x16-0x17`: `00 00` (Field 0x16 Value = 0)
*   `0x1E-0x1F`: `02 00` (Field 0x1E Value = 2)

### 10s (Duration `Dur0Units_actual` = 10)
```
0000:0000 | 50 52 03 49  4E 05 00 00  00 04 00 08  01 00 50 49 | PR.IN.........PI
0000:0010 | 15 00 00 00  01 00 00 00  64 00 33 00  00 00 0A 00 | ........d.3.....
```
*   `0x16-0x17`: `00 00` (Field 0x16 Value = 0)
*   `0x1E-0x1F`: `0A 00` (Field 0x1E Value = 10)

### 50s (Duration `Dur0Units_actual` = 50)
```
0000:0000 | 50 52 03 49  4E 05 00 00  00 04 00 08  01 00 50 49 | PR.IN.........PI
0000:0010 | 15 00 00 00  01 00 00 00  64 00 33 00  00 00 32 00 | ........d.3...2.
```
*   `0x16-0x17`: `00 00` (Field 0x16 Value = 0)
*   `0x1E-0x1F`: `32 00` (Field 0x1E Value = 50)

### 99s (Duration `Dur0Units_actual` = 99)
```
0000:0000 | 50 52 03 49  4E 05 00 00  00 04 00 08  01 00 50 49 | PR.IN.........PI
0000:0010 | 15 00 00 00  01 00 00 00  64 00 33 00  00 00 63 00 | ........d.3...c.
```
*   `0x16-0x17`: `00 00` (Field 0x16 Value = 0)
*   `0x1E-0x1F`: `63 00` (Field 0x1E Value = 99)

### 100s (Duration `Dur0Units_actual` = 100)
```
0000:0000 | 50 52 03 49  4E 05 00 00  00 04 00 08  01 00 50 49 | PR.IN.........PI
0000:0010 | 15 00 00 00  01 00 01 00  64 00 33 00  00 00 00 00 | ........d.3.....
```
*   `0x16-0x17`: `01 00` (Field 0x16 Value = 1)
*   `0x1E-0x1F`: `00 00` (Field 0x1E Value = 0)

### 101s (Duration `Dur0Units_actual` = 101)
```
0000:0000 | 50 52 03 49  4E 05 00 00  00 04 00 08  01 00 50 49 | PR.IN.........PI
0000:0010 | 15 00 00 00  01 00 01 00  64 00 33 00  00 00 01 00 | ........d.3.....
```
*   `0x16-0x17`: `01 00` (Field 0x16 Value = 1)
*   `0x1E-0x1F`: `01 00` (Field 0x1E Value = 1)

### 200s (Duration `Dur0Units_actual` = 200)
```
0000:0000 | 50 52 03 49  4E 05 00 00  00 04 00 08  01 00 50 49 | PR.IN.........PI
0000:0010 | 15 00 00 00  01 00 02 00  64 00 33 00  00 00 00 00 | ........d.3.....
```
*   `0x16-0x17`: `02 00` (Field 0x16 Value = 2)
*   `0x1E-0x1F`: `00 00` (Field 0x1E Value = 0)

## Multi-Segment, 1Hz Refresh Rate Examples

### red_1s_blue_1s_1r.prg (N=2, Dur0Units_actual=1)
```
0000:0000 | 50 52 03 49  4E 05 00 00  00 04 00 08  01 00 50 49 | PR.IN.........PI
0000:0010 | 28 00 00 00  02 00 00 00  64 00 46 00  00 00 01 00 | (.......d.F.....
0000:0020 | 04 00 01 00  00 01 00 00  00 00 00 64  00 72 01 00 | ...........d.r..
0000:0030 | 00 01 00 04  00 01 00 00  01 00 00 00  43 44 5C 02 | ............CD\.
```
*   `0x14-0x15`: `02 00` (Segment Count N = 2)
*   `0x16-0x17`: `00 00` (Field 0x16 Value = 0)
*   `0x1E-0x1F`: `01 00` (Field 0x1E Value = 1)

### red_1s_blue_1s_green_1s_1r.prg (N=3, Dur0Units_actual=1)
```
0000:0000 | 50 52 03 49  4E 05 00 00  00 04 00 08  01 00 50 49 | PR.IN.........PI
0000:0010 | 3B 00 00 00  03 00 00 00  64 00 59 00  00 00 01 00 | ;.......d.Y.....
0000:0020 | 04 00 01 00  00 01 00 00  00 00 00 64  00 85 01 00 | ...........d....
```
*   `0x14-0x15`: `03 00` (Segment Count N = 3)
*   `0x16-0x17`: `00 00` (Field 0x16 Value = 0)
*   `0x1E-0x1F`: `01 00` (Field 0x1E Value = 1)

### red_1s_blue_2s_1r.prg (N=2, Dur0Units_actual=1)
Same header as `red_1s_blue_1s_1r.prg` for fields 0x16 and 0x1E.
```
0000:0000 | 50 52 03 49  4E 05 00 00  00 04 00 08  01 00 50 49 | PR.IN.........PI
0000:0010 | 28 00 00 00  02 00 00 00  64 00 46 00  00 00 01 00 | (.......d.F.....
```
*   `0x16-0x17`: `00 00`
*   `0x1E-0x1F`: `01 00`

### red_50s_blue_50s_1r.prg (N=2, Dur0Units_actual=50)
```
0000:0000 | 50 52 03 49  4E 05 00 00  00 04 00 08  01 00 50 49 | PR.IN.........PI
0000:0010 | 28 00 00 00  02 00 00 00  64 00 46 00  00 00 32 00 | (.......d.F...2.
```
*   `0x16-0x17`: `00 00` (Field 0x16 Value = 0)
*   `0x1E-0x1F`: `32 00` (Field 0x1E Value = 50)

### red_100s_blue_50s_1r.prg (N=2, Dur0Units_actual=100)
```
0000:0000 | 50 52 03 49  4E 05 00 00  00 04 00 08  01 00 50 49 | PR.IN.........PI
0000:0010 | 28 00 00 00  02 00 01 00  64 00 46 00  00 00 00 00 | (.......d.F.....
```
*   `0x16-0x17`: `01 00` (Field 0x16 Value = 1)
*   `0x1E-0x1F`: `00 00` (Field 0x1E Value = 0)


## Deduced Logic for Header Fields 0x16 and 0x1E

Let:
*   `Dur0Units_actual`: The duration of the first PRG segment in PRG time units.
*   `N_prg`: The total number of PRG segments in the file.
*   `val_0x16_dec`: The decimal value calculated for field `0x16`.

**Field `0x16` (Header First Segment Info):**
1.  If `N_prg == 1`:
    *   `val_0x16_dec = floor(Dur0Units_actual / 100)`
2.  Else (`N_prg > 1`):
    *   If `Dur0Units_actual == 100`: `val_0x16_dec = 1`
    *   Else (`Dur0Units_actual != 100`): `val_0x16_dec = 0`
*   The byte value written to the file is `struct.pack('<H', val_0x16_dec)`.

**Field `0x1E` (Header First Segment Duration (Conditional)):**
1.  If `N_prg == 1`:
    *   `val_0x1E_dec = Dur0Units_actual - (val_0x16_dec * 100)`
      (Note: `val_0x16_dec` is the decimal value calculated for field `0x16` above)
2.  Else (`N_prg > 1`):
    *   If `Dur0Units_actual == 100`: `val_0x1E_dec = 0`
    *   Else (`Dur0Units_actual != 100`): `val_0x1E_dec = Dur0Units_actual`
*   The byte value written to the file is `struct.pack('<H', val_0x1E_dec & 0xFFFF)`.

This logic appears consistent with all provided 1Hz examples.

---

## Important Finding: 1Hz PRG with 100 Color Slots Experiment (Failed)

**Date:** 2025-06-01

An experiment was conducted using a modified generator (`prg_generator_new.py`) that produced PRG files with a 1Hz master refresh rate. The intention was to use the 100 RGB color data slots within each 1-second PRG segment to achieve 0.01s granularity.

**Observation:** The LTX ball firmware appears to **only use the first RGB color** from the 300-byte (100x3 RGB) color data block when the PRG file's refresh rate is 1Hz. The remaining 99 color slots are ignored for display purposes in this mode.

**Example JSON that resulted in solid yellow (not yellow then black):**
```json
{
  "default_pixels": 4,
  "color_format": "rgb",
  "refresh_rate": 100,
  "end_time": 100,
  "sequence": {
    "0": {"color": [255, 255, 0], "pixels": 4},    // Yellow
    "1": {"color": [0, 0, 0], "pixels": 4}         // Black (intended for 0.01s later)
  }
}
```
Resulting PRG (1Hz) showed solid yellow for 1 second.

**Example JSON that resulted in solid red (not red then blue):**
```json
{
  "default_pixels": 4,
  "color_format": "rgb",
  "refresh_rate": 100,
  "end_time": 100,
  "sequence": {
    "0": {"color": [255, 0, 0], "pixels": 4},     // Red
    "50": {"color": [0, 0, 255], "pixels": 4}    // Blue (intended for 0.5s later)
  }
}
```
Resulting PRG (1Hz) showed solid red for 1 second.

**Conclusion:** High-frequency color changes cannot be achieved by manipulating the 100 sub-color slots within a 1Hz PRG segment. A higher PRG refresh rate (e.g., 100Hz or 1000Hz) is necessary for fine-grained temporal resolution.

---

## 1000Hz Refresh Rate Examples (PRG Refresh Rate = 1000)

These examples use a PRG file refresh rate of 1000Hz (`03E8` Little Endian).
All are 4-pixel.

**Common Header Values for 1000Hz Refresh Rate, 4px:**
*   `0x00-0x07`: `50 52 03 49 4E 05 00 00` (Signature)
*   `0x08-0x09`: `00 04` (Default Pixels = 4, Big Endian)
*   `0x0A-0x0B`: `00 08` (Constant)
*   `0x0C-0x0D`: `E8 03` (Refresh Rate = 1000Hz, Little Endian)
*   `0x0E-0x0F`: `50 49` ('PI' Marker)
*   `0x18-0x19`: `64 00` (RGB Data Repetition Count = 100)
*   `0x1C-0x1D`: `00 00` (Constant)

### red_.01s_1000r.prg (N=1, Dur0Units_actual = 10)
*Actual Hex:*
```
0000:0000 | 50 52 03 49  4E 05 00 00  00 04 00 08  E8 03 50 49 | PR.IN.......è.PI
0000:0010 | 15 00 00 00  01 00 00 00  64 00 33 00  00 00 0A 00 | ........d.3.....
```
*   `0x16-0x17`: `00 00` (Value 0)
*   `0x1E-0x1F`: `0A 00` (Value 10)

### red_.1s_1000r.prg (N=1, Dur0Units_actual = 100)
*Actual Hex:*
```
0000:0000 | 50 52 03 49  4E 05 00 00  00 04 00 08  E8 03 50 49 | PR.IN.......è.PI
0000:0010 | 15 00 00 00  01 00 01 00  64 00 33 00  00 00 00 00 | ........d.3.....
```
*   `0x16-0x17`: `01 00` (Value 1)
*   `0x1E-0x1F`: `00 00` (Value 0)

### red_0.5s_1000r.prg (N=1, Dur0Units_actual = 500)
*Actual Hex:*
```
0000:0000 | 50 52 03 49  4E 05 00 00  00 04 00 08  E8 03 50 49 | PR.IN.......è.PI
0000:0010 | 15 00 00 00  01 00 05 00  64 00 33 00  00 00 F4 01 | ........d.3...ô.
```
*   `0x16-0x17`: `05 00` (Value 5)
*   `0x1E-0x1F`: `F4 01` (Value 500)

### red_1s_1000r.prg (N=1, Dur0Units_actual = 1000)
*Actual Hex:*
```
0000:0000 | 50 52 03 49  4E 05 00 00  00 04 00 08  E8 03 50 49 | PR.IN.......è.PI
0000:0010 | 15 00 00 00  01 00 0A 00  64 00 33 00  00 00 E8 03 | ........d.3...è.
```
*   `0x16-0x17`: `0A 00` (Value 10)
*   `0x1E-0x1F`: `E8 03` (Value 1000)

### red_5s_1000r.prg (N=1, Dur0Units_actual = 5000)
*Actual Hex:*
```
0000:0000 | 50 52 03 49  4E 05 00 00  00 04 00 08  E8 03 50 49 | PR.IN.......è.PI
0000:0010 | 15 00 00 00  01 00 32 00  64 00 33 00  00 00 88 13 | ......2.d.3.....
```
*   `0x16-0x17`: `32 00` (Value 50)
*   `0x1E-0x1F`: `88 13` (Value 5000)


### red_10s_1000r.prg (N=1, Dur0Units_actual = 10000)
*Actual Hex:*
```
0000:0000 | 50 52 03 49  4E 05 00 00  00 04 00 08  E8 03 50 49 | PR.IN.......è.PI
0000:0010 | 15 00 00 00  01 00 64 00  64 00 33 00  00 00 10 27 | ......d.d.3....'
```
*   `0x16-0x17`: `64 00` (Value 100)
*   `0x1E-0x1F`: `10 27` (Value 10000)

### Header `0x1E` (N=1, Dur0 = multiple of 100) Pinpoint Threshold Tests

*   Objective: Pinpoint the threshold between 400ms and 500ms for Field `0x1E` when N=1 and Dur0 is a multiple of 100.
*   All tests are 1000Hz PRG refresh rate.

#### Test H_0x1E_1: N=1, Dur0 = 401ms
*   Expected: `0x1E = 1` (01 00)
*   Header: `0x16 = 0400` (4), `0x1E = 0100` (1)
```
0000:0000 | 50 52 03 49  4E 05 00 00  00 04 00 08  E8 03 50 49 | PR.IN.......è.PI
0000:0010 | 15 00 00 00  01 00 04 00  64 00 33 00  00 00 01 00 | ........d.3.....
0000:0020 | 04 00 01 00  00 91 01 00  00 43 44 30  01 00 00 64 | .....‘...CD0...d
0000:0030 | 00 00 00 FF  00 00 FF 00  00 FF 00 00  FF 00 00 FF | ...ÿ..ÿ..ÿ..ÿ..ÿ
```

#### Test H_0x1E_2: N=1, Dur0 = 499ms
*   Expected: `0x1E = 99` (63 00)
*   Header: `0x16 = 0400` (4), `0x1E = 6300` (99)
```
0000:0000 | 50 52 03 49  4E 05 00 00  00 04 00 08  E8 03 50 49 | PR.IN.......è.PI
0000:0010 | 15 00 00 00  01 00 04 00  64 00 33 00  00 00 63 00 | ........d.3...c.
0000:0020 | 04 00 01 00  00 F3 01 00  00 43 44 30  01 00 00 64 | .....ó...CD0...d
0000:0030 | 00 00 00 FF  00 00 FF 00  00 FF 00 00  FF 00 00 FF | ...ÿ..ÿ..ÿ..ÿ..ÿ
```

#### Test H_0x1E_3: N=1, Dur0 = 420ms
*   Expected: `0x1E = 0` (00 00) if threshold > 420ms for the "0" rule, or `0x1E = 20` (14 00) if it's `Dur0 % 100`.
*   Actual: `0x1E = 1400` (20)
*   Header: `0x16 = 0400` (4), `0x1E = 1400` (20)
```
0000:0000 | 50 52 03 49  4E 05 00 00  00 04 00 08  E8 03 50 49 | PR.IN.......è.PI
0000:0010 | 15 00 00 00  01 00 04 00  64 00 33 00  00 00 14 00 | ........d.3.....
0000:0020 | 04 00 01 00  00 A4 01 00  00 43 44 30  01 00 00 64 | .....¤...CD0...d
0000:0030 | 00 00 00 FF  00 00 FF 00  00 FF 00 00  FF 00 00 FF | ...ÿ..ÿ..ÿ..ÿ..ÿ
```
*   Analysis: For Dur0=420 (N=1, 1000Hz), `0x1E` = 20. This means `Dur0 % 100` is applied. This contradicts the S2 test (Dur0=400 gives 0x1E=0). This suggests the threshold for N=1 multiples of 100 (where 0x1E becomes 0) is *exactly* 400ms, or the rule is more complex.

#### Test H_0x1E_4: N=1, Dur0 = 480ms
*   Expected: `0x1E = 0` (00 00) if threshold for "0" rule > 480ms, or `0x1E = 480` (E0 01) if it's direct passthrough, or `0x1E = 80` (50 00) if `Dur0 % 100`.
*   Actual: `0x1E = 5000` (80)
*   Header: `0x16 = 0400` (4), `0x1E = 5000` (80)
```
0000:0000 | 50 52 03 49  4E 05 00 00  00 04 00 08  E8 03 50 49 | PR.IN.......è.PI
0000:0010 | 15 00 00 00  01 00 04 00  64 00 33 00  00 00 50 00 | ........d.3...P.
0000:0020 | 04 00 01 00  00 E0 01 00  00 43 44 30  01 00 00 64 | .....à...CD0...d
0000:0030 | 00 00 00 FF  00 00 FF 00  00 FF 00 00  FF 00 00 FF | ...ÿ..ÿ..ÿ..ÿ..ÿ
```
*   Analysis: For Dur0=480 (N=1, 1000Hz), `0x1E` = 80. This means `Dur0 % 100` is applied. Consistent with H_0x1E_3.
*   The S2 test (Dur0=400, 0x1E=0) and Q1 (Dur0=200, 0x1E=0), Q2 (Dur0=300, 0x1E=0) show `0x1E=0` for multiples of 100 up to 400ms.
*   red_0.5s_1000r.prg (Dur0=500, N=1) has `0x1E=500`.
*   This new H_0x1E series suggests for N=1, 1000Hz:
    *   If `Dur0Units_actual % 100 == 0`:
        *   If `Dur0Units_actual <= 400`: `val_0x1E_dec = 0`.
        *   Else (`Dur0Units_actual >= 500`): `val_0x1E_dec = Dur0Units_actual`.
    *   Else (`Dur0Units_actual % 100 != 0`): `val_0x1E_dec = Dur0Units_actual % 100`. (Confirmed by H_0x1E_1, H_0x1E_2, H_0x1E_3, H_0x1E_4).

---
### red_0.1s_blue_0.1s_1000r.prg (N=2, Dur0Units_actual=100)
*Actual Hex:*
```
0000:0000 | 50 52 03 49  4E 05 00 00  00 04 00 08  E8 03 50 49 | PR.IN.......è.PI
0000:0010 | 28 00 00 00  02 00 01 00  64 00 46 00  00 00 00 00 | (.......d.F.....
```
*   `0x14-0x15` (N): `02 00` (2)
*   `0x16-0x17` (Field 0x16, from Dur0=100): `01 00` (Value 1)
*   `0x1E-0x1F` (Field 0x1E, from Dur0=100): `00 00` (Value 0)


### red_1s_blue_.5s_1000r.prg (N=2, Dur0Units_actual=1000)
*Actual Hex:*
```
0000:0000 | 50 52 03 49  4E 05 00 00  00 04 00 08  E8 03 50 49 | PR.IN.......è.PI
0000:0010 | 28 00 00 00  02 00 0A 00  64 00 46 00  00 00 E8 03 | (.......d.F...è.
```
*   `0x14-0x15` (N): `02 00` (2)
*   `0x16-0x17` (Field 0x16, from Dur0=1000): `0A 00` (Value 10)
*   `0x1E-0x1F` (Field 0x1E, from Dur0=1000): `E8 03` (Value 1000)


---

### High Segment Count (N > 255) at 1000Hz Refresh Rate Examples

**Date:** 2025-06-01

These examples are to investigate how the PRG format handles segment counts exceeding 255.
All files have a 0.1s segment duration and 1000Hz refresh rate.
This means each segment has `Dur0Units_actual = 0.1 * 1000 = 100`.
The common header values for Refresh Rate (`E8 03` at `0x0C-0x0D`), Field `0x16` (`01 00` at `0x16-0x17`), and Field `0x1E` (`00 00` at `0x1E-0x1F`) are consistent with `Dur0Units_actual=100` according to Hypothesis 8.

#### N253_.1s_1000r.prg (Actual N=253, Dur0Units_actual=100)
*Actual Hex (first 256 bytes):*
```
0000:0000 | 50 52 03 49  4E 05 00 00  00 04 00 08  E8 03 50 49 | PR.IN.......è.PI
0000:0010 | C9 12 00 00  FD 00 01 00  64 00 E7 12  00 00 00 00 | É...ý...d.ç.....
0000:0020 | 04 00 01 00  00 64 00 00  00 01 00 64  00 13 14 00 | .....d.....d....
0000:0030 | 00 00 00 04  00 01 00 00  64 00 00 00  01 00 64 00 | ........d.....d.
0000:0040 | 3F 15 00 00  00 00 04 00  01 00 00 64  00 00 00 01 | ?..........d....
0000:0050 | 00 64 00 6B  16 00 00 00  00 04 00 01  00 00 64 00 | .d.k..........d.
0000:0060 | 00 00 01 00  64 00 97 17  00 00 00 00  04 00 01 00 | ....d...........
0000:0070 | 00 64 00 00  00 01 00 64  00 C3 18 00  00 00 00 04 | .d.....d.Ã......
0000:0080 | 00 01 00 00  64 00 00 00  01 00 64 00  EF 19 00 00 | ....d.....d.ï...
0000:0090 | 00 00 04 00  01 00 00 64  00 00 00 01  00 64 00 1B | .......d.....d..
0000:00A0 | 1B 00 00 00  00 04 00 01  00 00 64 00  00 00 01 00 | ..........d.....
0000:00B0 | 64 00 47 1C  00 00 00 00  04 00 01 00  00 64 00 00 | d.G..........d..
0000:00C0 | 00 01 00 64  00 73 1D 00  00 00 00 04  00 01 00 00 | ...d.s..........
0000:00D0 | 64 00 00 00  01 00 64 00  9F 1E 00 00  00 00 04 00 | d.....d.........
0000:00E0 | 01 00 00 64  00 00 00 01  00 64 00 CB  1F 00 00 00 | ...d.....d.Ë....
0000:00F0 | 00 04 00 01  00 00 64 00  00 00 01 00  64 00 F7 20 | ......d.....d.÷
0000:0100 | 00 00 00 00  04 00 01 00  00 64 00 00  00 01 00 64 | .........d.....d
```
*   `0x10-0x13` (Pointer1): `C9 12 00 00` (`0x12C9` = 4809). Formula `21 + 19*(253-1) = 21 + 19*252 = 21 + 4788 = 4809`. Matches.
*   `0x14-0x15` (Segment Count N): `FD 00` (`0x00FD` = 253). Matches.
*   `0x1A-0x1B` (RGB Data Start Offset): `E7 12` (`0x12E7` = 4839). Formula `32 + 253*19 = 32 + 4807 = 4839`. Matches.

#### N257_.1s_1000r.prg (Actual N=257, Dur0Units_actual=100)
**Note:** Filename has been corrected to match actual segment count. Header fields consistently point to N=257.
*Actual Hex (first 256 bytes):*
```
0000:0000 | 50 52 03 49  4E 05 00 00  00 04 00 08  E8 03 50 49 | PR.IN.......è.PI
0000:0010 | 15 13 00 00  01 01 01 00  64 00 33 13  00 00 00 00 | ........d.3.....
0000:0020 | 04 00 01 00  00 64 00 00  00 01 00 64  00 5F 14 00 | .....d.....d._..
0000:0030 | 00 00 00 04  00 01 00 00  64 00 00 00  01 00 64 00 | ........d.....d.
0000:0040 | 8B 15 00 00  00 00 04 00  01 00 00 64  00 00 00 01 | ...........d....
0000:0050 | 00 64 00 B7  16 00 00 00  00 04 00 01  00 00 64 00 | .d.·..........d.
0000:0060 | 00 00 01 00  64 00 E3 17  00 00 00 00  04 00 01 00 | ....d.ã.........
0000:0070 | 00 64 00 00  00 01 00 64  00 0F 19 00  00 00 00 04 | .d.....d........
0000:0080 | 00 01 00 00  64 00 00 00  01 00 64 00  3B 1A 00 00 | ....d.....d.;...
0000:0090 | 00 00 04 00  01 00 00 64  00 00 00 01  00 64 00 67 | .......d.....d.g
0000:00A0 | 1B 00 00 00  00 04 00 01  00 00 64 00  00 00 01 00 | ..........d.....
0000:00B0 | 64 00 93 1C  00 00 00 00  04 00 01 00  00 64 00 00 | d............d..
0000:00C0 | 00 01 00 64  00 BF 1D 00  00 00 00 04  00 01 00 00 | ...d.¿..........
0000:00D0 | 64 00 00 00  01 00 64 00  EB 1E 00 00  00 00 04 00 | d.....d.ë.......
0000:00E0 | 01 00 00 64  00 00 00 01  00 64 00 17  20 00 00 00 | ...d.....d.. ...
0000:00F0 | 00 04 00 01  00 00 64 00  00 00 01 00  64 00 43 21 | ......d.....d.C!
0000:0100 | 00 00 00 00  04 00 01 00  00 64 00 00  00 01 00 64 | .........d.....d
```
*   `0x10-0x13` (Pointer1): `15 13 00 00` (`0x1315` = 4885). Formula `21 + 19*(257-1) = 21 + 19*256 = 21 + 4864 = 4885`. Matches N=257.
*   `0x14-0x15` (Segment Count N): `01 01` (`0x0101` = 257). Matches N=257.
*   `0x1A-0x1B` (RGB Data Start Offset): `33 13` (`0x1333` = 4915). Formula `32 + 257*19 = 32 + 4883 = 4915`. Matches N=257.

#### N258_.1s_1000r.prg (Actual N=258, Dur0Units_actual=100)
**Note:** Filename has been corrected to match actual segment count. Header fields consistently point to N=258.
*Actual Hex (first 256 bytes):*
```
0000:0000 | 50 52 03 49  4E 05 00 00  00 04 00 08  E8 03 50 49 | PR.IN.......è.PI
0000:0010 | 28 13 00 00  02 01 01 00  64 00 46 13  00 00 00 00 | (.......d.F.....
0000:0020 | 04 00 01 00  00 64 00 00  00 01 00 64  00 72 14 00 | .....d.....d.r..
0000:0030 | 00 00 00 04  00 01 00 00  64 00 00 00  01 00 64 00 | ........d.....d.
0000:0040 | 9E 15 00 00  00 00 04 00  01 00 00 64  00 00 00 01 | ...........d....
0000:0050 | 00 64 00 CA  16 00 00 00  00 04 00 01  00 00 64 00 | .d.Ê..........d.
0000:0060 | 00 00 01 00  64 00 F6 17  00 00 00 00  04 00 01 00 | ....d.ö.........
0000:0070 | 00 64 00 00  00 01 00 64  00 22 19 00  00 00 00 04 | .d.....d."......
0000:0080 | 00 01 00 00  64 00 00 00  01 00 64 00  4E 1A 00 00 | ....d.....d.N...
0000:0090 | 00 00 04 00  01 00 00 64  00 00 00 01  00 64 00 7A | .......d.....d.z
0000:00A0 | 1B 00 00 00  00 04 00 01  00 00 64 00  00 00 01 00 | ..........d.....
0000:00B0 | 64 00 A6 1C  00 00 00 00  04 00 01 00  00 64 00 00 | d.¦..........d..
0000:00C0 | 00 01 00 64  00 D2 1D 00  00 00 00 04  00 01 00 00 | ...d.Ò..........
0000:00D0 | 64 00 00 00  01 00 64 00  FE 1E 00 00  00 00 04 00 | d.....d.þ.......
0000:00E0 | 01 00 00 64  00 00 00 01  00 64 00 2A  20 00 00 00 | ...d.....d.* ...
0000:00F0 | 00 04 00 01  00 00 64 00  00 00 01 00  64 00 56 21 | ......d.....d.V!
0000:0100 | 00 00 00 00  04 00 01 00  00 64 00 00  00 01 00 64 | .........d.....d
```
*Additional hex dump for official `N258_.1s_1000r.prg` (offsets `0x0470-0x04F0`):*
```
0000:0470 | 01 00 00 64  00 00 00 00  00 64 00 6A  58 00 00 5F | ...d.....d.jX.._
0000:0480 | 00 04 00 01  00 00 5F 00  00 00 01 00  64 00 96 59 | ......_.....d..Y
0000:0490 | 00 00 00 00  04 00 01 00  00 64 00 00  00 01 00 64 | .........d.....d
0000:04A0 | 00 C2 5A 00  00 00 00 04  00 01 00 00  64 00 00 00 | .ÂZ.........d...
0000:04B0 | 01 00 64 00  EE 5B 00 00  00 00 04 00  01 00 00 64 | ..d.î[.........d
0000:04C0 | 00 00 00 00  00 64 00 1A  5D 00 00 55  00 04 00 01 | .....d..]..U....
0000:04D0 | 00 00 55 00  00 00 01 00  64 00 46 5E  00 00 00 00 | ..U.....d.F^....
0000:04E0 | 04 00 01 00  00 64 00 00  00 01 00 64  00 72 5F 00 | .....d.....d.r_.
0000:04F0 | 00 00 00 04  00 01 00 00  64 00 00 00  01 00 64 00 | ........d.....d.
```
*   `0x10-0x13` (Pointer1): `28 13 00 00` (`0x1328` = 4904). Formula `21 + 19*(258-1) = 21 + 19*257 = 21 + 4883 = 4904`. Matches N=258.
*   `0x14-0x15` (Segment Count N): `02 01` (`0x0102` = 258). Matches N=258.
*   `0x1A-0x1B` (RGB Data Start Offset): `46 13` (`0x1346` = 4934). Formula `32 + 258*19 = 32 + 4902 = 4934`. Matches N=258.
*   Duration Block Analysis (e.g., First block at `0x0020` for Segment 0, Second block at `0x0033` for Segment 1):
*   `+0x05` Current Segment Duration is `64 00` (100 units) for all segments.
*   `+0x09` (Field `+0x09`):
    *   For Block 0 (idx=0): `01 00 64 00` (`field_09_part1=1`, `field_09_part2=100`). `part1` is `idx+1`.
    *   For Block 1 (idx=1, CurrentDur=100, PrevDur=100): `01 00 64 00` (`field_09_part1=1`, `field_09_part2=100`). `part1` is `1` because durations are equal. This supports "Hypothesis I" for `field_09_part1`.
*   `+0x11` Next Segment Info (Dur of next segment): `00 00` (0 units) for initial blocks when the next segment's duration is 100ms. This supports the re-confirmed "Hypothesis F" (where `Field+0x11 = 0` if `Dur_k+1 == 100`).
    *   **Further Analysis & Exceptions for N=258 (Official App):**
        *   **Segment Duration Change:** Segment 59 (idx=59) has an actual duration of 95ms (`5F 00` at offset `0x0486`) in the official PRG, deviating from an input of 100ms.
        *   **Block 58 (idx=58):**
            *   `+0x09` (`field_09_part1`, at `0x477`): Official is `00 00` (0). Current Hypothesis I (`1`) is incorrect here.
            *   `+0x11` (NextSegInfo for Seg 59, at `0x47F`): Official is `5F 00` (95). This matches the altered duration of Seg 59 (95ms), so Hypothesis F (`value = Dur_k+1` if `Dur_k+1 < 100`) correctly predicts this *if* it knows Seg 59's duration is 95.
        *   **Block 62 (idx=62):**
            *   `+0x09` (`field_09_part1`, at `0x04BA+9=0x04C3`): Official is `00 00` (0). Current Hypothesis I (`1`) is incorrect here.
            *   `+0x11` (NextSegInfo for Seg 63, at `0x04BA+17=0x04CB`): Official is `55 00` (85). Assuming Seg 63 intended duration is 100ms, Hypothesis F (`0`) is incorrect.
        *   These discrepancies indicate highly specific behavior for N=258 around these indices, not covered by current general hypotheses.
    *   **Additional Discrepancies for N=258 (Official App, from `0x0D60` onwards as provided 2025-06-01):**
        *   Hex dump section for official `N258_.1s_1000r.prg` starting `0x0D60`:
        ```
        0000:0D60 | 00 64 00 0A  E5 00 00 00  00 04 00 01  00 00 64 00 | .d..å.........d.
        0000:0D70 | 00 00 01 00  64 00 36 E6  00 00 03 00  04 00 01 00 | ....d.6æ........
        0000:0D80 | 00 67 00 00  00 01 00 64  00 62 E7 00  00 00 00 04 | .g.....d.bç.....
        0000:0D90 | 00 01 00 00  64 00 00 00  01 00 64 00  8E E8 00 00 | ....d.....d..è..
        0000:0DA0 | 00 00 04 00  01 00 00 64  00 00 00 01  00 64 00 BA | .......d.....d.º
        0000:0DB0 | E9 00 00 00  00 04 00 01  00 00 64 00  00 00 01 00 | é.........d.....
        0000:0DC0 | 64 00 E6 EA  00 00 00 00  04 00 01 00  00 64 00 00 | d.æê.........d..
        0000:0DD0 | 00 01 00 64  00 12 EC 00  00 00 00 04  00 01 00 00 | ...d..ì.........
        0000:0DE0 | 64 00 00 00  01 00 64 00  3E ED 00 00  00 00 04 00 | d.....d.>í......
        0000:0DF0 | 01 00 00 64  00 00 00 01  00 64 00 6A  EE 00 00 00 | ...d.....d.jî...
        0000:0E00 | 00 04 00 01  00 00 64 00  00 00 01 00  64 00 96 EF | ......d.....d..ï
        0000:0E10 | 00 00 00 00  04 00 01 00  00 64 00 00  00 01 00 64 | .........d.....d
        0000:0E20 | 00 C2 F0 00  00 00 00 04  00 01 00 00  64 00 00 00 | .Âð.........d...
        0000:0E30 | 01 00 64 00  EE F1 00 00  00 00 04 00  01 00 00 64 | ..d.îñ.........d
        0000:0E40 | 00 00 00 01  00 64 00 1A  F3 00 00 00  00 04 00 01 | .....d..ó.......
        0000:0E50 | 00 00 64 00  00 00 01 00  64 00 46 F4  00 00 00 00 | ..d.....d.Fô....
        0000:0E60 | 04 00 01 00  00 64 00 00  00 01 00 64  00 72 F5 00 | .....d.....d.rõ.
        0000:0E70 | 00 02 00 04  00 01 00 00  66 00 00 00  01 00 64 00 | ........f.....d.
        ```
        *   **Block 179 (idx=179, starts `0xD69`):** `Field +0x11` (NextSegInfo, at `0xD7A`) is `03 00` (value 3). Current Hypothesis F for `Field +0x11` would predict `0` if Seg 180's duration is 100ms.
        *   **Segment 180 (idx=180, its block starts `0xD7C`):** Its own duration (`+0x05` field, at `0xD81`) is `67 00` (103ms). The input JSON implies 100ms.
        *   **Block 192 (idx=192, its block starts `0xE6D`):**
            *   Its own duration (`+0x05` field, at `0xE78`) is `66 00` (102ms). The input JSON implies 100ms.
            *   `field_09_part1` (`+0x09` field LSBs, at `0xE76`) is `02 00` (value 2). Current Hypothesis I for `field_09_part1` would predict `1` (if previous segment had same duration) or `193` (if different).
        *   These observations further confirm that the official app's generation logic for `N=258` includes dynamic adjustments to segment durations and related duration block fields that are not yet captured by our general hypotheses or current patches.


#### N259_.1s_1000r.prg (Actual N=259, Dur0Units_actual=100, Official App)
*Actual Hex (first 256 bytes, from Official App):*
```
0000:0000 | 50 52 03 49  4E 05 00 00  00 04 00 08  E8 03 50 49 | PR.IN.......è.PI
0000:0010 | 3B 13 00 00  03 01 01 00  64 00 59 13  00 00 00 00 | ;.......d.Y.....
0000:0020 | 04 00 01 00  00 64 00 00  00 01 00 64  00 85 14 00 | .....d.....d....
0000:0030 | 00 00 00 04  00 01 00 00  64 00 00 00  01 00 64 00 | ........d.....d.
0000:0040 | B1 15 00 00  00 00 04 00  01 00 00 64  00 00 00 01 | ±..........d....
0000:0050 | 00 64 00 DD  16 00 00 00  00 04 00 01  00 00 64 00 | .d.Ý..........d.
0000:0060 | 00 00 01 00  64 00 09 18  00 00 00 00  04 00 01 00 | ....d...........
0000:0070 | 00 64 00 00  00 01 00 64  00 35 19 00  00 00 00 04 | .d.....d.5......
0000:0080 | 00 01 00 00  64 00 00 00  01 00 64 00  61 1A 00 00 | ....d.....d.a...
0000:0090 | 00 00 04 00  01 00 00 64  00 00 00 01  00 64 00 8D | .......d.....d..
0000:00A0 | 1B 00 00 00  00 04 00 01  00 00 64 00  00 00 01 00 | ..........d.....
0000:00B0 | 64 00 B9 1C  00 00 00 00  04 00 01 00  00 64 00 00 | d.¹..........d..
0000:00C0 | 00 01 00 64  00 E5 1D 00  00 00 00 04  00 01 00 00 | ...d.å..........
0000:00D0 | 64 00 00 00  01 00 64 00  11 1F 00 00  00 00 04 00 | d.....d.........
0000:00E0 | 01 00 00 64  00 00 00 01  00 64 00 3D  20 00 00 00 | ...d.....d.= ...
0000:00F0 | 00 04 00 01  00 00 64 00  00 00 01 00  64 00 69 21 | ......d.....d.i!
0000:0100 | 00 00 00 00  04 00 01 00  00 64 00 00  00 01 00 64 | .........d.....d
```
*   Header Analysis (all segments 0.1s = 100 units @ 1000Hz):
    *   `0x10-0x13` (Pointer1): `3B 13 00 00` (`0x133B` = 4923). Formula `21 + 19*(259-1) = 21 + 19*258 = 21 + 4902 = 4923`. Matches.
    *   `0x14-0x15` (Segment Count N): `03 01` (`0x0103` = 259). Matches.
    *   `0x16-0x17` (Field 0x16 from Dur0=100): `01 00` (Value 1). Matches Hypothesis 8.
    *   `0x1A-0x1B` (RGB Data Start Offset): `59 13` (`0x1359` = 4953). Formula `32 + 259*19 = 32 + 4921 = 4953`. Matches.
    *   `0x1E-0x1F` (Field 0x1E from Dur0=100): `00 00` (Value 0). Matches Hypothesis 8.
*   Duration Block Analysis (e.g., First block at `0x0020` for Segment 0, Second block at `0x0033` for Segment 1):
    *   `+0x00` Pixel Count: `04 00` (4 pixels).
    *   `+0x05` Current Segment Duration is `64 00` (100 units) for all segments.
    *   `+0x09` (Field `+0x09`):
        *   For Block 0 (idx=0): `01 00 64 00` (`field_09_part1=1`, `field_09_part2=100`). `part1` is `idx+1`.
        *   For Block 1 (idx=1, CurrentDur=100, PrevDur=100): `01 00 64 00` (`field_09_part1=1`, `field_09_part2=100`). `part1` is `1` because durations are equal. This supports "Hypothesis I" for `field_09_part1`.
    *   `+0x11` Next Segment Info (Dur of next segment): `00 00` (0 units) for initial blocks when the next segment's duration is 100ms. This supports the re-confirmed "Hypothesis F" (where `Field+0x11 = 0` if `Dur_k+1 == 100`).
*   Observation: This official app file appears to contain 259 segments, each 100 units (100ms) long, without inserted black gaps.

## Field[+0x09] and Field[+0x11] Investigation (1000Hz Refresh Rate)

**Date:** 2025-06-02

The following tests were conducted using the official LTX app with a PRG refresh rate of 1000Hz (1 unit = 1ms) to understand the dynamic behavior of `Field[+0x09]` (specifically `field_09_part1` and `field_09_part2`) and `Field[+0x11]` within the intermediate duration blocks. All PRG hex dumps are truncated.

### Test A: N=3 segments. Durations: 1240, 470, 1930 units

*Input Durations:*
*   Segment 0: 1240 units
*   Segment 1: 470 units
*   Segment 2: 1930 units

*Hex Dump (TestA.prg):*
```
0000:0000 | 50 52 03 49  4E 05 00 00  00 04 00 08  E8 03 50 49 | PR.IN.......è.PI
0000:0010 | 3B 00 00 00  03 00 0C 00  64 00 59 00  00 00 28 00 | ;.......d.Y...(.
0000:0020 | 04 00 01 00  00 D8 04 00  00 04 00 64  00 85 01 00 | .....Ø.....d....
0000:0030 | 00 46 00 04  00 01 00 00  D6 01 00 00  13 00 64 00 | .F......Ö.....d.
0000:0040 | B1 02 00 00  1E 00 04 00  01 00 00 8A  07 00 00 43 | ±..............C
0000:0050 | 44 88 03 00  00 2C 01 00  00 FF 00 00  FF 00 00 FF | D....,...ÿ..ÿ..ÿ
```

*Header Analysis (Offsets `0x16`, `0x1E`):*
*   `Dur0Units_actual` = 1240
*   Field `0x16`: `0C 00` (12). `floor(1240 / 100) = 12`. Matches.
*   Field `0x1E`: `28 00` (40). `1240 % 100 = 40`. Matches (using simplified rule `Dur0 % 100`).

*Duration Block Analysis:*
*   **Block 0 (Segment 0, offset `0x20`):**
    *   `+0x05` CurrentSegmentDurationUnits: `D8 04` (1240). Correct.
    *   `+0x09` Field[+0x09]: `04 00 64 00` -> `field_09_part1 = 4`, `field_09_part2 = 100`.
    *   `+0x11` NextSegmentInfo (for Dur_1=470): `D6 01` (470). Hypothesis F: `Dur_k+1`(470) > 100, `Dur_k`(1240) != 100 -> val=470. Matches.
*   **Block 1 (Segment 1, offset `0x33`):**
    *   `+0x05` CurrentSegmentDurationUnits: `D6 01` (470). Correct.
    *   `+0x09` Field[+0x09]: `13 00 64 00` -> `field_09_part1 = 19`, `field_09_part2 = 100`.
        *   Observation: `field_09_part2` is 100, despite `CurrentSegmentDurationUnits` being 470.
    *   `+0x11` NextSegmentInfo (for Dur_2=1930): `1E 00` (30). **DISCREPANCY.** Expected 1930 (`8A 07`) by Hypothesis F. Actual dump shows 30.
*   **Block 2 (Segment 2, Last Block, offset `0x46`):**
    *   `+0x05` CurrentSegmentDurationUnits: `8A 07` (1930). Correct.
    *   `+0x09` Field[+0x09]: `43 44` ('CD'). Standard for last block.

### Test B: N=3 segments. Durations: 500, 80, 500 units

*Input Durations:*
*   Segment 0: 500 units
*   Segment 1: 80 units
*   Segment 2: 500 units

*Hex Dump (TestB.prg):*
```
0000:0000 | 50 52 03 49  4E 05 00 00  00 04 00 08  E8 03 50 49
0000:0010 | 3B 00 00 00  03 00 05 00  64 00 59 00  00 00 00 00
0000:0020 | 04 00 01 00  00 F4 01 00  00 00 00 64  00 85 01 00
0000:0030 | 00 50 00 04  00 01 00 00  50 00 00 00  05 00 64 00
0000:0040 | B1 02 00 00  00 00 04 00  01 00 00 F4  01 00 00 43
0000:0050 | 44 88 03 00  00 2C 01 00  00 FF 00 00  FF 00 00 FF
```

*Header Analysis (Offsets `0x16`, `0x1E`):*
*   `Dur0Units_actual` = 500
*   Field `0x16`: `05 00` (5). `floor(500 / 100) = 5`. Matches.
*   Field `0x1E`: `00 00` (0). `500 % 100 = 0`. Matches (using simplified rule `Dur0 % 100`).

*Duration Block Analysis:*
*   **Block 0 (Segment 0, offset `0x20`):**
    *   `+0x05` CurrentSegmentDurationUnits: `F4 01` (500). Correct.
    *   `+0x09` Field[+0x09]: `00 00 64 00` -> `field_09_part1 = 0`, `field_09_part2 = 100`.
    *   `+0x11` NextSegmentInfo (for Dur_1=80): `50 00` (80). Hypothesis F: `Dur_k+1`(80) < 100 -> val=80. Matches.
*   **Block 1 (Segment 1, offset `0x33`):**
    *   `+0x05` CurrentSegmentDurationUnits: `50 00` (80). Correct.
    *   `+0x09` Field[+0x09]: `05 00 64 00` -> `field_09_part1 = 5`, `field_09_part2 = 100`.
        *   Observation: `field_09_part2` is 100, despite `CurrentSegmentDurationUnits` (80) < 100.
    *   `+0x11` NextSegmentInfo (for Dur_2=500): `F4 01` (500). Hypothesis F: `Dur_k+1`(500) > 100, `Dur_k`(80) != 100 -> val=500. Matches.
*   **Block 2 (Segment 2, Last Block, offset `0x46`):**
    *   `+0x05` CurrentSegmentDurationUnits: `F4 01` (500). Correct.
    *   `+0x09` Field[+0x09]: `43 44` ('CD'). Standard for last block.

### Test C: N=3 segments. Durations: 500, 120, 500 units

*Input Durations:*
*   Segment 0: 500 units
*   Segment 1: 120 units
*   Segment 2: 500 units

*Hex Dump (TestC.prg):*
```
0000:0000 | 50 52 03 49  4E 05 00 00  00 04 00 08  E8 03 50 49
0000:0010 | 3B 00 00 00  03 00 05 00  64 00 59 00  00 00 00 00
0000:0020 | 04 00 01 00  00 F4 01 00  00 01 00 64  00 85 01 00
0000:0030 | 00 14 00 04  00 01 00 00  78 00 00 00  05 00 64 00
0000:0040 | B1 02 00 00  00 00 04 00  01 00 00 F4  01 00 00 43
0000:0050 | 44 88 03 00  00 2C 01 00  00 FF 00 00  FF 00 00 FF
```

*Header Analysis (Offsets `0x16`, `0x1E`):*
*   `Dur0Units_actual` = 500
*   Field `0x16`: `05 00` (5). `floor(500 / 100) = 5`. Matches.
*   Field `0x1E`: `00 00` (0). `500 % 100 = 0`. Matches (using simplified rule `Dur0 % 100`).

*Duration Block Analysis:*
*   **Block 0 (Segment 0, offset `0x20`):**
    *   `+0x05` CurrentSegmentDurationUnits: `F4 01` (500). Correct.
    *   `+0x09` Field[+0x09]: `01 00 64 00` -> `field_09_part1 = 1`, `field_09_part2 = 100`.
    *   `+0x11` NextSegmentInfo (for Dur_1=120): `78 00` (120). Hypothesis F: `Dur_k+1`(120) > 100, `Dur_k`(500) != 100 -> val=120. Matches.
*   **Block 1 (Segment 1, offset `0x33`):**
    *   `+0x05` CurrentSegmentDurationUnits: `78 00` (120). Correct.
    *   `+0x09` Field[+0x09]: `05 00 64 00` -> `field_09_part1 = 5`, `field_09_part2 = 100`.
        *   Observation: `field_09_part2` is 100, despite `CurrentSegmentDurationUnits` (120) > 100.
    *   `+0x11` NextSegmentInfo (for Dur_2=500): `F4 01` (500). Hypothesis F: `Dur_k+1`(500) > 100, `Dur_k`(120) != 100 -> val=500. Matches.
*   **Block 2 (Segment 2, Last Block, offset `0x46`):**
    *   `+0x05` CurrentSegmentDurationUnits: `F4 01` (500). Correct.
    *   `+0x09` Field[+0x09]: `43 44` ('CD'). Standard for last block.
## Deduced Logic for Header Fields 0x16 and 0x1E (Hypothesis 8 - Current Best as of 2025-06-01 10:25)

This logic applies universally across different PRG refresh rates and segment counts, based on all provided official app samples.

It's also important to note the structure of certain fields within **Intermediate Duration Blocks** (i.e., not the last duration block):

*   **Field `+0x09` (Segment Index & Duration) (Revised 2025-06-01):**
    This 4-byte field consists of two 2-byte Little Endian values:
    1.  `field_09_part1`:
        *   If it's the first duration block (`current_block_index == 0`): This is `1` (`01 00`).
        *   If `current_block_index > 0` AND `CurrentSegmentDurationUnits == PreviousSegmentDurationUnits`: This value is `CurrentSegmentDurationUnits`.
        *   Else (`current_block_index > 0` AND `CurrentSegmentDurationUnits != PreviousSegmentDurationUnits`): This value is `current_block_index + 1`.
    2.  `field_09_part2`: This is always `CurrentSegmentDurationUnits`.

*   **Field `+0x11` (Next Segment Info) (Revised 2025-06-01):**
    Let `Dur_k` be current segment's duration, `Dur_k+1` be next segment's duration.
    1.  If `Dur_k+1 < 100`: value is `Dur_k+1`.
### Test D: N=4 segments. All durations: 75 units

*Input Durations:* 75, 75, 75, 75 units.

*Hex Dump (TestD.prg):*
```
0000:0000 | 50 52 03 49  4E 05 00 00  00 04 00 08  E8 03 50 49 | PR.IN.......è.PI
0000:0010 | 4E 00 00 00  04 00 00 00  64 00 6C 00  00 00 4B 00 | N.......d.l...K.
0000:0020 | 04 00 01 00  00 4B 00 00  00 00 00 64  00 98 01 00 | .....K.....d....
0000:0030 | 00 4B 00 04  00 01 00 00  4B 00 00 00  00 00 64 00 | .K......K.....d.
0000:0040 | C4 02 00 00  4B 00 04 00  01 00 00 4B  00 00 00 00 | Ä...K......K....
0000:0050 | 00 64 00 F0  03 00 00 4B  00 04 00 01  00 00 4B 00 | .d.ð...K......K.
0000:0060 | 00 00 43 44  B4 04 00 00  90 01 00 00  FF 00 00 FF | ..CD´.......ÿ..ÿ
```

*Header Analysis (Offsets `0x16`, `0x1E`):*
*   `Dur0Units_actual` = 75
*   Field `0x16`: `00 00` (0). `floor(75/100)=0`. Matches.
*   Field `0x1E`: `4B 00` (75). `75 % 100 = 75`. Matches simplified rule.

*Duration Block Analysis (all segments 75 units):*
*   **Block 0 (Seg 0, offset `0x20`):** Dur=75. `Field[+0x09]`: `00 00 64 00` (`part1=0`, `part2=100`). `Field[+0x11]` (for Dur_1=75): `4B 00` (75). Matches HypF.
*   **Block 1 (Seg 1, offset `0x33`):** Dur=75. `Field[+0x09]`: `00 00 64 00` (`part1=0`, `part2=100`). `Field[+0x11]` (for Dur_2=75): `4B 00` (75). Matches HypF.
*   **Block 2 (Seg 2, offset `0x46`):** Dur=75. `Field[+0x09]`: `00 00 64 00` (`part1=0`, `part2=100`). `Field[+0x11]` (for Dur_3=75): `4B 00` (75). Matches HypF.
*   **Block 3 (Seg 3, Last Block, offset `0x59`):** Dur=75. `Field[+0x09]`: `43 44`. Standard.

### Test E: N=4 segments. All durations: 100 units

*Input Durations:* 100, 100, 100, 100 units.

*Hex Dump (TestE.prg):*
```
0000:0000 | 50 52 03 49  4E 05 00 00  00 04 00 08  E8 03 50 49
0000:0010 | 4E 00 00 00  04 00 01 00  64 00 6C 00  00 00 00 00
0000:0020 | 04 00 01 00  00 64 00 00  00 01 00 64  00 98 01 00
0000:0030 | 00 00 00 04  00 01 00 00  64 00 00 00  01 00 64 00
0000:0040 | C4 02 00 00  00 00 04 00  01 00 00 64  00 00 00 01
0000:0050 | 00 64 00 F0  03 00 00 00  00 04 00 01  00 00 64 00
0000:0060 | 00 00 43 44  B4 04 00 00  90 01 00 00  FF 00 00 FF
```

*Header Analysis (Offsets `0x16`, `0x1E`):*
*   `Dur0Units_actual` = 100
*   Field `0x16`: `01 00` (1). `floor(100/100)=1`. Matches.
*   Field `0x1E`: `00 00` (0). `100 % 100 = 0`. Matches simplified rule.

*Duration Block Analysis (all segments 100 units):*
*   **Block 0 (Seg 0, offset `0x20`):** Dur=100. `Field[+0x09]`: `01 00 64 00` (`part1=1`, `part2=100`). `Field[+0x11]` (for Dur_1=100): `00 00` (0). Matches HypF.
*   **Block 1 (Seg 1, offset `0x33`):** Dur=100. `Field[+0x09]`: `01 00 64 00` (`part1=1`, `part2=100`). `Field[+0x11]` (for Dur_2=100): `00 00` (0). Matches HypF.
*   **Block 2 (Seg 2, offset `0x46`):** Dur=100. `Field[+0x09]`: `01 00 64 00` (`part1=1`, `part2=100`). `Field[+0x11]` (for Dur_3=100): `00 00` (0). Matches HypF.
*   **Block 3 (Seg 3, Last Block, offset `0x59`):** Dur=100. `Field[+0x09]`: `43 44`. Standard.

### Test F: N=4 segments. Alternating durations: 70, 120, 70, 120 units

*Input Durations:* 70, 120, 70, 120 units.

*Hex Dump (TestF.prg):*
```
0000:0000 | 50 52 03 49  4E 05 00 00  00 04 00 08  E8 03 50 49
0000:0010 | 4E 00 00 00  04 00 00 00  64 00 6C 00  00 00 46 00
0000:0020 | 04 00 01 00  00 46 00 00  00 01 00 64  00 98 01 00
0000:0030 | 00 14 00 04  00 01 00 00  78 00 00 00  00 00 64 00
0000:0040 | C4 02 00 00  46 00 04 00  01 00 00 46  00 00 00 01
0000:0050 | 00 64 00 F0  03 00 00 14  00 04 00 01  00 00 78 00
0000:0060 | 00 00 43 44  B4 04 00 00  90 01 00 00  FF 00 00 FF
```

*Header Analysis (Offsets `0x16`, `0x1E`):*
*   `Dur0Units_actual` = 70
*   Field `0x16`: `00 00` (0). `floor(70/100)=0`. Matches.
*   Field `0x1E`: `46 00` (70). `70 % 100 = 70`. Matches simplified rule.

*Duration Block Analysis:*
*   **Block 0 (Seg 0, Dur=70, offset `0x20`):** `Field[+0x09]`: `01 00 64 00` (`part1=1`, `part2=100`). `Field[+0x11]` (for Dur_1=120): `78 00` (120). Matches HypF.
*   **Block 1 (Seg 1, Dur=120, offset `0x33`):** `Field[+0x09]`: `00 00 64 00` (`part1=0`, `part2=100`). `Field[+0x11]` (for Dur_2=70): `46 00` (70). Matches HypF.
*   **Block 2 (Seg 2, Dur=70, offset `0x46`):** `Field[+0x09]`: `01 00 64 00` (`part1=1`, `part2=100`). `Field[+0x11]` (for Dur_3=120): `78 00` (120). Matches HypF.
*   **Block 3 (Seg 3, Dur=120, Last Block, offset `0x59`):** `Field[+0x09]`: `43 44`. Standard.

### Test G: N=5 segments. Durations: 70, 70, 120, 120, 70 units

*Input Durations:* 70, 70, 120, 120, 70 units.

*Hex Dump (TestG.prg):*
```
0000:0000 | 50 52 03 49  4E 05 00 00  00 04 00 08  E8 03 50 49
0000:0010 | 61 00 00 00  05 00 00 00  64 00 7F 00  00 00 46 00
0000:0020 | 04 00 01 00  00 46 00 00  00 00 00 64  00 AB 01 00
0000:0030 | 00 46 00 04  00 01 00 00  46 00 00 00  01 00 64 00
0000:0040 | D7 02 00 00  14 00 04 00  01 00 00 78  00 00 00 01
0000:0050 | 00 64 00 03  04 00 00 14  00 04 00 01  00 00 78 00
0000:0060 | 00 00 00 00  64 00 2F 05  00 00 46 00  04 00 01 00
0000:0070 | 00 46 00 00  00 43 44 E0  05 00 00 F4  01 00 00 FF
```

*Header Analysis (Offsets `0x16`, `0x1E`):*
*   `Dur0Units_actual` = 70
*   Field `0x16`: `00 00` (0). `floor(70/100)=0`. Matches.
*   Field `0x1E`: `46 00` (70). `70 % 100 = 70`. Matches simplified rule.

*Duration Block Analysis:*
*   **Block 0 (Seg 0, Dur=70, offset `0x20`):** `Field[+0x09]`: `00 00 64 00` (`part1=0`, `part2=100`). `Field[+0x11]` (for Dur_1=70): `46 00` (70). Matches HypF.
*   **Block 1 (Seg 1, Dur=70, offset `0x33`):** `Field[+0x09]`: `01 00 64 00` (`part1=1`, `part2=100`). `Field[+0x11]` (for Dur_2=120): `78 00` (120). Matches HypF.
*   **Block 2 (Seg 2, Dur=120, offset `0x46`):** `Field[+0x09]`: `01 00 64 00` (`part1=1`, `part2=100`). `Field[+0x11]` (for Dur_3=120): `78 00` (120). Matches HypF.
*   **Block 3 (Seg 3, Dur=120, offset `0x59`):** `Field[+0x09]`: `00 00 64 00` (`part1=0`, `part2=100`). `Field[+0x11]` (for Dur_4=70): `46 00` (70). Matches HypF.
*   **Block 4 (Seg 4, Dur=70, Last Block, offset `0x6C`):** `Field[+0x09]`: `43 44`. Standard.

---

## Further Field[+0x09] and Field[+0x11] Investigation - H & J Series (1000Hz)

**Date:** 2025-06-02 (following analysis of Tests A-G)

These tests further probe `Field[+0x09].part1` and the `Field[+0x11]` anomaly using N=3 segments at 1000Hz.

### Test H1: N=3 segments. Durations: 50, 50, 50 units

*Hex Dump (H1.prg):*
```
0000:0000 | 50 52 03 49  4E 05 00 00  00 04 00 08  E8 03 50 49
0000:0010 | 3B 00 00 00  03 00 00 00  64 00 59 00  00 00 32 00
0000:0020 | 04 00 01 00  00 32 00 00  00 00 00 64  00 85 01 00
0000:0030 | 00 32 00 04  00 01 00 00  32 00 00 00  00 00 64 00
0000:0040 | B1 02 00 00  32 00 04 00  01 00 00 32  00 00 00 43
0000:0050 | 44 88 03 00  00 2C 01 00  00 FF 00 00  FF 00 00 FF
```
*Header (Dur0=50):* `0x16=0000` (0), `0x1E=3200` (50). Matches.
*Block 0 (Dur=50):* `+0x09=00006400` (p1=0, p2=100). `+0x11` (for Dur1=50) = `3200` (50). Matches HypF.
*Block 1 (Dur=50):* `+0x09=00006400` (p1=0, p2=100). `+0x11` (for Dur2=50) = `3200` (50). Matches HypF.
*Block 2 (Dur=50, Last):* Standard.

### Test H2: N=3 segments. Durations: 150, 150, 150 units

*Hex Dump (H2.prg):*
```
0000:0000 | 50 52 03 49  4E 05 00 00  00 04 00 08  E8 03 50 49
0000:0010 | 3B 00 00 00  03 00 01 00  64 00 59 00  00 00 32 00
0000:0020 | 04 00 01 00  00 96 00 00  00 01 00 64  00 85 01 00
0000:0030 | 00 32 00 04  00 01 00 00  96 00 00 00  01 00 64 00
0000:0040 | B1 02 00 00  32 00 04 00  01 00 00 96  00 00 00 43
0000:0050 | 44 88 03 00  00 2C 01 00  00 FF 00 00  FF 00 00 FF
```
*Header (Dur0=150):* `0x16=0100` (1), `0x1E=3200` (50). Matches.
*Block 0 (Dur=150):* `+0x09=01006400` (p1=1, p2=100). `+0x11` (for Dur1=150) = `9600` (150). Matches HypF.
*Block 1 (Dur=150):* `+0x09=01006400` (p1=1, p2=100). `+0x11` (for Dur2=150) = `9600` (150). Matches HypF.
*Block 2 (Dur=150, Last):* Standard.

### Test H3: N=3 segments. Durations: 50, 100, 150 units

*Hex Dump (H3.prg):*
```
0000:0000 | 50 52 03 49  4E 05 00 00  00 04 00 08  E8 03 50 49
0000:0010 | 3B 00 00 00  03 00 00 00  64 00 59 00  00 00 32 00
0000:0020 | 04 00 01 00  00 32 00 00  00 01 00 64  00 85 01 00
0000:0030 | 00 00 00 04  00 01 00 00  64 00 00 00  01 00 64 00
0000:0040 | B1 02 00 00  32 00 04 00  01 00 00 96  00 00 00 43
0000:0050 | 44 88 03 00  00 2C 01 00  00 FF 00 00  FF 00 00 FF
```
*Header (Dur0=50):* `0x16=0000` (0), `0x1E=3200` (50). Matches.
*Block 0 (Dur=50):* `+0x09=01006400` (p1=1, p2=100). `+0x11` (for Dur1=100) = `0000` (0). Matches HypF.
*Block 1 (Dur=100):* `+0x09=01006400` (p1=1, p2=100). `+0x11` (for Dur2=150) = `9600` (150). **DISCREPANCY** with refined HypF rule 3.a (expected 0 if Dur_k=100).
*Block 2 (Dur=150, Last):* Standard.

### Test H4: N=3 segments. Durations: 150, 100, 50 units

*Hex Dump (H4.prg):*
```
0000:0000 | 50 52 03 49  4E 05 00 00  00 04 00 08  E8 03 50 49
0000:0010 | 3B 00 00 00  03 00 01 00  64 00 59 00  00 00 32 00
0000:0020 | 04 00 01 00  00 96 00 00  00 01 00 64  00 85 01 00
0000:0030 | 00 00 00 04  00 01 00 00  64 00 00 00  00 00 64 00
0000:0040 | B1 02 00 00  32 00 04 00  01 00 00 32  00 00 00 43
0000:0050 | 44 88 03 00  00 2C 01 00  00 FF 00 00  FF 00 00 FF
```
*Header (Dur0=150):* `0x16=0100` (1), `0x1E=3200` (50). Matches.
*Block 0 (Dur=150):* `+0x09=01006400` (p1=1, p2=100). `+0x11` (for Dur1=100) = `0000` (0). Matches HypF.
*Block 1 (Dur=100):* `+0x09=00006400` (p1=0, p2=100). `+0x11` (for Dur2=50) = `3200` (50). Matches HypF.
*Block 2 (Dur=50, Last):* Standard.

### Test H5: N=3 segments. Durations: 80, 120, 80 units

*Hex Dump (H5.prg):*
```
0000:0000 | 50 52 03 49  4E 05 00 00  00 04 00 08  E8 03 50 49
0000:0010 | 3B 00 00 00  03 00 00 00  64 00 59 00  00 00 50 00
0000:0020 | 04 00 01 00  00 50 00 00  00 01 00 64  00 85 01 00
0000:0030 | 00 14 00 04  00 01 00 00  78 00 00 00  00 00 64 00
0000:0040 | B1 02 00 00  50 00 04 00  01 00 00 50  00 00 00 43
0000:0050 | 44 88 03 00  00 2C 01 00  00 FF 00 00  FF 00 00 FF
```
*Header (Dur0=80):* `0x16=0000` (0), `0x1E=5000` (80). Matches.
*Block 0 (Dur=80):* `+0x09=01006400` (p1=1, p2=100). `+0x11` (for Dur1=120) = `7800` (120). Matches HypF.
*Block 1 (Dur=120):* `+0x09=00006400` (p1=0, p2=100). `+0x11` (for Dur2=80) = `5000` (80). Matches HypF.
*Block 2 (Dur=80, Last):* Standard.

### Test J1: N=3 segments. Durations: 1240, 470, 1930 units (Repeat of Test A)

*Hex Dump (J1.prg - identical to TestA.prg):*
```
0000:0000 | 50 52 03 49  4E 05 00 00  00 04 00 08  E8 03 50 49
0000:0010 | 3B 00 00 00  03 00 0C 00  64 00 59 00  00 00 28 00
0000:0020 | 04 00 01 00  00 D8 04 00  00 04 00 64  00 85 01 00
0000:0030 | 00 46 00 04  00 01 00 00  D6 01 00 00  13 00 64 00
0000:0040 | B1 02 00 00  1E 00 04 00  01 00 00 8A  07 00 00 43
0000:0050 | 44 88 03 00  00 2C 01 00  00 FF 00 00  FF 00 00 FF
```
*Analysis:* Identical to Test A. Block 1 `+0x11` (for Dur2=1930) is `1E00` (30). Anomaly reproduced.

### Test J2: N=3 segments. Durations: 1240, 470, 1800 units

*Hex Dump (J2.prg):*
```
0000:0000 | 50 52 03 49  4E 05 00 00  00 04 00 08  E8 03 50 49
0000:0010 | 3B 00 00 00  03 00 0C 00  64 00 59 00  00 00 28 00
0000:0020 | 04 00 01 00  00 D8 04 00  00 04 00 64  00 85 01 00
0000:0030 | 00 46 00 04  00 01 00 00  D6 01 00 00  12 00 64 00
0000:0040 | B1 02 00 00  00 00 04 00  01 00 00 08  07 00 00 43
0000:0050 | 44 88 03 00  00 2C 01 00  00 FF 00 00  FF 00 00 FF
```
*Header (Dur0=1240):* Same as J1.
*Block 0 (Dur=1240):* `+0x09=04006400` (p1=4, p2=100). `+0x11` (for Dur1=470) = `D601` (470). Matches HypF.
*Block 1 (Dur=470):* `+0x09=12006400` (p1=18, p2=100). `+0x11` (for Dur2=1800) = `0807` (1800). **Matches HypF! Anomaly gone.**
*Block 2 (Dur=1800, Last):* Standard.

### Test J3: N=3 segments. Durations: 1240, 450, 1930 units

*Hex Dump (J3.prg):*
```
0000:0000 | 50 52 03 49  4E 05 00 00  00 04 00 08  E8 03 50 49
0000:0010 | 3B 00 00 00  03 00 0C 00  64 00 59 00  00 00 28 00
0000:0020 | 04 00 01 00  00 D8 04 00  00 04 00 64  00 85 01 00
0000:0030 | 00 32 00 04  00 01 00 00  C2 01 00 00  13 00 64 00
0000:0040 | B1 02 00 00  1E 00 04 00  01 00 00 8A  07 00 00 43
0000:0050 | 44 88 03 00  00 2C 01 00  00 FF 00 00  FF 00 00 FF
```
*Header (Dur0=1240):* Same as J1.
*Block 0 (Dur=1240):* `+0x09=04006400` (p1=4, p2=100). `+0x11` (for Dur1=450) = `C201` (450). Matches HypF.
*Block 1 (Dur=450):* `+0x09=13006400` (p1=19, p2=100). `+0x11` (for Dur2=1930) = `1E00` (30). **Anomaly persists.**
*Block 2 (Dur=1930, Last):* Standard.

### Test J4: N=3 segments. Durations: 1240, 500, 1930 units

*Hex Dump (J4.prg):*
```
0000:0000 | 50 52 03 49  4E 05 00 00  00 04 00 08  E8 03 50 49
0000:0010 | 3B 00 00 00  03 00 0C 00  64 00 59 00  00 00 28 00
0000:0020 | 04 00 01 00  00 D8 04 00  00 05 00 64  00 85 01 00
0000:0030 | 00 00 00 04  00 01 00 00  F4 01 00 00  13 00 64 00
0000:0040 | B1 02 00 00  1E 00 04 00  01 00 00 8A  07 00 00 43
0000:0050 | 44 88 03 00  00 2C 01 00  00 FF 00 00  FF 00 00 FF
```
*Header (Dur0=1240):* Same as J1.
*Block 0 (Dur=1240):* `+0x09=05006400` (p1=5, p2=100). `+0x11` (for Dur1=500) = `F401` (500). Matches HypF.
*Block 1 (Dur=500):* `+0x09=13006400` (p1=19, p2=100). `+0x11` (for Dur2=1930) = `1E00` (30). **Anomaly persists.**
*Block 2 (Dur=1930, Last):* Standard.

### Test J5: N=3 segments. Durations: 1240, 80, 1930 units

*Hex Dump (J5.prg):*
```
0000:0000 | 50 52 03 49  4E 05 00 00  00 04 00 08  E8 03 50 49
0000:0010 | 3B 00 00 00  03 00 0C 00  64 00 59 00  00 00 28 00
0000:0020 | 04 00 01 00  00 D8 04 00  00 00 00 64  00 85 01 00
0000:0030 | 00 50 00 04  00 01 00 00  50 00 00 00  13 00 64 00
0000:0040 | B1 02 00 00  1E 00 04 00  01 00 00 8A  07 00 00 43
0000:0050 | 44 88 03 00  00 2C 01 00  00 FF 00 00  FF 00 00 FF
```
*Header (Dur0=1240):* Same as J1.
*Block 0 (Dur=1240):* `+0x09=00006400` (p1=0, p2=100). `+0x11` (for Dur1=80) = `5000` (80). Matches HypF.
*Block 1 (Dur=80):* `+0x09=13006400` (p1=19, p2=100). `+0x11` (for Dur2=1930) = `1E00` (30). **Anomaly persists.**
*Block 2 (Dur=1930, Last):* Standard.

---

---

## Field[+0x09].part1 and "1930 Anomaly" Deep Dive - K & L Series (1000Hz)

**Date:** 2025-06-02 (following analysis of Tests H & J)

These N=3 segment tests (1000Hz) further probe `Field[+0x09].part1` and the conditions for the `Field[+0x11]` "1930 Anomaly".

### Set K: Probing `Field[+0x09].field_09_part1`

**Test K1: Durations: 70, 70, 100 units**
*Hex Dump (K1.prg):*
```
0000:0000 | 50 52 03 49  4E 05 00 00  00 04 00 08  E8 03 50 49
0000:0010 | 3B 00 00 00  03 00 00 00  64 00 59 00  00 00 46 00
0000:0020 | 04 00 01 00  00 46 00 00  00 00 00 64  00 85 01 00
0000:0030 | 00 46 00 04  00 01 00 00  46 00 00 00  01 00 64 00
0000:0040 | B1 02 00 00  00 00 04 00  01 00 00 64  00 00 00 43
0000:0050 | 44 88 03 00  00 2C 01 00  00 FF 00 00  FF 00 00 FF
```
*Header (Dur0=70):* `0x16=0000` (0), `0x1E=4600` (70). Matches.
*Block 0 (Dur0=70, Dur1=70):* `+0x09=00006400` (p1=0, p2=100). `+0x11` (for Dur1=70) = `4600` (70). Matches HypF.
*Block 1 (Dur1=70, Dur2=100):* `+0x09=01006400` (p1=1, p2=100). `+0x11` (for Dur2=100) = `0000` (0). Matches HypF.

**Test K2: Durations: 70, 100, 70 units**
*Hex Dump (K2.prg):*
```
0000:0000 | 50 52 03 49  4E 05 00 00  00 04 00 08  E8 03 50 49
0000:0010 | 3B 00 00 00  03 00 00 00  64 00 59 00  00 00 46 00
0000:0020 | 04 00 01 00  00 46 00 00  00 01 00 64  00 85 01 00
0000:0030 | 00 00 00 04  00 01 00 00  64 00 00 00  00 00 64 00
0000:0040 | B1 02 00 00  46 00 04 00  01 00 00 46  00 00 00 43
0000:0050 | 44 88 03 00  00 2C 01 00  00 FF 00 00  FF 00 00 FF
```
*Header (Dur0=70):* `0x16=0000` (0), `0x1E=4600` (70). Matches.
*Block 0 (Dur0=70, Dur1=100):* `+0x09=01006400` (p1=1, p2=100). `+0x11` (for Dur1=100) = `0000` (0). Matches HypF.
*Block 1 (Dur1=100, Dur2=70):* `+0x09=00006400` (p1=0, p2=100). `+0x11` (for Dur2=70) = `4600` (70). Matches HypF.

**Test K3: Durations: 100, 70, 70 units**
*Hex Dump (K3.prg):*
```
0000:0000 | 50 52 03 49  4E 05 00 00  00 04 00 08  E8 03 50 49
0000:0010 | 3B 00 00 00  03 00 01 00  64 00 59 00  00 00 00 00
0000:0020 | 04 00 01 00  00 64 00 00  00 00 00 64  00 85 01 00
0000:0030 | 00 46 00 04  00 01 00 00  46 00 00 00  00 00 64 00
0000:0040 | B1 02 00 00  46 00 04 00  01 00 00 46  00 00 00 43
0000:0050 | 44 88 03 00  00 2C 01 00  00 FF 00 00  FF 00 00 FF
```
*Header (Dur0=100):* `0x16=0100` (1), `0x1E=0000` (0). Matches.
*Block 0 (Dur0=100, Dur1=70):* `+0x09=00006400` (p1=0, p2=100). `+0x11` (for Dur1=70) = `4600` (70). Matches HypF.
*Block 1 (Dur1=70, Dur2=70):* `+0x09=00006400` (p1=0, p2=100). `+0x11` (for Dur2=70) = `4600` (70). Matches HypF.

**Test K4: Durations: 120, 120, 100 units**
*Hex Dump (K4.prg):*
```
0000:0000 | 50 52 03 49  4E 05 00 00  00 04 00 08  E8 03 50 49
0000:0010 | 3B 00 00 00  03 00 01 00  64 00 59 00  00 00 14 00
0000:0020 | 04 00 01 00  00 78 00 00  00 01 00 64  00 85 01 00
0000:0030 | 00 14 00 04  00 01 00 00  78 00 00 00  01 00 64 00
0000:0040 | B1 02 00 00  00 00 04 00  01 00 00 64  00 00 00 43
0000:0050 | 44 88 03 00  00 2C 01 00  00 FF 00 00  FF 00 00 FF
```
*Header (Dur0=120):* `0x16=0100` (1), `0x1E=1400` (20). Matches.
*Block 0 (Dur0=120, Dur1=120):* `+0x09=01006400` (p1=1, p2=100). `+0x11` (for Dur1=120) = `7800` (120). Matches HypF.
*Block 1 (Dur1=120, Dur2=100):* `+0x09=01006400` (p1=1, p2=100). `+0x11` (for Dur2=100) = `0000` (0). Matches HypF.

**Test K5: Durations: 120, 100, 120 units**
*Hex Dump (K5.prg):*
```
0000:0000 | 50 52 03 49  4E 05 00 00  00 04 00 08  E8 03 50 49
0000:0010 | 3B 00 00 00  03 00 01 00  64 00 59 00  00 00 14 00
0000:0020 | 04 00 01 00  00 78 00 00  00 01 00 64  00 85 01 00
0000:0030 | 00 00 00 04  00 01 00 00  64 00 00 00  01 00 64 00
0000:0040 | B1 02 00 00  14 00 04 00  01 00 00 78  00 00 00 43
0000:0050 | 44 88 03 00  00 2C 01 00  00 FF 00 00  FF 00 00 FF
```
*Header (Dur0=120):* `0x16=0100` (1), `0x1E=1400` (20). Matches.
*Block 0 (Dur0=120, Dur1=100):* `+0x09=01006400` (p1=1, p2=100). `+0x11` (for Dur1=100) = `0000` (0). Matches HypF.
*Block 1 (Dur1=100, Dur2=120):* `+0x09=01006400` (p1=1, p2=100). `+0x11` (for Dur2=120) = `7800` (120). Matches HypF (rule 2c, Dur_k=100).

**Test K6: Durations: 100, 120, 120 units**
*Hex Dump (K6.prg):*
```
0000:0000 | 50 52 03 49  4E 05 00 00  00 04 00 08  E8 03 50 49
0000:0010 | 3B 00 00 00  03 00 01 00  64 00 59 00  00 00 00 00
0000:0020 | 04 00 01 00  00 64 00 00  00 01 00 64  00 85 01 00
0000:0030 | 00 14 00 04  00 01 00 00  78 00 00 00  01 00 64 00
0000:0040 | B1 02 00 00  14 00 04 00  01 00 00 78  00 00 00 43
0000:0050 | 44 88 03 00  00 2C 01 00  00 FF 00 00  FF 00 00 FF
```
*Header (Dur0=100):* `0x16=0100` (1), `0x1E=0000` (0). Matches.
*Block 0 (Dur0=100, Dur1=120):* `+0x09=01006400` (p1=1, p2=100). `+0x11` (for Dur1=120) = `7800` (120). Matches HypF (rule 2c, Dur_k=100).
*Block 1 (Dur1=120, Dur2=120):* `+0x09=01006400` (p1=1, p2=100). `+0x11` (for Dur2=120) = `7800` (120). Matches HypF.

**Test K7: Durations: 70, 120, 150 units**
*Hex Dump (K7.prg):*
```
0000:0000 | 50 52 03 49  4E 05 00 00  00 04 00 08  E8 03 50 49
0000:0010 | 3B 00 00 00  03 00 00 00  64 00 59 00  00 00 46 00
0000:0020 | 04 00 01 00  00 46 00 00  00 01 00 64  00 85 01 00
0000:0030 | 00 14 00 04  00 01 00 00  78 00 00 00  01 00 64 00
0000:0040 | B1 02 00 00  32 00 04 00  01 00 00 96  00 00 00 43
0000:0050 | 44 88 03 00  00 2C 01 00  00 FF 00 00  FF 00 00 FF
```
*Header (Dur0=70):* `0x16=0000` (0), `0x1E=4600` (70). Matches.
*Block 0 (Dur0=70, Dur1=120):* `+0x09=01006400` (p1=1, p2=100). `+0x11` (for Dur1=120) = `7800` (120). Matches HypF.
*Block 1 (Dur1=120, Dur2=150):* `+0x09=01006400` (p1=1, p2=100). `+0x11` (for Dur2=150) = `9600` (150). Matches HypF.

**Test K8: Durations: 150, 120, 70 units**
*Hex Dump (K8.prg):*
```
0000:0000 | 50 52 03 49  4E 05 00 00  00 04 00 08  E8 03 50 49
0000:0010 | 3B 00 00 00  03 00 01 00  64 00 59 00  00 00 32 00
0000:0020 | 04 00 01 00  00 96 00 00  00 01 00 64  00 85 01 00
0000:0030 | 00 14 00 04  00 01 00 00  78 00 00 00  00 00 64 00
0000:0040 | B1 02 00 00  46 00 04 00  01 00 00 46  00 00 00 43
0000:0050 | 44 88 03 00  00 2C 01 00  00 FF 00 00  FF 00 00 FF
```
*Header (Dur0=150):* `0x16=0100` (1), `0x1E=3200` (50). Matches.
*Block 0 (Dur0=150, Dur1=120):* `+0x09=01006400` (p1=1, p2=100). `+0x11` (for Dur1=120) = `7800` (120). Matches HypF.
*Block 1 (Dur1=120, Dur2=70):* `+0x09=00006400` (p1=0, p2=100). `+0x11` (for Dur2=70) = `4600` (70). Matches HypF.

### Set L: Mapping the "1930 Anomaly" for `Field[+0x11]`
*(Dur0 = 1000 units for these tests)*

**Test L1: Durations: 1000, 70, 1930 units**
*Hex Dump (L1.prg):*
```
0000:0000 | 50 52 03 49  4E 05 00 00  00 04 00 08  E8 03 50 49
0000:0010 | 3B 00 00 00  03 00 0A 00  64 00 59 00  00 00 00 00
0000:0020 | 04 00 01 00  00 E8 03 00  00 00 00 64  00 85 01 00
0000:0030 | 00 46 00 04  00 01 00 00  46 00 00 00  13 00 64 00
0000:0040 | B1 02 00 00  1E 00 04 00  01 00 00 8A  07 00 00 43
0000:0050 | 44 88 03 00  00 2C 01 00  00 FF 00 00  FF 00 00 FF
```
*Header (Dur0=1000):* `0x16=0A00` (10), `0x1E=0000` (0). Matches.
*Block 0 (Dur0=1000, Dur1=70):* `+0x09=00006400` (p1=0, p2=100). `+0x11` (for Dur1=70) = `4600` (70). Matches HypF.
*Block 1 (Dur1=70, Dur2=1930):* `+0x09=13006400` (p1=19, p2=100). `+0x11` (for Dur2=1930) = `1E00` (30). **Anomaly present.**

**Test L2: Durations: 1000, 100, 1930 units**
*Hex Dump (L2.prg):*
```
0000:0000 | 50 52 03 49  4E 05 00 00  00 04 00 08  E8 03 50 49
0000:0010 | 3B 00 00 00  03 00 0A 00  64 00 59 00  00 00 00 00
0000:0020 | 04 00 01 00  00 E8 03 00  00 01 00 64  00 85 01 00
0000:0030 | 00 00 00 04  00 01 00 00  64 00 00 00  13 00 64 00
0000:0040 | B1 02 00 00  1E 00 04 00  01 00 00 8A  07 00 00 43
0000:0050 | 44 88 03 00  00 2C 01 00  00 FF 00 00  FF 00 00 FF
```
*Header (Dur0=1000):* Same as L1.
*Block 0 (Dur0=1000, Dur1=100):* `+0x09=01006400` (p1=1, p2=100). `+0x11` (for Dur1=100) = `0000` (0). Matches HypF.
*Block 1 (Dur1=100, Dur2=1930):* `+0x09=13006400` (p1=19, p2=100). `+0x11` (for Dur2=1930) = `1E00` (30). **Anomaly present.**

**Test L3: Durations: 1000, 490, 1930 units**
*Hex Dump (L3.prg):*
```
0000:0000 | 50 52 03 49  4E 05 00 00  00 04 00 08  E8 03 50 49
0000:0010 | 3B 00 00 00  03 00 0A 00  64 00 59 00  00 00 00 00
0000:0020 | 04 00 01 00  00 E8 03 00  00 04 00 64  00 85 01 00
0000:0030 | 00 5A 00 04  00 01 00 00  EA 01 00 00  13 00 64 00
0000:0040 | B1 02 00 00  1E 00 04 00  01 00 00 8A  07 00 00 43
0000:0050 | 44 88 03 00  00 2C 01 00  00 FF 00 00  FF 00 00 FF
```
*Header (Dur0=1000):* Same as L1.
*Block 0 (Dur0=1000, Dur1=490):* `+0x09=04006400` (p1=4, p2=100). `+0x11` (for Dur1=490) = `EA01` (490). Matches HypF.
*Block 1 (Dur1=490, Dur2=1930):* `+0x09=13006400` (p1=19, p2=100). `+0x11` (for Dur2=1930) = `1E00` (30). **Anomaly present.**

**Test L4: Durations: 1000, 510, 1930 units**
*Hex Dump (L4.prg):*
```
0000:0000 | 50 52 03 49  4E 05 00 00  00 04 00 08  E8 03 50 49
0000:0010 | 3B 00 00 00  03 00 0A 00  64 00 59 00  00 00 00 00
0000:0020 | 04 00 01 00  00 E8 03 00  00 05 00 64  00 85 01 00
0000:0030 | 00 0A 00 04  00 01 00 00  FE 01 00 00  13 00 64 00
0000:0040 | B1 02 00 00  1E 00 04 00  01 00 00 8A  07 00 00 43
0000:0050 | 44 88 03 00  00 2C 01 00  00 FF 00 00  FF 00 00 FF
```
*Header (Dur0=1000):* Same as L1.
*Block 0 (Dur0=1000, Dur1=510):* `+0x09=05006400` (p1=5, p2=100). `+0x11` (for Dur1=510) = `FE01` (510). Matches HypF.
*Block 1 (Dur1=510, Dur2=1930):* `+0x09=13006400` (p1=19, p2=100). `+0x11` (for Dur2=1930) = `1E00` (30). **Anomaly present.**

**Test L5: Durations: 1000, 600, 1930 units**
*Hex Dump (L5.prg):*
```
0000:0000 | 50 52 03 49  4E 05 00 00  00 04 00 08  E8 03 50 49
0000:0010 | 3B 00 00 00  03 00 0A 00  64 00 59 00  00 00 00 00
0000:0020 | 04 00 01 00  00 E8 03 00  00 06 00 64  00 85 01 00
0000:0030 | 00 00 00 04  00 01 00 00  58 02 00 00  13 00 64 00
0000:0040 | B1 02 00 00  1E 00 04 00  01 00 00 8A  07 00 00 43
0000:0050 | 44 88 03 00  00 2C 01 00  00 FF 00 00  FF 00 00 FF
```
*Header (Dur0=1000):* Same as L1.
*Block 0 (Dur0=1000, Dur1=600):* `+0x09=06006400` (p1=6, p2=100). `+0x11` (for Dur1=600) = `5802` (600). Matches HypF.
*Block 1 (Dur1=600, Dur2=1930):* `+0x09=13006400` (p1=19, p2=100). `+0x11` (for Dur2=1930) = `1E00` (30). **Anomaly present.**

**Test L6: Durations: 1000, 1000, 1930 units**
*Hex Dump (L6.prg):*
```
0000:0000 | 50 52 03 49  4E 05 00 00  00 04 00 08  E8 03 50 49
0000:0010 | 3B 00 00 00  03 00 0A 00  64 00 59 00  00 00 00 00
0000:0020 | 04 00 01 00  00 E8 03 00  00 0A 00 64  00 85 01 00
0000:0030 | 00 00 00 04  00 01 00 00  E8 03 00 00  13 00 64 00
0000:0040 | B1 02 00 00  1E 00 04 00  01 00 00 8A  07 00 00 43
0000:0050 | 44 88 03 00  00 2C 01 00  00 FF 00 00  FF 00 00 FF
```
*Header (Dur0=1000):* Same as L1.
*Block 0 (Dur0=1000, Dur1=1000):* `+0x09=0A006400` (p1=10, p2=100). `+0x11` (for Dur1=1000) = `E803` (1000). Matches HypF.
*Block 1 (Dur1=1000, Dur2=1930):* `+0x09=13006400` (p1=19, p2=100). `+0x11` (for Dur2=1930) = `1E00` (30). **Anomaly present.**

**Test L7: Durations: 1000, 1929, 1930 units**
*Hex Dump (L7.prg):*
```
0000:0000 | 50 52 03 49  4E 05 00 00  00 04 00 08  E8 03 50 49
0000:0010 | 3B 00 00 00  03 00 0A 00  64 00 59 00  00 00 00 00
0000:0020 | 04 00 01 00  00 E8 03 00  00 13 00 64  00 85 01 00
0000:0030 | 00 1D 00 04  00 01 00 00  89 07 00 00  13 00 64 00
0000:0040 | B1 02 00 00  1E 00 04 00  01 00 00 8A  07 00 00 43
0000:0050 | 44 88 03 00  00 2C 01 00  00 FF 00 00  FF 00 00 FF
```
*Header (Dur0=1000):* Same as L1.
*Block 0 (Dur0=1000, Dur1=1929):* `+0x09=13006400` (p1=19, p2=100). `+0x11` (for Dur1=1929) = `8907` (1929). Matches HypF.
*Block 1 (Dur1=1929, Dur2=1930):* `+0x09=13006400` (p1=19, p2=100). `+0x11` (for Dur2=1930) = `1E00` (30). **Anomaly present.**

---

## Deduced Logic and Hypotheses (as of 2025-06-02, after K & L series)

This section summarizes the current understanding based on all analyzed PRG files, including Tests A-L.

### Header Fields `0x16` and `0x1E`

Let:
*   `Dur0Units_actual`: The duration of the first PRG segment (Segment 0) in PRG time units.
*   `N_prg`: The total number of PRG segments in the file.
*   `NominalBase = 100`.
*   `val_0x16_dec`: The decimal value for field `0x16`.
*   `val_0x1E_dec`: The decimal value for field `0x1E`.

**Field `0x16` (Header First Segment Info):**
  `val_0x16_dec = floor(Dur0Units_actual / NominalBase)`
  *This logic holds universally across all tests (A-L, N=1 and N>1, various refresh rates).*

**Field `0x1E` (Header First Segment Duration (Conditional)):**
Refined Hypothesis for Header Field 0x1E:
Let NominalBase = 100.

    If N_prg == 1:
        If Dur0Units_actual % NominalBase == 0: (Dur0 is a multiple of 100)
            If RefreshRate == 1 OR Dur0Units_actual == NominalBase: val_0x1E_dec = 0.
            Else (RefreshRate != 1 AND Dur0Units_actual != NominalBase): val_0x1E_dec = Dur0Units_actual.
        Else (Dur0Units_actual % NominalBase != 0):
            val_0x1E_dec = Dur0Units_actual % NominalBase.

    If N_prg > 1:
        If Dur0Units_actual == NominalBase (i.e., 100): val_0x1E_dec = 0.
        Else: val_0x1E_dec = Dur0Units_actual.

    Justification for N=1 refinement: This handles the 1Hz, Dur0=200 case (0x1E=0) and the 1000Hz, Dur0=500/1000 cases (0x1E=Dur0).

    Justification for N>1 refinement: This handles red_1s_blue_.5s_1000r.prg (Dur0=1000, 0x1E=1000) and other N>1 cases correctly. The key is that for N>1, if Dur0 is not 100, 0x1E seems to just be Dur0Units_actual.
The byte values written to the file are `struct.pack('<H', val_0x16_dec)` and `struct.pack('<H', val_0x1E_dec & 0xFFFF)`.
*This logic for header fields 0x16 and 0x1E appears consistent across all known tests (A-L).*

### Intermediate Duration Block Fields (Segments 0 to N-2)

This section details the refined understanding of Field `+0x09` and Field `+0x11` for intermediate duration blocks (i.e., for segments 0 to N-2, where N is the total number of segments).

**Field `+0x09` (Segment Index & Duration)**
This 4-byte field is composed of two 2-byte Little Endian values: `field_09_part1` followed by `field_09_part2`.

*   **`field_09_part2`:**
    *   **Observation (Tests A-L, 1000Hz):** For all intermediate duration blocks (segments 0 to N-2), `field_09_part2` is consistently `64 00` (decimal 100).
    *   **Assessment:** This is correct and universally observed in the provided 1000Hz test data.

*   **`field_09_part1`:**
    *   **Hypothesis (from Tests A-L, 1000Hz):** For an intermediate duration block `k` (which describes segment `k`), if the *next* segment (segment `k+1`) has a duration `Dur_k+1` (in PRG time units):
        **`field_09_part1 (for block k) = floor(Dur_k+1 / 100)`**
    *   **Assessment:** This hypothesis correctly predicts `field_09_part1` for all intermediate blocks in all official app tests A-L (1000Hz).
        *   Example Test A (Durations: 1240, 470, 1930):
            *   Block 0: `Dur_1` = 470. `floor(470 / 100) = 4`. `field_09_part1` is `04 00`. Matches.
            *   Block 1: `Dur_2` = 1930. `floor(1930 / 100) = 19`. `field_09_part1` is `13 00`. Matches.
        *   Example Test G (Durations: 70, 70, 120, 120, 70):
            *   Block 0: `Dur_1` = 70. `floor(70 / 100) = 0`. `field_09_part1` is `00 00`. Matches.
            *   Block 1: `Dur_2` = 120. `floor(120 / 100) = 1`. `field_09_part1` is `01 00`. Matches.
            *   Block 2: `Dur_3` = 120. `floor(120 / 100) = 1`. `field_09_part1` is `01 00`. Matches.
            *   Block 3: `Dur_4` = 70. `floor(70 / 100) = 0`. `field_09_part1` is `00 00`. Matches.

**Field `+0x11` (Next Segment Info)**
Let `Dur_k+1` be the duration of the next segment (segment `k+1`) in PRG time units.

*   **Special Override Case ("1930 Anomaly"):**
    *   If `Dur_k+1 == 1930`: `Field[+0x11]` for Block `k` is `1E 00` (decimal 30).
    *   This override is confirmed by Tests L1-L7, irrespective of `Dur_k`.

*   **General Rules (if not overridden by the "1930 Anomaly"):**
    a.  If `Dur_k+1 < 100`: `Field[+0x11] = Dur_k+1`.
    b.  Else if `Dur_k+1 == 100`: `Field[+0x11] = 0`.
    c.  Else (`Dur_k+1 > 100` and `Dur_k+1 != 1930`): `Field[+0x11] = Dur_k+1`.

*   **Assessment:** This refined logic for `Field[+0x11]` correctly predicts its value for all intermediate blocks in Tests A-L. The previous "Discrepancy" noted in Test H3 is resolved with this logic (Test H3, Block 1: `Dur_k=100`, `Dur_k+1=150`. Since `150 > 100` and not 1930, `Field[+0x11]` is 150 (`96 00`), which matches the hex dump and Rule 2.c).

*Implementation Note for `prg_generator.py`: The generator should be updated to reflect these refined hypotheses for both `Field[+0x09]` (part1 and part2) and `Field[+0x11]` to align more closely with official app behavior, potentially resolving previous strobing issues linked to older, more complex hypotheses for these fields.*
---

## Additional Test Series (M, N, P, Q, R) - 1000Hz Refresh Rate

**Date:** 2025-06-02

These tests further investigate specific behaviors and boundary conditions at 1000Hz PRG refresh rate.

### Test M1:

    Segment 0 Duration: 50ms
    Segment 1 Duration: 50ms
    Segment 2 Duration: 103ms

```
0000:0000 | 50 52 03 49  4E 05 00 00  00 04 00 08  E8 03 50 49 | PR.IN.......è.PI
0000:0010 | 3B 00 00 00  03 00 00 00  64 00 59 00  00 00 32 00 | ;.......d.Y...2.
0000:0020 | 04 00 01 00  00 32 00 00  00 00 00 64  00 85 01 00 | .....2.....d....
0000:0030 | 00 32 00 04  00 01 00 00  32 00 00 00  01 00 64 00 | .2......2.....d.
0000:0040 | B1 02 00 00  03 00 04 00  01 00 00 67  00 00 00 43 | ±..........g...C
0000:0050 | 44 88 03 00  00 2C 01 00  00 FF 00 00  FF 00 00 FF | D....,...ÿ..ÿ..ÿ
```

### Test M2:

    Segment 0 Duration: 50ms
    Segment 1 Duration: 100ms
    Segment 2 Duration: 103ms

```
0000:0000 | 50 52 03 49  4E 05 00 00  00 04 00 08  E8 03 50 49 | PR.IN.......è.PI
0000:0010 | 3B 00 00 00  03 00 00 00  64 00 59 00  00 00 32 00 | ;.......d.Y...2.
0000:0020 | 04 00 01 00  00 32 00 00  00 01 00 64  00 85 01 00 | .....2.....d....
0000:0030 | 00 00 00 04  00 01 00 00  64 00 00 00  01 00 64 00 | ........d.....d.
0000:0040 | B1 02 00 00  03 00 04 00  01 00 00 67  00 00 00 43 | ±..........g...C
0000:0050 | 44 88 03 00  00 2C 01 00  00 FF 00 00  FF 00 00 FF | D....,...ÿ..ÿ..ÿ
```

### Test M3:

    Segment 0 Duration: 50ms
    Segment 1 Duration: 150ms
    Segment 2 Duration: 103ms

```
0000:0000 | 50 52 03 49  4E 05 00 00  00 04 00 08  E8 03 50 49 | PR.IN.......è.PI
0000:0010 | 3B 00 00 00  03 00 00 00  64 00 59 00  00 00 32 00 | ;.......d.Y...2.
0000:0020 | 04 00 01 00  00 32 00 00  00 01 00 64  00 85 01 00 | .....2.....d....
0000:0030 | 00 32 00 04  00 01 00 00  96 00 00 00  01 00 64 00 | .2............d.
0000:0040 | B1 02 00 00  03 00 04 00  01 00 00 67  00 00 00 43 | ±..........g...C
0000:0050 | 44 88 03 00  00 2C 01 00  00 FF 00 00  FF 00 00 FF | D....,...ÿ..ÿ..ÿ
```

### Test N1:

    Segment 0 Duration: 50ms
    Segment 1 Duration: 50ms
    Segment 2 Duration: 101ms

```
0000:0000 | 50 52 03 49  4E 05 00 00  00 04 00 08  E8 03 50 49 | PR.IN.......è.PI
0000:0010 | 3B 00 00 00  03 00 00 00  64 00 59 00  00 00 32 00 | ;.......d.Y...2.
0000:0020 | 04 00 01 00  00 32 00 00  00 00 00 64  00 85 01 00 | .....2.....d....
0000:0030 | 00 32 00 04  00 01 00 00  32 00 00 00  01 00 64 00 | .2......2.....d.
0000:0040 | B1 02 00 00  01 00 04 00  01 00 00 65  00 00 00 43 | ±..........e...C
0000:0050 | 44 88 03 00  00 2C 01 00  00 FF 00 00  FF 00 00 FF | D....,...ÿ..ÿ..ÿ
```

### Test N2:

    Segment 0 Duration: 50ms
    Segment 1 Duration: 50ms
    Segment 2 Duration: 102ms

```
0000:0000 | 50 52 03 49  4E 05 00 00  00 04 00 08  E8 03 50 49 | PR.IN.......è.PI
0000:0010 | 3B 00 00 00  03 00 00 00  64 00 59 00  00 00 32 00 | ;.......d.Y...2.
0000:0020 | 04 00 01 00  00 32 00 00  00 00 00 64  00 85 01 00 | .....2.....d....
0000:0030 | 00 32 00 04  00 01 00 00  32 00 00 00  01 00 64 00 | .2......2.....d.
0000:0040 | B1 02 00 00  02 00 04 00  01 00 00 66  00 00 00 43 | ±..........f...C
0000:0050 | 44 88 03 00  00 2C 01 00  00 FF 00 00  FF 00 00 FF | D....,...ÿ..ÿ..ÿ
```

### Test N3:

    Segment 0 Duration: 50ms
    Segment 1 Duration: 50ms
    Segment 2 Duration: 104ms

```
0000:0000 | 50 52 03 49  4E 05 00 00  00 04 00 08  E8 03 50 49 | PR.IN.......è.PI
0000:0010 | 3B 00 00 00  03 00 00 00  64 00 59 00  00 00 32 00 | ;.......d.Y...2.
0000:0020 | 04 00 01 00  00 32 00 00  00 00 00 64  00 85 01 00 | .....2.....d....
0000:0030 | 00 32 00 04  00 01 00 00  32 00 00 00  01 00 64 00 | .2......2.....d.
0000:0040 | B1 02 00 00  04 00 04 00  01 00 00 68  00 00 00 43 | ±..........h...C
0000:0050 | 44 88 03 00  00 2C 01 00  00 FF 00 00  FF 00 00 FF | D....,...ÿ..ÿ..ÿ
```

### Test N4:

    Segment 0 Duration: 50ms
    Segment 1 Duration: 50ms
    Segment 2 Duration: 105ms

```
0000:0000 | 50 52 03 49  4E 05 00 00  00 04 00 08  E8 03 50 49 | PR.IN.......è.PI
0000:0010 | 3B 00 00 00  03 00 00 00  64 00 59 00  00 00 32 00 | ;.......d.Y...2.
0000:0020 | 04 00 01 00  00 32 00 00  00 00 00 64  00 85 01 00 | .....2.....d....
0000:0030 | 00 32 00 04  00 01 00 00  32 00 00 00  01 00 64 00 | .2......2.....d.
0000:0040 | B1 02 00 00  05 00 04 00  01 00 00 69  00 00 00 43 | ±..........i...C
0000:0050 | 44 88 03 00  00 2C 01 00  00 FF 00 00  FF 00 00 FF | D....,...ÿ..ÿ..ÿ
```

### Test P1: (Mimicking context similar to N=258 Block 192 anomaly where part1 was 2)

    Segment 0 Duration: 50ms
    Segment 1 Duration: 102ms (Mimicking Dur_k of Segment 192)
    Segment 2 Duration: 200ms (Testing Dur_k+1 that should yield part1 = 2)

```
0000:0000 | 50 52 03 49  4E 05 00 00  00 04 00 08  E8 03 50 49 | PR.IN.......è.PI
0000:0010 | 3B 00 00 00  03 00 00 00  64 00 59 00  00 00 32 00 | ;.......d.Y...2.
0000:0020 | 04 00 01 00  00 32 00 00  00 01 00 64  00 85 01 00 | .....2.....d....
0000:0030 | 00 02 00 04  00 01 00 00  66 00 00 00  02 00 64 00 | ........f.....d.
0000:0040 | B1 02 00 00  00 00 04 00  01 00 00 C8  00 00 00 43 | ±..........È...C
0000:0050 | 44 88 03 00  00 2C 01 00  00 FF 00 00  FF 00 00 FF | D....,...ÿ..ÿ..ÿ
```

### Test P2: (Testing Dur_k+1 boundary for part1 around floor(X/100)=1 or 2)

    Segment 0 Duration: 50ms
    Segment 1 Duration: 50ms
    Segment 2 Duration: 199ms

```
0000:0000 | 50 52 03 49  4E 05 00 00  00 04 00 08  E8 03 50 49 | PR.IN.......è.PI
0000:0010 | 3B 00 00 00  03 00 00 00  64 00 59 00  00 00 32 00 | ;.......d.Y...2.
0000:0020 | 04 00 01 00  00 32 00 00  00 00 00 64  00 85 01 00 | .....2.....d....
0000:0030 | 00 32 00 04  00 01 00 00  32 00 00 00  01 00 64 00 | .2......2.....d.
0000:0040 | B1 02 00 00  63 00 04 00  01 00 00 C7  00 00 00 43 | ±...c......Ç...C
0000:0050 | 44 88 03 00  00 2C 01 00  00 FF 00 00  FF 00 00 FF | D....,...ÿ..ÿ..ÿ
```

### Test P3: (Testing Dur_k+1 boundary for part1 around floor(X/100)=1 or 2)

    Segment 0 Duration: 50ms
    Segment 1 Duration: 50ms
    Segment 2 Duration: 200ms

```
0000:0000 | 50 52 03 49  4E 05 00 00  00 04 00 08  E8 03 50 49 | PR.IN.......è.PI
0000:0010 | 3B 00 00 00  03 00 00 00  64 00 59 00  00 00 32 00 | ;.......d.Y...2.
0000:0020 | 04 00 01 00  00 32 00 00  00 00 00 64  00 85 01 00 | .....2.....d....
0000:0030 | 00 32 00 04  00 01 00 00  32 00 00 00  02 00 64 00 | .2......2.....d.
0000:0040 | B1 02 00 00  00 00 04 00  01 00 00 C8  00 00 00 43 | ±..........È...C
0000:0050 | 44 88 03 00  00 2C 01 00  00 FF 00 00  FF 00 00 FF | D....,...ÿ..ÿ..ÿ
```

### Test P4: (Testing Dur_k+1 boundary for part1 around floor(X/100)=2)

    Segment 0 Duration: 50ms
    Segment 1 Duration: 50ms
    Segment 2 Duration: 201ms

```
0000:0000 | 50 52 03 49  4E 05 00 00  00 04 00 08  E8 03 50 49 | PR.IN.......è.PI
0000:0010 | 3B 00 00 00  03 00 00 00  64 00 59 00  00 00 32 00 | ;.......d.Y...2.
0000:0020 | 04 00 01 00  00 32 00 00  00 00 00 64  00 85 01 00 | .....2.....d....
0000:0030 | 00 32 00 04  00 01 00 00  32 00 00 00  02 00 64 00 | .2......2.....d.
0000:0040 | B1 02 00 00  01 00 04 00  01 00 00 C9  00 00 00 43 | ±..........É...C
0000:0050 | 44 88 03 00  00 2C 01 00  00 FF 00 00  FF 00 00 FF | D....,...ÿ..ÿ..ÿ
```

### Test P5: (Testing Dur_k+1 boundary for part1 around floor(X/100)=2 or 3)

    Segment 0 Duration: 50ms
    Segment 1 Duration: 50ms
    Segment 2 Duration: 299ms

```
0000:0000 | 50 52 03 49  4E 05 00 00  00 04 00 08  E8 03 50 49 | PR.IN.......è.PI
0000:0010 | 3B 00 00 00  03 00 00 00  64 00 59 00  00 00 32 00 | ;.......d.Y...2.
0000:0020 | 04 00 01 00  00 32 00 00  00 00 00 64  00 85 01 00 | .....2.....d....
0000:0030 | 00 32 00 04  00 01 00 00  32 00 00 00  02 00 64 00 | .2......2.....d.
0000:0040 | B1 02 00 00  63 00 04 00  01 00 00 2B  01 00 00 43 | ±...c......+...C
0000:0050 | 44 88 03 00  00 2C 01 00  00 FF 00 00  FF 00 00 FF | D....,...ÿ..ÿ..ÿ
```

### Test P6: (Testing Dur_k+1 boundary for part1 around floor(X/100)=2 or 3)

    Segment 0 Duration: 50ms
    Segment 1 Duration: 50ms
    Segment 2 Duration: 300ms

```
0000:0000 | 50 52 03 49  4E 05 00 00  00 04 00 08  E8 03 50 49 | PR.IN.......è.PI
0000:0010 | 3B 00 00 00  03 00 00 00  64 00 59 00  00 00 32 00 | ;.......d.Y...2.
0000:0020 | 04 00 01 00  00 32 00 00  00 00 00 64  00 85 01 00 | .....2.....d....
0000:0030 | 00 32 00 04  00 01 00 00  32 00 00 00  03 00 64 00 | .2......2.....d.
0000:0040 | B1 02 00 00  00 00 04 00  01 00 00 2C  01 00 00 43 | ±..........,...C
0000:0050 | 44 88 03 00  00 2C 01 00  00 FF 00 00  FF 00 00 FF | D....,...ÿ..ÿ..ÿ
```

### Test Q1: (N=1, Dur0Units_actual is multiple of 100, but not 100)

    Number of Segments (N): 1
    Segment 0 Duration (Dur0Units_actual): 200ms
    (Expected: 0x16=0200, 0x1E=C800 (200))

```
0000:0000 | 50 52 03 49  4E 05 00 00  00 04 00 08  E8 03 50 49 | PR.IN.......è.PI
0000:0010 | 15 00 00 00  01 00 02 00  64 00 33 00  00 00 00 00 | ........d.3.....
0000:0020 | 04 00 01 00  00 C8 00 00  00 43 44 30  01 00 00 64 | .....È...CD0...d
0000:0030 | 00 00 00 FF  00 00 FF 00  00 FF 00 00  FF 00 00 FF | ...ÿ..ÿ..ÿ..ÿ..ÿ
```

### Test Q2: (N=1, Dur0Units_actual is multiple of 100, but not 100)

    Number of Segments (N): 1
    Segment 0 Duration (Dur0Units_actual): 300ms
    (Expected: 0x16=0300, 0x1E=2C01 (300))

```
0000:0000 | 50 52 03 49  4E 05 00 00  00 04 00 08  E8 03 50 49 | PR.IN.......è.PI
0000:0010 | 15 00 00 00  01 00 03 00  64 00 33 00  00 00 00 00 | ........d.3.....
0000:0020 | 04 00 01 00  00 2C 01 00  00 43 44 30  01 00 00 64 | .....,...CD0...d
0000:0030 | 00 00 00 FF  00 00 FF 00  00 FF 00 00  FF 00 00 FF | ...ÿ..ÿ..ÿ..ÿ..ÿ
```

### Test Q3: (N>1, Dur0Units_actual is multiple of 100, but not 100)

    Number of Segments (N): 2
    Segment 0 Duration (Dur0Units_actual): 200ms
    Segment 1 Duration: 50ms
    (Expected: 0x16=0200, 0x1E=C800 (200), based on refined rule val_0x1E = Dur0Units_actual when N>1 and Dur0 != 100)

```
0000:0000 | 50 52 03 49  4E 05 00 00  00 04 00 08  E8 03 50 49 | PR.IN.......è.PI
0000:0010 | 28 00 00 00  02 00 02 00  64 00 46 00  00 00 00 00 | (.......d.F.....
0000:0020 | 04 00 01 00  00 C8 00 00  00 00 00 64  00 72 01 00 | .....È.....d.r..
0000:0030 | 00 32 00 04  00 01 00 00  32 00 00 00  43 44 5C 02 | .2......2...CD\.
0000:0040 | 00 00 C8 00  00 00 FF 00  00 FF 00 00  FF 00 00 FF | ..È...ÿ..ÿ..ÿ..ÿ
```

### Test Q4: (N>1, Dur0Units_actual is NOT a multiple of 100)

    Number of Segments (N): 2
    Segment 0 Duration (Dur0Units_actual): 170ms (AA00)
    Segment 1 Duration: 50ms
    (Expected: 0x16=0100, 0x1E=AA00 (170), based on refined rule val_0x1E = Dur0Units_actual when N>1 and Dur0 != 100)

```
0000:0000 | 50 52 03 49  4E 05 00 00  00 04 00 08  E8 03 50 49 | PR.IN.......è.PI
0000:0010 | 28 00 00 00  02 00 01 00  64 00 46 00  00 00 46 00 | (.......d.F...F.
0000:0020 | 04 00 01 00  00 AA 00 00  00 00 00 64  00 72 01 00 | .....ª.....d.r..
0000:0030 | 00 32 00 04  00 01 00 00  32 00 00 00  43 44 5C 02 | .2......2...CD\.
0000:0040 | 00 00 C8 00  00 00 FF 00  00 FF 00 00  FF 00 00 FF | ..È...ÿ..ÿ..ÿ..ÿ
```

### Test R1:

    Segment 0 Duration: 50ms
    Segment 1 Duration: 50ms
    Segment 2 Duration: 1929ms (8907)
    (Expected Field[+0x11] for Block 1: 8907 (1929))

```
0000:0000 | 50 52 03 49  4E 05 00 00  00 04 00 08  E8 03 50 49 | PR.IN.......è.PI
0000:0010 | 3B 00 00 00  03 00 00 00  64 00 59 00  00 00 32 00 | ;.......d.Y...2.
0000:0020 | 04 00 01 00  00 32 00 00  00 00 00 64  00 85 01 00 | .....2.....d....
0000:0030 | 00 32 00 04  00 01 00 00  32 00 00 00  13 00 64 00 | .2......2.....d.
0000:0040 | B1 02 00 00  1D 00 04 00  01 00 00 89  07 00 00 43 | ±..............C
0000:0050 | 44 88 03 00  00 2C 01 00  00 FF 00 00  FF 00 00 FF | D....,...ÿ..ÿ..ÿ
```

### Test R2: (This is a repeat of J1/Test A's relevant part, for specific re-confirmation alongside boundary tests)

    Segment 0 Duration: 50ms
    Segment 1 Duration: 50ms
    Segment 2 Duration: 1930ms (8A07)
    (Expected Field[+0x11] for Block 1: 1E00 (30))

```
0000:0000 | 50 52 03 49  4E 05 00 00  00 04 00 08  E8 03 50 49 | PR.IN.......è.PI
0000:0010 | 3B 00 00 00  03 00 00 00  64 00 59 00  00 00 32 00 | ;.......d.Y...2.
0000:0020 | 04 00 01 00  00 32 00 00  00 00 00 64  00 85 01 00 | .....2.....d....
0000:0030 | 00 32 00 04  00 01 00 00  32 00 00 00  13 00 64 00 | .2......2.....d.
0000:0040 | B1 02 00 00  1E 00 04 00  01 00 00 8A  07 00 00 43 | ±..............C
0000:0050 | 44 88 03 00  00 2C 01 00  00 FF 00 00  FF 00 00 FF | D....,...ÿ..ÿ..ÿ
```

### Test R3:

    Segment 0 Duration: 50ms
    Segment 1 Duration: 50ms
    Segment 2 Duration: 1931ms (8B07)
    (Expected Field[+0x11] for Block 1: 8B07 (1931))

```
0000:0000 | 50 52 03 49  4E 05 00 00  00 04 00 08  E8 03 50 49 | PR.IN.......è.PI
0000:0010 | 3B 00 00 00  03 00 00 00  64 00 59 00  00 00 32 00 | ;.......d.Y...2.
0000:0020 | 04 00 01 00  00 32 00 00  00 00 00 64  00 85 01 00 | .....2.....d....
0000:0030 | 00 32 00 04  00 01 00 00  32 00 00 00  13 00 64 00 | .2......2.....d.
0000:0040 | B1 02 00 00  1F 00 04 00  01 00 00 8B  07 00 00 43 | ±..............C
0000:0050 | 44 88 03 00  00 2C 01 00  00 FF 00 00  FF 00 00 FF | D....,...ÿ..ÿ..ÿ
0000:0060 | 00 00 FF 00  00 FF 00 00  FF 00 00 FF  00 00 FF 00 | ..ÿ..ÿ..ÿ..ÿ..ÿ.
```
---

## Additional Test Series (S, T, U, V) - 1000Hz Refresh Rate

**Date:** 2025-06-02 (following M-R series)

These tests further investigate Header Field `0x1E` and Duration Block Field `+0x11` behaviors.

### Test S1:

    Segment 0 Duration (Dur0Units_actual): 350ms
    (If 0x1E = Dur0 % 100: expect 50. If behavior similar to 300: expect 0. If behavior similar to 500: expect 350)
    Actually, since 350 is not a multiple of 100, this test should follow the val_0x1E_dec = Dur0Units_actual % NominalBase rule. Expect 0x1E = 50. This test serves as a control.

```
0000:0000 | 50 52 03 49  4E 05 00 00  00 04 00 08  E8 03 50 49 | PR.IN.......è.PI
0000:0010 | 15 00 00 00  01 00 03 00  64 00 33 00  00 00 32 00 | ........d.3...2.
0000:0020 | 04 00 01 00  00 5E 01 00  00 43 44 30  01 00 00 64 | .....^...CD0...d
0000:0030 | 00 00 00 FF  00 00 FF 00  00 FF 00 00  FF 00 00 FF | ...ÿ..ÿ..ÿ..ÿ..ÿ
```

### Test S2:

    Segment 0 Duration (Dur0Units_actual): 400ms
    (Goal: If 0x1E = 0 for multiples <= 300, and 0x1E = Dur0 for 500, what about 400? Is it 0 or 400?)

```
0000:0000 | 50 52 03 49  4E 05 00 00  00 04 00 08  E8 03 50 49 | PR.IN.......è.PI
0000:0010 | 15 00 00 00  01 00 04 00  64 00 33 00  00 00 00 00 | ........d.3.....
0000:0020 | 04 00 01 00  00 90 01 00  00 43 44 30  01 00 00 64 | .........CD0...d
0000:0030 | 00 00 00 FF  00 00 FF 00  00 FF 00 00  FF 00 00 FF | ...ÿ..ÿ..ÿ..ÿ..ÿ
```

### Test S3:

    Segment 0 Duration (Dur0Units_actual): 450ms
    (Control, expect 0x1E = 50)

```
0000:0000 | 50 52 03 49  4E 05 00 00  00 04 00 08  E8 03 50 49 | PR.IN.......è.PI
0000:0010 | 15 00 00 00  01 00 04 00  64 00 33 00  00 00 32 00 | ........d.3...2.
0000:0020 | 04 00 01 00  00 C2 01 00  00 43 44 30  01 00 00 64 | .....Â...CD0...d
0000:0030 | 00 00 00 FF  00 00 FF 00  00 FF 00 00  FF 00 00 FF | ...ÿ..ÿ..ÿ..ÿ..ÿ
```

### Test T1:

    Segment 2 Duration (Dur_k+1): 120ms
    (Is it 20 or 120? Compare with original Test C where Dur_k+1=120 gave 120)
    (Test T1-T6 have common Seg0=50ms, Seg1=50ms)

```
0000:0000 | 50 52 03 49  4E 05 00 00  00 04 00 08  E8 03 50 49 | PR.IN.......è.PI
0000:0010 | 3B 00 00 00  03 00 00 00  64 00 59 00  00 00 32 00 | ;.......d.Y...2.
0000:0020 | 04 00 01 00  00 32 00 00  00 00 00 64  00 85 01 00 | .....2.....d....
0000:0030 | 00 32 00 04  00 01 00 00  32 00 00 00  01 00 64 00 | .2......2.....d.
0000:0040 | B1 02 00 00  14 00 04 00  01 00 00 78  00 00 00 43 | ±..........x...C
0000:0050 | 44 88 03 00  00 2C 01 00  00 FF 00 00  FF 00 00 FF | D....,...ÿ..ÿ..ÿ
```

### Test T2:

    Segment 2 Duration (Dur_k+1): 140ms
    (Is it 40 or 140?)

```
0000:0000 | 50 52 03 49  4E 05 00 00  00 04 00 08  E8 03 50 49 | PR.IN.......è.PI
0000:0010 | 3B 00 00 00  03 00 00 00  64 00 59 00  00 00 32 00 | ;.......d.Y...2.
0000:0020 | 04 00 01 00  00 32 00 00  00 00 00 64  00 85 01 00 | .....2.....d....
0000:0030 | 00 32 00 04  00 01 00 00  32 00 00 00  01 00 64 00 | .2......2.....d.
0000:0040 | B1 02 00 00  28 00 04 00  01 00 00 8C  00 00 00 43 | ±...(..........C
0000:0050 | 44 88 03 00  00 2C 01 00  00 FF 00 00  FF 00 00 FF | D....,...ÿ..ÿ..ÿ
```

### Test T3:

    Segment 2 Duration (Dur_k+1): 148ms
    (Is it 48 or 148?)

```
0000:0000 | 50 52 03 49  4E 05 00 00  00 04 00 08  E8 03 50 49 | PR.IN.......è.PI
0000:0010 | 3B 00 00 00  03 00 00 00  64 00 59 00  00 00 32 00 | ;.......d.Y...2.
0000:0020 | 04 00 01 00  00 32 00 00  00 00 00 64  00 85 01 00 | .....2.....d....
0000:0030 | 00 32 00 04  00 01 00 00  32 00 00 00  01 00 64 00 | .2......2.....d.
0000:0040 | B1 02 00 00  30 00 04 00  01 00 00 94  00 00 00 43 | ±...0..........C
0000:0050 | 44 88 03 00  00 2C 01 00  00 FF 00 00  FF 00 00 FF | D....,...ÿ..ÿ..ÿ
```

### Test T4:

    Segment 2 Duration (Dur_k+1): 149ms
    (Is it 49 or 149?)

```
0000:0000 | 50 52 03 49  4E 05 00 00  00 04 00 08  E8 03 50 49 | PR.IN.......è.PI
0000:0010 | 3B 00 00 00  03 00 00 00  64 00 59 00  00 00 32 00 | ;.......d.Y...2.
0000:0020 | 04 00 01 00  00 32 00 00  00 00 00 64  00 85 01 00 | .....2.....d....
0000:0030 | 00 32 00 04  00 01 00 00  32 00 00 00  01 00 64 00 | .2......2.....d.
0000:0040 | B1 02 00 00  31 00 04 00  01 00 00 95  00 00 00 43 | ±...1..........C
0000:0050 | 44 88 03 00  00 2C 01 00  00 FF 00 00  FF 00 00 FF | D....,...ÿ..ÿ..ÿ
```

### Test T5: (This is a repeat of Test H3 for context, where Dur_k+1 was 150 and Field[+0x11] was 150)

    Segment 2 Duration (Dur_k+1): 150ms
    (Expect 150)

```
0000:0000 | 50 52 03 49  4E 05 00 00  00 04 00 08  E8 03 50 49 | PR.IN.......è.PI
0000:0010 | 3B 00 00 00  03 00 00 00  64 00 59 00  00 00 32 00 | ;.......d.Y...2.
0000:0020 | 04 00 01 00  00 32 00 00  00 00 00 64  00 85 01 00 | .....2.....d....
0000:0030 | 00 32 00 04  00 01 00 00  32 00 00 00  01 00 64 00 | .2......2.....d.
0000:0040 | B1 02 00 00  32 00 04 00  01 00 00 96  00 00 00 43 | ±...2..........C
0000:0050 | 44 88 03 00  00 2C 01 00  00 FF 00 00  FF 00 00 FF | D....,...ÿ..ÿ..ÿ
```

### Test T6:

    Segment 2 Duration (Dur_k+1): 151ms
    (Is it 51 or 151?)

```
0000:0000 | 50 52 03 49  4E 05 00 00  00 04 00 08  E8 03 50 49 | PR.IN.......è.PI
0000:0010 | 3B 00 00 00  03 00 00 00  64 00 59 00  00 00 32 00 | ;.......d.Y...2.
0000:0020 | 04 00 01 00  00 32 00 00  00 00 00 64  00 85 01 00 | .....2.....d....
0000:0030 | 00 32 00 04  00 01 00 00  32 00 00 00  01 00 64 00 | .2......2.....d.
0000:0040 | B1 02 00 00  33 00 04 00  01 00 00 97  00 00 00 43 | ±...3..........C
0000:0050 | 44 88 03 00  00 2C 01 00  00 FF 00 00  FF 00 00 FF | D....,...ÿ..ÿ..ÿ
```

### Test U1:

    Segment 2 Duration (Dur_k+1): 400ms
    (Is it 0 or 400? Test A had Dur1=470, where Field[+0x11] was 470, not 0 or 70)
    (Test U1-U3 have common Seg0=50ms, Seg1=50ms)

```
0000:0000 | 50 52 03 49  4E 05 00 00  00 04 00 08  E8 03 50 49 | PR.IN.......è.PI
0000:0010 | 3B 00 00 00  03 00 00 00  64 00 59 00  00 00 32 00 | ;.......d.Y...2.
0000:0020 | 04 00 01 00  00 32 00 00  00 00 00 64  00 85 01 00 | .....2.....d....
0000:0030 | 00 32 00 04  00 01 00 00  32 00 00 00  04 00 64 00 | .2......2.....d.
0000:0040 | B1 02 00 00  00 00 04 00  01 00 00 90  01 00 00 43 | ±..............C
0000:0050 | 44 88 03 00  00 2C 01 00  00 FF 00 00  FF 00 00 FF | D....,...ÿ..ÿ..ÿ
```

### Test U2:

    Segment 2 Duration (Dur_k+1): 500ms
    (Is it 0 or 500?)

```
0000:0000 | 50 52 03 49  4E 05 00 00  00 04 00 08  E8 03 50 49 | PR.IN.......è.PI
0000:0010 | 3B 00 00 00  03 00 00 00  64 00 59 00  00 00 32 00 | ;.......d.Y...2.
0000:0020 | 04 00 01 00  00 32 00 00  00 00 00 64  00 85 01 00 | .....2.....d....
0000:0030 | 00 32 00 04  00 01 00 00  32 00 00 00  05 00 64 00 | .2......2.....d.
0000:0040 | B1 02 00 00  00 00 04 00  01 00 00 F4  01 00 00 43 | ±..........ô...C
0000:0050 | 44 88 03 00  00 2C 01 00  00 FF 00 00  FF 00 00 FF | D....,...ÿ..ÿ..ÿ
```

### Test U3:

    Segment 2 Duration (Dur_k+1): 1000ms
    (Is it 0 or 1000? Test L6 had Dur1=1000 -> Field[+0x11]=1000)

```
0000:0000 | 50 52 03 49  4E 05 00 00  00 04 00 08  E8 03 50 49 | PR.IN.......è.PI
0000:0010 | 3B 00 00 00  03 00 00 00  64 00 59 00  00 00 32 00 | ;.......d.Y...2.
0000:0020 | 04 00 01 00  00 32 00 00  00 00 00 64  00 85 01 00 | .....2.....d....
0000:0030 | 00 32 00 04  00 01 00 00  32 00 00 00  0A 00 64 00 | .2......2.....d.
0000:0040 | B1 02 00 00  00 00 04 00  01 00 00 E8  03 00 00 43 | ±..........è...C
0000:0050 | 44 88 03 00  00 2C 01 00  00 FF 00 00  FF 00 00 FF | D....,...ÿ..ÿ..ÿ
```

### Test V1:

    Segment 2 Duration (Dur_k+1): 301ms
    (Is it 1 or 301?)
    (Test V1-V7 have common Seg0=50ms, Seg1=50ms)

```
0000:0000 | 50 52 03 49  4E 05 00 00  00 04 00 08  E8 03 50 49 | PR.IN.......è.PI
0000:0010 | 3B 00 00 00  03 00 00 00  64 00 59 00  00 00 32 00 | ;.......d.Y...2.
0000:0020 | 04 00 01 00  00 32 00 00  00 00 00 64  00 85 01 00 | .....2.....d....
0000:0030 | 00 32 00 04  00 01 00 00  32 00 00 00  03 00 64 00 | .2......2.....d.
0000:0040 | B1 02 00 00  01 00 04 00  01 00 00 2D  01 00 00 43 | ±..........-...C
0000:0050 | 44 88 03 00  00 2C 01 00  00 FF 00 00  FF 00 00 FF | D....,...ÿ..ÿ..ÿ
```

### Test V2:

    Segment 2 Duration (Dur_k+1): 349ms
    (Is it 49 or 349?)

```
0000:0000 | 50 52 03 49  4E 05 00 00  00 04 00 08  E8 03 50 49 | PR.IN.......è.PI
0000:0010 | 3B 00 00 00  03 00 00 00  64 00 59 00  00 00 32 00 | ;.......d.Y...2.
0000:0020 | 04 00 01 00  00 32 00 00  00 00 00 64  00 85 01 00 | .....2.....d....
0000:0030 | 00 32 00 04  00 01 00 00  32 00 00 00  03 00 64 00 | .2......2.....d.
0000:0040 | B1 02 00 00  31 00 04 00  01 00 00 5D  01 00 00 43 | ±...1......]...C
0000:0050 | 44 88 03 00  00 2C 01 00  00 FF 00 00  FF 00 00 FF | D....,...ÿ..ÿ..ÿ
```

### Test V3:

    Segment 2 Duration (Dur_k+1): 350ms
    (Is it 50 or 350?)

```
0000:0000 | 50 52 03 49  4E 05 00 00  00 04 00 08  E8 03 50 49 | PR.IN.......è.PI
0000:0010 | 3B 00 00 00  03 00 00 00  64 00 59 00  00 00 32 00 | ;.......d.Y...2.
0000:0020 | 04 00 01 00  00 32 00 00  00 00 00 64  00 85 01 00 | .....2.....d....
0000:0030 | 00 32 00 04  00 01 00 00  32 00 00 00  03 00 64 00 | .2......2.....d.
0000:0040 | B1 02 00 00  32 00 04 00  01 00 00 5E  01 00 00 43 | ±...2......^...C
0000:0050 | 44 88 03 00  00 2C 01 00  00 FF 00 00  FF 00 00 FF | D....,...ÿ..ÿ..ÿ
```
---

## Duration Block `+0x11` Interaction Tests (DB_11 Series) - 1000Hz

**Date:** 2025-06-02

These tests investigate the interaction of `Dur_k` (current segment duration) and `Dur_k+1` (next segment duration) on the value of `Field[+0x11]` for `Block k`. All tests are N=3 segments, 1000Hz PRG refresh rate. Seg0 is fixed at 50ms. The focus is on `Field[+0x11]` in Block 1, which describes Seg1 and looks ahead to Seg2.

Colors for all segments are FF0000 (Red), 00FF00 (Green), 0000FF (Blue) cycling, 4 pixels.
Header values are common: `0x0C=E803` (1000Hz), `0x14=0300` (N=3), `0x10=3B00` (Pointer1 for N=3), `0x1A=5900` (RGB offset for N=3).
`Dur0` (Seg0 duration) = 50ms. So, `Header[0x16]=0000` (0), `Header[0x1E]=3200` (50).

Common structure for Duration Blocks (Block 0 for Seg0, Block 1 for Seg1, Block 2 for Seg2):
*   Block 0 (`offset 0x20`): `PixelCount=0400`, `Const02=010000`, `CurrentDur(Seg0)=3200`(50ms), `Const07=0000`. `Field[+0x09].part2=6400`. `Index1Value=8501`.
*   Block 2 (Last Block, `offset 0x46`): `PixelCount=0400`, `Const02=010000`, `CurrentDur(Seg2)=variable`, `Const07=0000`, `LastBlockConst09=4344`, `Index2Part1=variable`, `LastBlockConst0D=0000`, `Index2Part2=variable`, `LastBlockConst11=0000`.

### Series DB_11_A: `Dur_k+1` (Seg2 Duration) = 150ms (`96 00`)

*   Seg0=50ms, Seg1=`Dur_k` (variable), Seg2=150ms.
*   Focus on Block 1 `Field[+0x11]` (for Seg1, looking at Seg2's 150ms duration).
*   `Field[+0x09].part1` for Block 0 (looking at Seg1) is `floor(Dur_k/100)`.
*   `Field[+0x09].part1` for Block 1 (looking at Seg2=150ms) is `floor(150/100) = 0100` (1).

#### Test DB_11_A1: `Dur_k` (Seg1 Duration) = 70ms (`46 00`)
*   Block 0 `Field[+0x09].part1` (for Seg1=70ms): `0000` (0). `Field[+0x11]` (for Seg1=70ms): `4600` (70).
*   Block 1 (Seg1 Duration = 70ms): `CurrentDur=4600`. `Field[+0x09].part1=0100`.
*   Block 1 `Field[+0x11]` (for Seg2=150ms): `3200` (50) -> `150 % 100`.
```
0000:0000 | 50 52 03 49  4E 05 00 00  00 04 00 08  E8 03 50 49 | PR.IN.......è.PI
0000:0010 | 3B 00 00 00  03 00 00 00  64 00 59 00  00 00 32 00 | ;.......d.Y...2.
0000:0020 | 04 00 01 00  00 32 00 00  00 00 00 64  00 85 01 00 | .....2.....d....
0000:0030 | 00 46 00 04  00 01 00 00  46 00 00 00  01 00 64 00 | .F......F.....d.
0000:0040 | B1 02 00 00  32 00 04 00  01 00 00 96  00 00 00 43 | ±...2..........C
0000:0050 | 44 88 03 00  00 2C 01 00  00 FF 00 00  FF 00 00 FF | D....,...ÿ..ÿ..ÿ
```

#### Test DB_11_A2: `Dur_k` (Seg1 Duration) = 99ms (`63 00`)
*   Block 0 `Field[+0x09].part1` (for Seg1=99ms): `0000` (0). `Field[+0x11]` (for Seg1=99ms): `6300` (99).
*   Block 1 (Seg1 Duration = 99ms): `CurrentDur=6300`. `Field[+0x09].part1=0100`.
*   Block 1 `Field[+0x11]` (for Seg2=150ms): `3200` (50) -> `150 % 100`.
```
0000:0000 | 50 52 03 49  4E 05 00 00  00 04 00 08  E8 03 50 49 | PR.IN.......è.PI
0000:0010 | 3B 00 00 00  03 00 00 00  64 00 59 00  00 00 32 00 | ;.......d.Y...2.
0000:0020 | 04 00 01 00  00 32 00 00  00 00 00 64  00 85 01 00 | .....2.....d....
0000:0030 | 00 63 00 04  00 01 00 00  63 00 00 00  01 00 64 00 | .c......c.....d.
0000:0040 | B1 02 00 00  32 00 04 00  01 00 00 96  00 00 00 43 | ±...2..........C
0000:0050 | 44 88 03 00  00 2C 01 00  00 FF 00 00  FF 00 00 FF | D....,...ÿ..ÿ..ÿ
```

#### Test DB_11_A3: `Dur_k` (Seg1 Duration) = 101ms (`65 00`)
*   Block 0 `Field[+0x09].part1` (for Seg1=101ms): `0100` (1). `Field[+0x11]` (for Seg1=101ms): `6500` (101).
*   Block 1 (Seg1 Duration = 101ms): `CurrentDur=6500`. `Field[+0x09].part1=0100`.
*   Block 1 `Field[+0x11]` (for Seg2=150ms): `9600` (150) -> Direct passthrough.
```
0000:0000 | 50 52 03 49  4E 05 00 00  00 04 00 08  E8 03 50 49 | PR.IN.......è.PI
0000:0010 | 3B 00 00 00  03 00 00 00  64 00 59 00  00 00 32 00 | ;.......d.Y...2.
0000:0020 | 04 00 01 00  00 32 00 00  00 01 00 64  00 85 01 00 | .....2.....d....
0000:0030 | 00 01 00 04  00 01 00 00  65 00 00 00  01 00 64 00 | ........e.....d.
0000:0040 | B1 02 00 00  32 00 04 00  01 00 00 96  00 00 00 43 | ±...2..........C
0000:0050 | 44 88 03 00  00 2C 01 00  00 FF 00 00  FF 00 00 FF | D....,...ÿ..ÿ..ÿ
```
*   Correction: Block 1 `Field[+0x11]` for DB_11_A3 should be `9600` (150) according to the hex dump (offset `0x40` value `3200` is for color data intro). The dump at `0x46+0x11 = 0x57` is `96 00`. This needs careful parsing.
*   Re-parsing DB_11_A3, Block 1 (starts `0x33`): `Dur_k=101` (`6500` at `0x33+5`). `Field[+0x11]` (at `0x33+17=0x44`) is `9600` (150). This is Direct Passthrough.

#### Test DB_11_A4: `Dur_k` (Seg1 Duration) = 140ms (`8C 00`)
*   Block 0 `Field[+0x09].part1` (for Seg1=140ms): `0100` (1). `Field[+0x11]` (for Seg1=140ms): `8C00` (140).
*   Block 1 (Seg1 Duration = 140ms): `CurrentDur=8C00`. `Field[+0x09].part1=0100`.
*   Block 1 `Field[+0x11]` (for Seg2=150ms, at `0x33+17=0x44`): `9600` (150) -> Direct passthrough.
```
0000:0000 | 50 52 03 49  4E 05 00 00  00 04 00 08  E8 03 50 49 | PR.IN.......è.PI
0000:0010 | 3B 00 00 00  03 00 00 00  64 00 59 00  00 00 32 00 | ;.......d.Y...2.
0000:0020 | 04 00 01 00  00 32 00 00  00 01 00 64  00 85 01 00 | .....2.....d....
0000:0030 | 00 28 00 04  00 01 00 00  8C 00 00 00  01 00 64 00 | .(............d.
0000:0040 | B1 02 00 00  32 00 04 00  01 00 00 96  00 00 00 43 | ±...2..........C
0000:0050 | 44 88 03 00  00 2C 01 00  00 FF 00 00  FF 00 00 FF | D....,...ÿ..ÿ..ÿ
```
*   Re-parsing DB_11_A4, Block 1 (starts `0x33`): `Dur_k=140` (`8C00` at `0x33+5`). `Field[+0x11]` (at `0x33+17=0x44`) is `9600` (150). This is Direct Passthrough.

#### Test DB_11_A5: `Dur_k` (Seg1 Duration) = 150ms (`96 00`)
*   Block 0 `Field[+0x09].part1` (for Seg1=150ms): `0100` (1). `Field[+0x11]` (for Seg1=150ms): `9600` (150).
*   Block 1 (Seg1 Duration = 150ms): `CurrentDur=9600`. `Field[+0x09].part1=0100`.
*   Block 1 `Field[+0x11]` (for Seg2=150ms, at `0x33+17=0x44`): `9600` (150) -> Direct passthrough.
```
0000:0000 | 50 52 03 49  4E 05 00 00  00 04 00 08  E8 03 50 49 | PR.IN.......è.PI
0000:0010 | 3B 00 00 00  03 00 00 00  64 00 59 00  00 00 32 00 | ;.......d.Y...2.
0000:0020 | 04 00 01 00  00 32 00 00  00 01 00 64  00 85 01 00 | .....2.....d....
0000:0030 | 00 32 00 04  00 01 00 00  96 00 00 00  01 00 64 00 | .2............d.
0000:0040 | B1 02 00 00  32 00 04 00  01 00 00 96  00 00 00 43 | ±...2..........C
0000:0050 | 44 88 03 00  00 2C 01 00  00 FF 00 00  FF 00 00 FF | D....,...ÿ..ÿ..ÿ
```
*   Re-parsing DB_11_A5, Block 1 (starts `0x33`): `Dur_k=150` (`9600` at `0x33+5`). `Field[+0x11]` (at `0x33+17=0x44`) is `9600` (150). This is Direct Passthrough.

*Summary for DB_11_A (Dur_k+1 = 150ms):*
*   Dur_k=50 (T5): `+0x11 = 50` (`150 % 100`)
*   Dur_k=70 (A1): `+0x11 = 50` (`150 % 100`)
*   Dur_k=99 (A2): `+0x11 = 50` (`150 % 100`)
*   Dur_k=100 (H3): `+0x11 = 150` (Direct Passthrough)
*   Dur_k=101 (A3): `+0x11 = 150` (Direct Passthrough)
*   Dur_k=140 (A4): `+0x11 = 150` (Direct Passthrough)
*   Dur_k=150 (A5): `+0x11 = 150` (Direct Passthrough)
This suggests that if `Dur_k+1 > 100` and not an override: if `Dur_k >= 100`, `Field[+0x11] = Dur_k+1`. If `Dur_k < 100`, `Field[+0x11] = Dur_k+1 % 100`.

### Series DB_11_B: `Dur_k+1` (Seg2 Duration) = 600ms (`58 02`)

*   Seg0=50ms, Seg1=`Dur_k` (variable), Seg2=600ms.
*   Focus on Block 1 `Field[+0x11]` (for Seg1, looking at Seg2's 600ms duration).
*   `Field[+0x09].part1` for Block 1 (looking at Seg2=600ms) is `floor(600/100) = 0600` (6).

#### Test DB_11_B1: `Dur_k` (Seg1 Duration) = 100ms (`64 00`)
*   Block 0 `Field[+0x09].part1` (for Seg1=100ms): `0100` (1). `Field[+0x11]` (for Seg1=100ms): `0000` (0).
*   Block 1 (Seg1 Duration = 100ms): `CurrentDur=6400`. `Field[+0x09].part1=0600`.
*   Block 1 `Field[+0x11]` (for Seg2=600ms, at `0x33+17=0x44`): `0000` (0).
```
0000:0000 | 50 52 03 49  4E 05 00 00  00 04 00 08  E8 03 50 49 | PR.IN.......è.PI
0000:0010 | 3B 00 00 00  03 00 00 00  64 00 59 00  00 00 32 00 | ;.......d.Y...2.
0000:0020 | 04 00 01 00  00 32 00 00  00 01 00 64  00 85 01 00 | .....2.....d....
0000:0030 | 00 00 00 04  00 01 00 00  64 00 00 00  06 00 64 00 | ........d.....d.
0000:0040 | B1 02 00 00  00 00 04 00  01 00 00 58  02 00 00 43 | ±..........X...C
0000:0050 | 44 88 03 00  00 2C 01 00  00 FF 00 00  FF 00 00 FF | D....,...ÿ..ÿ..ÿ
```

#### Test DB_11_B2: `Dur_k` (Seg1 Duration) = 200ms (`C8 00`)
*   Block 0 `Field[+0x09].part1` (Seg1=200ms): `0200`(2). `Field[+0x11]` (Seg1=200ms): `0000`(0).
*   Block 1 (Seg1 Duration = 200ms): `CurrentDur=C800`. `Field[+0x09].part1=0600`.
*   Block 1 `Field[+0x11]` (for Seg2=600ms, at `0x33+17=0x44`): `0000` (0).
```
0000:0000 | 50 52 03 49  4E 05 00 00  00 04 00 08  E8 03 50 49 | PR.IN.......è.PI
0000:0010 | 3B 00 00 00  03 00 00 00  64 00 59 00  00 00 32 00 | ;.......d.Y...2.
0000:0020 | 04 00 01 00  00 32 00 00  00 02 00 64  00 85 01 00 | .....2.....d....
0000:0030 | 00 00 00 04  00 01 00 00  C8 00 00 00  06 00 64 00 | ........È.....d.
0000:0040 | B1 02 00 00  00 00 04 00  01 00 00 58  02 00 00 43 | ±..........X...C
0000:0050 | 44 88 03 00  00 2C 01 00  00 FF 00 00  FF 00 00 FF | D....,...ÿ..ÿ..ÿ
```

#### Test DB_11_B3: `Dur_k` (Seg1 Duration) = 500ms (`F4 01`)
*   Block 0 `Field[+0x09].part1` (Seg1=500ms): `0500`(5). `Field[+0x11]` (Seg1=500ms): `0000`(0).
*   Block 1 (Seg1 Duration = 500ms): `CurrentDur=F401`. `Field[+0x09].part1=0600`.
*   Block 1 `Field[+0x11]` (for Seg2=600ms, at `0x33+17=0x44`): `0000` (0).
```
0000:0000 | 50 52 03 49  4E 05 00 00  00 04 00 08  E8 03 50 49 | PR.IN.......è.PI
0000:0010 | 3B 00 00 00  03 00 00 00  64 00 59 00  00 00 32 00 | ;.......d.Y...2.
0000:0020 | 04 00 01 00  00 32 00 00  00 05 00 64  00 85 01 00 | .....2.....d....
0000:0030 | 00 00 00 04  00 01 00 00  F4 01 00 00  06 00 64 00 | ........ô.....d.
0000:0040 | B1 02 00 00  00 00 04 00  01 00 00 58  02 00 00 43 | ±..........X...C
0000:0050 | 44 88 03 00  00 2C 01 00  00 FF 00 00  FF 00 00 FF | D....,...ÿ..ÿ..ÿ
```

#### Test DB_11_B4: `Dur_k` (Seg1 Duration) = 600ms (`58 02`)
*   Block 0 `Field[+0x09].part1` (Seg1=600ms): `0600`(6). `Field[+0x11]` (Seg1=600ms): `0000`(0).
*   Block 1 (Seg1 Duration = 600ms): `CurrentDur=5802`. `Field[+0x09].part1=0600`.
*   Block 1 `Field[+0x11]` (for Seg2=600ms, at `0x33+17=0x44`): `5802` (600) -> Direct Passthrough.
```
0000:0000 | 50 52 03 49  4E 05 00 00  00 04 00 08  E8 03 50 49 | PR.IN.......è.PI
0000:0010 | 3B 00 00 00  03 00 00 00  64 00 59 00  00 00 32 00 | ;.......d.Y...2.
0000:0020 | 04 00 01 00  00 32 00 00  00 06 00 64  00 85 01 00 | .....2.....d....
0000:0030 | 00 00 00 04  00 01 00 00  58 02 00 00  06 00 64 00 | ........X.....d.
0000:0040 | B1 02 00 00  00 00 04 00  01 00 00 58  02 00 00 43 | ±..........X...C
```
*   Corrected: Block 1 `Field[+0x11]` for B4 (at `0x44`) is `5802` (600).

#### Test DB_11_B5: `Dur_k` (Seg1 Duration) = 999ms (`E7 03`)
*   Block 0 `Field[+0x09].part1` (Seg1=999ms): `0900`(9). `Field[+0x11]` (Seg1=999ms): `E703`(999).
*   Block 1 (Seg1 Duration = 999ms): `CurrentDur=E703`. `Field[+0x09].part1=0600`.
*   Block 1 `Field[+0x11]` (for Seg2=600ms, at `0x33+17=0x44`): `0000` (0).
```
0000:0000 | 50 52 03 49  4E 05 00 00  00 04 00 08  E8 03 50 49 | PR.IN.......è.PI
0000:0010 | 3B 00 00 00  03 00 00 00  64 00 59 00  00 00 32 00 | ;.......d.Y...2.
0000:0020 | 04 00 01 00  00 32 00 00  00 09 00 64  00 85 01 00 | .....2.....d....
0000:0030 | 00 63 00 04  00 01 00 00  E7 03 00 00  06 00 64 00 | .c......ç.....d.
0000:0040 | B1 02 00 00  00 00 04 00  01 00 00 58  02 00 00 43 | ±..........X...C
0000:0050 | 44 88 03 00  00 2C 01 00  00 FF 00 00  FF 00 00 FF | D....,...ÿ..ÿ..ÿ
```

*Summary for DB_11_B (Dur_k+1 = 600ms):*
*   Dur_k=50 (U-series reasoning): `+0x11 = 0`
*   Dur_k=100 (B1): `+0x11 = 0`
*   Dur_k=200 (B2): `+0x11 = 0`
*   Dur_k=500 (B3): `+0x11 = 0`
*   Dur_k=600 (B4): `+0x11 = 600` (Direct Passthrough)
*   Dur_k=999 (B5): `+0x11 = 0`
*   Dur_k=1000 (L5): `+0x11 = 600` (Direct Passthrough, although L5 was Dur_k+1=1930, Dur_k=1000, Field[+0x11]=600 is for Dur_k=1000, Dur_k-1=600) - *Recheck L5 context: L5 is Dur0=1k, Dur1=600, Dur2=1930. Block0 +0x11 (for Dur1=600) is 600. Block1 +0x11 (for Dur2=1930, with Dur_k=600) is 30 (anomaly).*
This implies for `Dur_k+1 % 100 == 0`: if `Dur_k == Dur_k+1`, `Field[+0x11] = Dur_k+1`. Otherwise, `Field[+0x11] = 0`.

### Series DB_11_C: `Dur_k+1` (Seg2 Duration) = 1000ms (`E8 03`)

*   Seg0=50ms, Seg1=`Dur_k` (variable), Seg2=1000ms.
*   Focus on Block 1 `Field[+0x11]` (for Seg1, looking at Seg2's 1000ms duration).
*   `Field[+0x09].part1` for Block 1 (looking at Seg2=1000ms) is `floor(1000/100) = 0A00` (10).

#### Test DB_11_C1: `Dur_k` (Seg1 Duration) = 100ms (`64 00`)
*   Block 0 `Field[+0x09].part1` (Seg1=100ms): `0100`(1). `Field[+0x11]` (Seg1=100ms): `0000`(0).
*   Block 1 (Seg1 Duration = 100ms): `CurrentDur=6400`. `Field[+0x09].part1=0A00`.
*   Block 1 `Field[+0x11]` (for Seg2=1000ms, at `0x33+17=0x44`): `0000` (0).
```
0000:0000 | 50 52 03 49  4E 05 00 00  00 04 00 08  E8 03 50 49 | PR.IN.......è.PI
0000:0010 | 3B 00 00 00  03 00 00 00  64 00 59 00  00 00 32 00 | ;.......d.Y...2.
0000:0020 | 04 00 01 00  00 32 00 00  00 01 00 64  00 85 01 00 | .....2.....d....
0000:0030 | 00 00 00 04  00 01 00 00  64 00 00 00  0A 00 64 00 | ........d.....d.
0000:0040 | B1 02 00 00  00 00 04 00  01 00 00 E8  03 00 00 43 | ±..........è...C
0000:0050 | 44 88 03 00  00 2C 01 00  00 FF 00 00  FF 00 00 FF | D....,...ÿ..ÿ..ÿ
```

#### Test DB_11_C2: `Dur_k` (Seg1 Duration) = 500ms (`F4 01`)
*   Block 0 `Field[+0x09].part1` (Seg1=500ms): `0500`(5). `Field[+0x11]` (Seg1=500ms): `0000`(0).
*   Block 1 (Seg1 Duration = 500ms): `CurrentDur=F401`. `Field[+0x09].part1=0A00`.
*   Block 1 `Field[+0x11]` (for Seg2=1000ms, at `0x33+17=0x44`): `0000` (0).
```
0000:0000 | 50 52 03 49  4E 05 00 00  00 04 00 08  E8 03 50 49 | PR.IN.......è.PI
0000:0010 | 3B 00 00 00  03 00 00 00  64 00 59 00  00 00 32 00 | ;.......d.Y...2.
0000:0020 | 04 00 01 00  00 32 00 00  00 05 00 64  00 85 01 00 | .....2.....d....
0000:0030 | 00 00 00 04  00 01 00 00  F4 01 00 00  0A 00 64 00 | ........ô.....d.
0000:0040 | B1 02 00 00  00 00 04 00  01 00 00 E8  03 00 00 43 | ±..........è...C
0000:0050 | 44 88 03 00  00 2C 01 00  00 FF 00 00  FF 00 00 FF | D....,...ÿ..ÿ..ÿ
```

#### Test DB_11_C3: `Dur_k` (Seg1 Duration) = 999ms (`E7 03`)
*   Block 0 `Field[+0x09].part1` (Seg1=999ms): `0900`(9). `Field[+0x11]` (Seg1=999ms): `E703`(999).
*   Block 1 (Seg1 Duration = 999ms): `CurrentDur=E703`. `Field[+0x09].part1=0A00`.
*   Block 1 `Field[+0x11]` (for Seg2=1000ms, at `0x33+17=0x44`): `0000` (0).
```
0000:0000 | 50 52 03 49  4E 05 00 00  00 04 00 08  E8 03 50 49 | PR.IN.......è.PI
0000:0010 | 3B 00 00 00  03 00 00 00  64 00 59 00  00 00 32 00 | ;.......d.Y...2.
0000:0020 | 04 00 01 00  00 32 00 00  00 09 00 64  00 85 01 00 | .....2.....d....
0000:0030 | 00 63 00 04  00 01 00 00  E7 03 00 00  0A 00 64 00 | .c......ç.....d.
0000:0040 | B1 02 00 00  00 00 04 00  01 00 00 E8  03 00 00 43 | ±..........è...C
0000:0050 | 44 88 03 00  00 2C 01 00  00 FF 00 00  FF 00 00 FF | D....,...ÿ..ÿ..ÿ
```

*Summary for DB_11_C (Dur_k+1 = 1000ms):*
*   Dur_k=50 (U3): `+0x11 = 0`
*   Dur_k=100 (C1): `+0x11 = 0`
*   Dur_k=500 (C2): `+0x11 = 0`
*   Dur_k=999 (C3): `+0x11 = 0`
*   Dur_k=1000 (L6): `+0x11 = 1000` (Direct Passthrough)
This again supports for `Dur_k+1 % 100 == 0`: if `Dur_k == Dur_k+1`, `Field[+0x11] = Dur_k+1`. Otherwise, `Field[+0x11] = 0`.

---

### Test V4:

    Segment 2 Duration (Dur_k+1): 351ms
    (Is it 51 or 351?)

```
0000:0000 | 50 52 03 49  4E 05 00 00  00 04 00 08  E8 03 50 49 | PR.IN.......è.PI
0000:0010 | 3B 00 00 00  03 00 00 00  64 00 59 00  00 00 32 00 | ;.......d.Y...2.
0000:0020 | 04 00 01 00  00 32 00 00  00 00 00 64  00 85 01 00 | .....2.....d....
0000:0030 | 00 32 00 04  00 01 00 00  32 00 00 00  03 00 64 00 | .2......2.....d.
0000:0040 | B1 02 00 00  33 00 04 00  01 00 00 5F  01 00 00 43 | ±...3......_...C
0000:0050 | 44 88 03 00  00 2C 01 00  00 FF 00 00  FF 00 00 FF | D....,...ÿ..ÿ..ÿ
```

### Test V5:

    Segment 2 Duration (Dur_k+1): 399ms
    (Is it 99 or 399?)

```
0000:0000 | 50 52 03 49  4E 05 00 00  00 04 00 08  E8 03 50 49 | PR.IN.......è.PI
0000:0010 | 3B 00 00 00  03 00 00 00  64 00 59 00  00 00 32 00 | ;.......d.Y...2.
0000:0020 | 04 00 01 00  00 32 00 00  00 00 00 64  00 85 01 00 | .....2.....d....
0000:0030 | 00 32 00 04  00 01 00 00  32 00 00 00  03 00 64 00 | .2......2.....d.
0000:0040 | B1 02 00 00  63 00 04 00  01 00 00 8F  01 00 00 43 | ±...c..........C
0000:0050 | 44 88 03 00  00 2C 01 00  00 FF 00 00  FF 00 00 FF | D....,...ÿ..ÿ..ÿ
```

### Test V6: (This is Test U1 again, placed here for context of this range)

    Segment 2 Duration (Dur_k+1): 400ms
    (Is it 0 or 400?)

```
0000:0000 | 50 52 03 49  4E 05 00 00  00 04 00 08  E8 03 50 49 | PR.IN.......è.PI
0000:0010 | 3B 00 00 00  03 00 00 00  64 00 59 00  00 00 32 00 | ;.......d.Y...2.
0000:0020 | 04 00 01 00  00 32 00 00  00 00 00 64  00 85 01 00 | .....2.....d....
0000:0030 | 00 32 00 04  00 01 00 00  32 00 00 00  04 00 64 00 | .2......2.....d.
0000:0040 | B1 02 00 00  00 00 04 00  01 00 00 90  01 00 00 43 | ±..............C
0000:0050 | 44 88 03 00  00 2C 01 00  00 FF 00 00  FF 00 00 FF | D....,...ÿ..ÿ..ÿ
```

### Test V7:

    Segment 2 Duration (Dur_k+1): 401ms
    (Is it 1 or 401?)

```
0000:0000 | 50 52 03 49  4E 05 00 00  00 04 00 08  E8 03 50 49 | PR.IN.......è.PI
0000:0010 | 3B 00 00 00  03 00 00 00  64 00 59 00  00 00 32 00 | ;.......d.Y...2.
0000:0020 | 04 00 01 00  00 32 00 00  00 00 00 64  00 85 01 00 | .....2.....d....
0000:0030 | 00 32 00 04  00 01 00 00  32 00 00 00  04 00 64 00 | .2......2.....d.
0000:0040 | B1 02 00 00  01 00 04 00  01 00 00 91  01 00 00 43 | ±..............C
0000:0050 | 44 88 03 00  00 2C 01 00  00 FF 00 00  FF 00 00 FF | D....,...ÿ..ÿ..ÿ
0000:0060 | 00 00 FF 00  00 FF 00 00  FF 00 00 FF  00 00 FF 00 | ..ÿ..ÿ..ÿ..ÿ..ÿ.
```