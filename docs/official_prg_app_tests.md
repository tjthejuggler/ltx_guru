# Official LTX App PRG File Test Dumps and Analysis

**Last Updated:** 2025-06-01 13:52 UTC+7

This document records hex dumps from `.prg` files generated by the official LTX application. These serve as a ground truth for reverse-engineering and validating the PRG file format, especially for conditional header fields.

All examples below were generated with a 4-pixel setting and a 1Hz refresh rate, unless otherwise specified.

## Single Segment, 1Hz Refresh Rate Examples

These examples show how header fields `0x16` and `0x1E` behave for single-segment files with varying durations at a 1Hz PRG refresh rate.

**Common Header Values for N=1, 1Hz Refresh Rate, 4px:**
*   `0x00-0x07`: `50 52 03 49 4E 05 00 00` (Signature)
*   `0x08-0x09`: `00 04` (Default Pixels = 4, Big Endian)
*   `0x0A-0x0B`: `00 08` (Constant)
*   `0x0C-0x0D`: `01 00` (Refresh Rate = 1Hz, Little Endian)
*   `0x0E-0x0F`: `50 49` ('PI' Marker)
*   `0x10-0x13`: `15 00 00 00` (Pointer1 = 21, for N=1)
*   `0x14-0x15`: `01 00` (Segment Count N = 1)
*   `0x18-0x19`: `64 00` (RGB Data Repetition Count = 100)
*   `0x1A-0x1B`: `33 00` (RGB Data Start Offset = 51, for N=1)
*   `0x1C-0x1D`: `00 00` (Constant)

### 1s (Duration `Dur0Units_actual` = 1)
```
0000:0000 | 50 52 03 49  4E 05 00 00  00 04 00 08  01 00 50 49 | PR.IN.........PI
0000:0010 | 15 00 00 00  01 00 00 00  64 00 33 00  00 00 01 00 | ........d.3.....
```
*   `0x16-0x17`: `00 00` (Field 0x16 Value = 0)
*   `0x1E-0x1F`: `01 00` (Field 0x1E Value = 1)

### 2s (Duration `Dur0Units_actual` = 2)
```
0000:0000 | 50 52 03 49  4E 05 00 00  00 04 00 08  01 00 50 49 | PR.IN.........PI
0000:0010 | 15 00 00 00  01 00 00 00  64 00 33 00  00 00 02 00 | ........d.3.....
```
*   `0x16-0x17`: `00 00` (Field 0x16 Value = 0)
*   `0x1E-0x1F`: `02 00` (Field 0x1E Value = 2)

### 10s (Duration `Dur0Units_actual` = 10)
```
0000:0000 | 50 52 03 49  4E 05 00 00  00 04 00 08  01 00 50 49 | PR.IN.........PI
0000:0010 | 15 00 00 00  01 00 00 00  64 00 33 00  00 00 0A 00 | ........d.3.....
```
*   `0x16-0x17`: `00 00` (Field 0x16 Value = 0)
*   `0x1E-0x1F`: `0A 00` (Field 0x1E Value = 10)

### 50s (Duration `Dur0Units_actual` = 50)
```
0000:0000 | 50 52 03 49  4E 05 00 00  00 04 00 08  01 00 50 49 | PR.IN.........PI
0000:0010 | 15 00 00 00  01 00 00 00  64 00 33 00  00 00 32 00 | ........d.3...2.
```
*   `0x16-0x17`: `00 00` (Field 0x16 Value = 0)
*   `0x1E-0x1F`: `32 00` (Field 0x1E Value = 50)

### 99s (Duration `Dur0Units_actual` = 99)
```
0000:0000 | 50 52 03 49  4E 05 00 00  00 04 00 08  01 00 50 49 | PR.IN.........PI
0000:0010 | 15 00 00 00  01 00 00 00  64 00 33 00  00 00 63 00 | ........d.3...c.
```
*   `0x16-0x17`: `00 00` (Field 0x16 Value = 0)
*   `0x1E-0x1F`: `63 00` (Field 0x1E Value = 99)

### 100s (Duration `Dur0Units_actual` = 100)
```
0000:0000 | 50 52 03 49  4E 05 00 00  00 04 00 08  01 00 50 49 | PR.IN.........PI
0000:0010 | 15 00 00 00  01 00 01 00  64 00 33 00  00 00 00 00 | ........d.3.....
```
*   `0x16-0x17`: `01 00` (Field 0x16 Value = 1)
*   `0x1E-0x1F`: `00 00` (Field 0x1E Value = 0)

### 101s (Duration `Dur0Units_actual` = 101)
```
0000:0000 | 50 52 03 49  4E 05 00 00  00 04 00 08  01 00 50 49 | PR.IN.........PI
0000:0010 | 15 00 00 00  01 00 01 00  64 00 33 00  00 00 01 00 | ........d.3.....
```
*   `0x16-0x17`: `01 00` (Field 0x16 Value = 1)
*   `0x1E-0x1F`: `01 00` (Field 0x1E Value = 1)

### 200s (Duration `Dur0Units_actual` = 200)
```
0000:0000 | 50 52 03 49  4E 05 00 00  00 04 00 08  01 00 50 49 | PR.IN.........PI
0000:0010 | 15 00 00 00  01 00 02 00  64 00 33 00  00 00 00 00 | ........d.3.....
```
*   `0x16-0x17`: `02 00` (Field 0x16 Value = 2)
*   `0x1E-0x1F`: `00 00` (Field 0x1E Value = 0)

## Multi-Segment, 1Hz Refresh Rate Examples

### red_1s_blue_1s_1r.prg (N=2, Dur0Units_actual=1)
```
0000:0000 | 50 52 03 49  4E 05 00 00  00 04 00 08  01 00 50 49 | PR.IN.........PI
0000:0010 | 28 00 00 00  02 00 00 00  64 00 46 00  00 00 01 00 | (.......d.F.....
0000:0020 | 04 00 01 00  00 01 00 00  00 00 00 64  00 72 01 00 | ...........d.r..
0000:0030 | 00 01 00 04  00 01 00 00  01 00 00 00  43 44 5C 02 | ............CD\.
```
*   `0x14-0x15`: `02 00` (Segment Count N = 2)
*   `0x16-0x17`: `00 00` (Field 0x16 Value = 0)
*   `0x1E-0x1F`: `01 00` (Field 0x1E Value = 1)

### red_1s_blue_1s_green_1s_1r.prg (N=3, Dur0Units_actual=1)
```
0000:0000 | 50 52 03 49  4E 05 00 00  00 04 00 08  01 00 50 49 | PR.IN.........PI
0000:0010 | 3B 00 00 00  03 00 00 00  64 00 59 00  00 00 01 00 | ;.......d.Y.....
0000:0020 | 04 00 01 00  00 01 00 00  00 00 00 64  00 85 01 00 | ...........d....
```
*   `0x14-0x15`: `03 00` (Segment Count N = 3)
*   `0x16-0x17`: `00 00` (Field 0x16 Value = 0)
*   `0x1E-0x1F`: `01 00` (Field 0x1E Value = 1)

### red_1s_blue_2s_1r.prg (N=2, Dur0Units_actual=1)
Same header as `red_1s_blue_1s_1r.prg` for fields 0x16 and 0x1E.
```
0000:0000 | 50 52 03 49  4E 05 00 00  00 04 00 08  01 00 50 49 | PR.IN.........PI
0000:0010 | 28 00 00 00  02 00 00 00  64 00 46 00  00 00 01 00 | (.......d.F.....
```
*   `0x16-0x17`: `00 00`
*   `0x1E-0x1F`: `01 00`

### red_50s_blue_50s_1r.prg (N=2, Dur0Units_actual=50)
```
0000:0000 | 50 52 03 49  4E 05 00 00  00 04 00 08  01 00 50 49 | PR.IN.........PI
0000:0010 | 28 00 00 00  02 00 00 00  64 00 46 00  00 00 32 00 | (.......d.F...2.
```
*   `0x16-0x17`: `00 00` (Field 0x16 Value = 0)
*   `0x1E-0x1F`: `32 00` (Field 0x1E Value = 50)

### red_100s_blue_50s_1r.prg (N=2, Dur0Units_actual=100)
```
0000:0000 | 50 52 03 49  4E 05 00 00  00 04 00 08  01 00 50 49 | PR.IN.........PI
0000:0010 | 28 00 00 00  02 00 01 00  64 00 46 00  00 00 00 00 | (.......d.F.....
```
*   `0x16-0x17`: `01 00` (Field 0x16 Value = 1)
*   `0x1E-0x1F`: `00 00` (Field 0x1E Value = 0)


## Deduced Logic for Header Fields 0x16 and 0x1E

Let:
*   `Dur0Units_actual`: The duration of the first PRG segment in PRG time units.
*   `N_prg`: The total number of PRG segments in the file.
*   `val_0x16_dec`: The decimal value calculated for field `0x16`.

**Field `0x16` (Header First Segment Info):**
1.  If `N_prg == 1`:
    *   `val_0x16_dec = floor(Dur0Units_actual / 100)`
2.  Else (`N_prg > 1`):
    *   If `Dur0Units_actual == 100`: `val_0x16_dec = 1`
    *   Else (`Dur0Units_actual != 100`): `val_0x16_dec = 0`
*   The byte value written to the file is `struct.pack('<H', val_0x16_dec)`.

**Field `0x1E` (Header First Segment Duration (Conditional)):**
1.  If `N_prg == 1`:
    *   `val_0x1E_dec = Dur0Units_actual - (val_0x16_dec * 100)`
      (Note: `val_0x16_dec` is the decimal value calculated for field `0x16` above)
2.  Else (`N_prg > 1`):
    *   If `Dur0Units_actual == 100`: `val_0x1E_dec = 0`
    *   Else (`Dur0Units_actual != 100`): `val_0x1E_dec = Dur0Units_actual`
*   The byte value written to the file is `struct.pack('<H', val_0x1E_dec & 0xFFFF)`.

This logic appears consistent with all provided 1Hz examples.

---

## Important Finding: 1Hz PRG with 100 Color Slots Experiment (Failed)

**Date:** 2025-06-01

An experiment was conducted using a modified generator (`prg_generator_new.py`) that produced PRG files with a 1Hz master refresh rate. The intention was to use the 100 RGB color data slots within each 1-second PRG segment to achieve 0.01s granularity.

**Observation:** The LTX ball firmware appears to **only use the first RGB color** from the 300-byte (100x3 RGB) color data block when the PRG file's refresh rate is 1Hz. The remaining 99 color slots are ignored for display purposes in this mode.

**Example JSON that resulted in solid yellow (not yellow then black):**
```json
{
  "default_pixels": 4,
  "color_format": "rgb",
  "refresh_rate": 100,
  "end_time": 100,
  "sequence": {
    "0": {"color": [255, 255, 0], "pixels": 4},    // Yellow
    "1": {"color": [0, 0, 0], "pixels": 4}         // Black (intended for 0.01s later)
  }
}
```
Resulting PRG (1Hz) showed solid yellow for 1 second.

**Example JSON that resulted in solid red (not red then blue):**
```json
{
  "default_pixels": 4,
  "color_format": "rgb",
  "refresh_rate": 100,
  "end_time": 100,
  "sequence": {
    "0": {"color": [255, 0, 0], "pixels": 4},     // Red
    "50": {"color": [0, 0, 255], "pixels": 4}    // Blue (intended for 0.5s later)
  }
}
```
Resulting PRG (1Hz) showed solid red for 1 second.

**Conclusion:** High-frequency color changes cannot be achieved by manipulating the 100 sub-color slots within a 1Hz PRG segment. A higher PRG refresh rate (e.g., 100Hz or 1000Hz) is necessary for fine-grained temporal resolution.

---

## 1000Hz Refresh Rate Examples (PRG Refresh Rate = 1000)

These examples use a PRG file refresh rate of 1000Hz (`03E8` Little Endian).
All are 4-pixel.

**Common Header Values for 1000Hz Refresh Rate, 4px:**
*   `0x00-0x07`: `50 52 03 49 4E 05 00 00` (Signature)
*   `0x08-0x09`: `00 04` (Default Pixels = 4, Big Endian)
*   `0x0A-0x0B`: `00 08` (Constant)
*   `0x0C-0x0D`: `E8 03` (Refresh Rate = 1000Hz, Little Endian)
*   `0x0E-0x0F`: `50 49` ('PI' Marker)
*   `0x18-0x19`: `64 00` (RGB Data Repetition Count = 100)
*   `0x1C-0x1D`: `00 00` (Constant)

### red_.01s_1000r.prg (N=1, Dur0Units_actual = 10)
*Actual Hex:*
```
0000:0000 | 50 52 03 49  4E 05 00 00  00 04 00 08  E8 03 50 49 | PR.IN.......è.PI
0000:0010 | 15 00 00 00  01 00 00 00  64 00 33 00  00 00 0A 00 | ........d.3.....
```
*   `0x16-0x17`: `00 00` (Value 0)
*   `0x1E-0x1F`: `0A 00` (Value 10)

### red_.1s_1000r.prg (N=1, Dur0Units_actual = 100)
*Actual Hex:*
```
0000:0000 | 50 52 03 49  4E 05 00 00  00 04 00 08  E8 03 50 49 | PR.IN.......è.PI
0000:0010 | 15 00 00 00  01 00 01 00  64 00 33 00  00 00 00 00 | ........d.3.....
```
*   `0x16-0x17`: `01 00` (Value 1)
*   `0x1E-0x1F`: `00 00` (Value 0)

### red_0.5s_1000r.prg (N=1, Dur0Units_actual = 500)
*Actual Hex:*
```
0000:0000 | 50 52 03 49  4E 05 00 00  00 04 00 08  E8 03 50 49 | PR.IN.......è.PI
0000:0010 | 15 00 00 00  01 00 05 00  64 00 33 00  00 00 F4 01 | ........d.3...ô.
```
*   `0x16-0x17`: `05 00` (Value 5)
*   `0x1E-0x1F`: `F4 01` (Value 500)

### red_1s_1000r.prg (N=1, Dur0Units_actual = 1000)
*Actual Hex:*
```
0000:0000 | 50 52 03 49  4E 05 00 00  00 04 00 08  E8 03 50 49 | PR.IN.......è.PI
0000:0010 | 15 00 00 00  01 00 0A 00  64 00 33 00  00 00 E8 03 | ........d.3...è.
```
*   `0x16-0x17`: `0A 00` (Value 10)
*   `0x1E-0x1F`: `E8 03` (Value 1000)

### red_5s_1000r.prg (N=1, Dur0Units_actual = 5000)
*Actual Hex:*
```
0000:0000 | 50 52 03 49  4E 05 00 00  00 04 00 08  E8 03 50 49 | PR.IN.......è.PI
0000:0010 | 15 00 00 00  01 00 32 00  64 00 33 00  00 00 88 13 | ......2.d.3.....
```
*   `0x16-0x17`: `32 00` (Value 50)
*   `0x1E-0x1F`: `88 13` (Value 5000)


### red_10s_1000r.prg (N=1, Dur0Units_actual = 10000)
*Actual Hex:*
```
0000:0000 | 50 52 03 49  4E 05 00 00  00 04 00 08  E8 03 50 49 | PR.IN.......è.PI
0000:0010 | 15 00 00 00  01 00 64 00  64 00 33 00  00 00 10 27 | ......d.d.3....'
```
*   `0x16-0x17`: `64 00` (Value 100)
*   `0x1E-0x1F`: `10 27` (Value 10000)

### red_0.1s_blue_0.1s_1000r.prg (N=2, Dur0Units_actual=100)
*Actual Hex:*
```
0000:0000 | 50 52 03 49  4E 05 00 00  00 04 00 08  E8 03 50 49 | PR.IN.......è.PI
0000:0010 | 28 00 00 00  02 00 01 00  64 00 46 00  00 00 00 00 | (.......d.F.....
```
*   `0x14-0x15` (N): `02 00` (2)
*   `0x16-0x17` (Field 0x16, from Dur0=100): `01 00` (Value 1)
*   `0x1E-0x1F` (Field 0x1E, from Dur0=100): `00 00` (Value 0)


### red_1s_blue_.5s_1000r.prg (N=2, Dur0Units_actual=1000)
*Actual Hex:*
```
0000:0000 | 50 52 03 49  4E 05 00 00  00 04 00 08  E8 03 50 49 | PR.IN.......è.PI
0000:0010 | 28 00 00 00  02 00 0A 00  64 00 46 00  00 00 E8 03 | (.......d.F...è.
```
*   `0x14-0x15` (N): `02 00` (2)
*   `0x16-0x17` (Field 0x16, from Dur0=1000): `0A 00` (Value 10)
*   `0x1E-0x1F` (Field 0x1E, from Dur0=1000): `E8 03` (Value 1000)


---

### High Segment Count (N > 255) at 1000Hz Refresh Rate Examples

**Date:** 2025-06-01

These examples are to investigate how the PRG format handles segment counts exceeding 255.
All files have a 0.1s segment duration and 1000Hz refresh rate.
This means each segment has `Dur0Units_actual = 0.1 * 1000 = 100`.
The common header values for Refresh Rate (`E8 03` at `0x0C-0x0D`), Field `0x16` (`01 00` at `0x16-0x17`), and Field `0x1E` (`00 00` at `0x1E-0x1F`) are consistent with `Dur0Units_actual=100` according to Hypothesis 8.

#### N253_.1s_1000r.prg (Actual N=253, Dur0Units_actual=100)
*Actual Hex (first 256 bytes):*
```
0000:0000 | 50 52 03 49  4E 05 00 00  00 04 00 08  E8 03 50 49 | PR.IN.......è.PI
0000:0010 | C9 12 00 00  FD 00 01 00  64 00 E7 12  00 00 00 00 | É...ý...d.ç.....
0000:0020 | 04 00 01 00  00 64 00 00  00 01 00 64  00 13 14 00 | .....d.....d....
0000:0030 | 00 00 00 04  00 01 00 00  64 00 00 00  01 00 64 00 | ........d.....d.
0000:0040 | 3F 15 00 00  00 00 04 00  01 00 00 64  00 00 00 01 | ?..........d....
0000:0050 | 00 64 00 6B  16 00 00 00  00 04 00 01  00 00 64 00 | .d.k..........d.
0000:0060 | 00 00 01 00  64 00 97 17  00 00 00 00  04 00 01 00 | ....d...........
0000:0070 | 00 64 00 00  00 01 00 64  00 C3 18 00  00 00 00 04 | .d.....d.Ã......
0000:0080 | 00 01 00 00  64 00 00 00  01 00 64 00  EF 19 00 00 | ....d.....d.ï...
0000:0090 | 00 00 04 00  01 00 00 64  00 00 00 01  00 64 00 1B | .......d.....d..
0000:00A0 | 1B 00 00 00  00 04 00 01  00 00 64 00  00 00 01 00 | ..........d.....
0000:00B0 | 64 00 47 1C  00 00 00 00  04 00 01 00  00 64 00 00 | d.G..........d..
0000:00C0 | 00 01 00 64  00 73 1D 00  00 00 00 04  00 01 00 00 | ...d.s..........
0000:00D0 | 64 00 00 00  01 00 64 00  9F 1E 00 00  00 00 04 00 | d.....d.........
0000:00E0 | 01 00 00 64  00 00 00 01  00 64 00 CB  1F 00 00 00 | ...d.....d.Ë....
0000:00F0 | 00 04 00 01  00 00 64 00  00 00 01 00  64 00 F7 20 | ......d.....d.÷
0000:0100 | 00 00 00 00  04 00 01 00  00 64 00 00  00 01 00 64 | .........d.....d
```
*   `0x10-0x13` (Pointer1): `C9 12 00 00` (`0x12C9` = 4809). Formula `21 + 19*(253-1) = 21 + 19*252 = 21 + 4788 = 4809`. Matches.
*   `0x14-0x15` (Segment Count N): `FD 00` (`0x00FD` = 253). Matches.
*   `0x1A-0x1B` (RGB Data Start Offset): `E7 12` (`0x12E7` = 4839). Formula `32 + 253*19 = 32 + 4807 = 4839`. Matches.

#### N257_.1s_1000r.prg (Actual N=257, Dur0Units_actual=100)
**Note:** Filename has been corrected to match actual segment count. Header fields consistently point to N=257.
*Actual Hex (first 256 bytes):*
```
0000:0000 | 50 52 03 49  4E 05 00 00  00 04 00 08  E8 03 50 49 | PR.IN.......è.PI
0000:0010 | 15 13 00 00  01 01 01 00  64 00 33 13  00 00 00 00 | ........d.3.....
0000:0020 | 04 00 01 00  00 64 00 00  00 01 00 64  00 5F 14 00 | .....d.....d._..
0000:0030 | 00 00 00 04  00 01 00 00  64 00 00 00  01 00 64 00 | ........d.....d.
0000:0040 | 8B 15 00 00  00 00 04 00  01 00 00 64  00 00 00 01 | ...........d....
0000:0050 | 00 64 00 B7  16 00 00 00  00 04 00 01  00 00 64 00 | .d.·..........d.
0000:0060 | 00 00 01 00  64 00 E3 17  00 00 00 00  04 00 01 00 | ....d.ã.........
0000:0070 | 00 64 00 00  00 01 00 64  00 0F 19 00  00 00 00 04 | .d.....d........
0000:0080 | 00 01 00 00  64 00 00 00  01 00 64 00  3B 1A 00 00 | ....d.....d.;...
0000:0090 | 00 00 04 00  01 00 00 64  00 00 00 01  00 64 00 67 | .......d.....d.g
0000:00A0 | 1B 00 00 00  00 04 00 01  00 00 64 00  00 00 01 00 | ..........d.....
0000:00B0 | 64 00 93 1C  00 00 00 00  04 00 01 00  00 64 00 00 | d............d..
0000:00C0 | 00 01 00 64  00 BF 1D 00  00 00 00 04  00 01 00 00 | ...d.¿..........
0000:00D0 | 64 00 00 00  01 00 64 00  EB 1E 00 00  00 00 04 00 | d.....d.ë.......
0000:00E0 | 01 00 00 64  00 00 00 01  00 64 00 17  20 00 00 00 | ...d.....d.. ...
0000:00F0 | 00 04 00 01  00 00 64 00  00 00 01 00  64 00 43 21 | ......d.....d.C!
0000:0100 | 00 00 00 00  04 00 01 00  00 64 00 00  00 01 00 64 | .........d.....d
```
*   `0x10-0x13` (Pointer1): `15 13 00 00` (`0x1315` = 4885). Formula `21 + 19*(257-1) = 21 + 19*256 = 21 + 4864 = 4885`. Matches N=257.
*   `0x14-0x15` (Segment Count N): `01 01` (`0x0101` = 257). Matches N=257.
*   `0x1A-0x1B` (RGB Data Start Offset): `33 13` (`0x1333` = 4915). Formula `32 + 257*19 = 32 + 4883 = 4915`. Matches N=257.

#### N258_.1s_1000r.prg (Actual N=258, Dur0Units_actual=100)
**Note:** Filename has been corrected to match actual segment count. Header fields consistently point to N=258.
*Actual Hex (first 256 bytes):*
```
0000:0000 | 50 52 03 49  4E 05 00 00  00 04 00 08  E8 03 50 49 | PR.IN.......è.PI
0000:0010 | 28 13 00 00  02 01 01 00  64 00 46 13  00 00 00 00 | (.......d.F.....
0000:0020 | 04 00 01 00  00 64 00 00  00 01 00 64  00 72 14 00 | .....d.....d.r..
0000:0030 | 00 00 00 04  00 01 00 00  64 00 00 00  01 00 64 00 | ........d.....d.
0000:0040 | 9E 15 00 00  00 00 04 00  01 00 00 64  00 00 00 01 | ...........d....
0000:0050 | 00 64 00 CA  16 00 00 00  00 04 00 01  00 00 64 00 | .d.Ê..........d.
0000:0060 | 00 00 01 00  64 00 F6 17  00 00 00 00  04 00 01 00 | ....d.ö.........
0000:0070 | 00 64 00 00  00 01 00 64  00 22 19 00  00 00 00 04 | .d.....d."......
0000:0080 | 00 01 00 00  64 00 00 00  01 00 64 00  4E 1A 00 00 | ....d.....d.N...
0000:0090 | 00 00 04 00  01 00 00 64  00 00 00 01  00 64 00 7A | .......d.....d.z
0000:00A0 | 1B 00 00 00  00 04 00 01  00 00 64 00  00 00 01 00 | ..........d.....
0000:00B0 | 64 00 A6 1C  00 00 00 00  04 00 01 00  00 64 00 00 | d.¦..........d..
0000:00C0 | 00 01 00 64  00 D2 1D 00  00 00 00 04  00 01 00 00 | ...d.Ò..........
0000:00D0 | 64 00 00 00  01 00 64 00  FE 1E 00 00  00 00 04 00 | d.....d.þ.......
0000:00E0 | 01 00 00 64  00 00 00 01  00 64 00 2A  20 00 00 00 | ...d.....d.* ...
0000:00F0 | 00 04 00 01  00 00 64 00  00 00 01 00  64 00 56 21 | ......d.....d.V!
0000:0100 | 00 00 00 00  04 00 01 00  00 64 00 00  00 01 00 64 | .........d.....d
```
*   `0x10-0x13` (Pointer1): `28 13 00 00` (`0x1328` = 4904). Formula `21 + 19*(258-1) = 21 + 19*257 = 21 + 4883 = 4904`. Matches N=258.
*   `0x14-0x15` (Segment Count N): `02 01` (`0x0102` = 258). Matches N=258.
*   `0x1A-0x1B` (RGB Data Start Offset): `46 13` (`0x1346` = 4934). Formula `32 + 258*19 = 32 + 4902 = 4934`. Matches N=258.
*   Duration Block Analysis (e.g., First block at `0x0020` for Segment 0, Second block at `0x0033` for Segment 1):
*   `+0x05` Current Segment Duration is `64 00` (100 units) for all segments.
*   `+0x09` (Field `+0x09`):
    *   For Block 0 (idx=0): `01 00 64 00` (`field_09_part1=1`, `field_09_part2=100`). `part1` is `idx+1`.
    *   For Block 1 (idx=1, CurrentDur=100, PrevDur=100): `01 00 64 00` (`field_09_part1=1`, `field_09_part2=100`). `part1` is `1` because durations are equal. This supports "Hypothesis I" for `field_09_part1`.
*   `+0x11` Next Segment Info (Dur of next segment): `00 00` (0 units) for initial blocks when the next segment's duration is 100ms. This supports the re-confirmed "Hypothesis F" (where `Field+0x11 = 0` if `Dur_k+1 == 100`).


#### N259_.1s_1000r.prg (Actual N=259, Dur0Units_actual=100, Official App)
*Actual Hex (first 256 bytes, from Official App):*
```
0000:0000 | 50 52 03 49  4E 05 00 00  00 04 00 08  E8 03 50 49 | PR.IN.......è.PI
0000:0010 | 3B 13 00 00  03 01 01 00  64 00 59 13  00 00 00 00 | ;.......d.Y.....
0000:0020 | 04 00 01 00  00 64 00 00  00 01 00 64  00 85 14 00 | .....d.....d....
0000:0030 | 00 00 00 04  00 01 00 00  64 00 00 00  01 00 64 00 | ........d.....d.
0000:0040 | B1 15 00 00  00 00 04 00  01 00 00 64  00 00 00 01 | ±..........d....
0000:0050 | 00 64 00 DD  16 00 00 00  00 04 00 01  00 00 64 00 | .d.Ý..........d.
0000:0060 | 00 00 01 00  64 00 09 18  00 00 00 00  04 00 01 00 | ....d...........
0000:0070 | 00 64 00 00  00 01 00 64  00 35 19 00  00 00 00 04 | .d.....d.5......
0000:0080 | 00 01 00 00  64 00 00 00  01 00 64 00  61 1A 00 00 | ....d.....d.a...
0000:0090 | 00 00 04 00  01 00 00 64  00 00 00 01  00 64 00 8D | .......d.....d..
0000:00A0 | 1B 00 00 00  00 04 00 01  00 00 64 00  00 00 01 00 | ..........d.....
0000:00B0 | 64 00 B9 1C  00 00 00 00  04 00 01 00  00 64 00 00 | d.¹..........d..
0000:00C0 | 00 01 00 64  00 E5 1D 00  00 00 00 04  00 01 00 00 | ...d.å..........
0000:00D0 | 64 00 00 00  01 00 64 00  11 1F 00 00  00 00 04 00 | d.....d.........
0000:00E0 | 01 00 00 64  00 00 00 01  00 64 00 3D  20 00 00 00 | ...d.....d.= ...
0000:00F0 | 00 04 00 01  00 00 64 00  00 00 01 00  64 00 69 21 | ......d.....d.i!
0000:0100 | 00 00 00 00  04 00 01 00  00 64 00 00  00 01 00 64 | .........d.....d
```
*   Header Analysis (all segments 0.1s = 100 units @ 1000Hz):
    *   `0x10-0x13` (Pointer1): `3B 13 00 00` (`0x133B` = 4923). Formula `21 + 19*(259-1) = 21 + 19*258 = 21 + 4902 = 4923`. Matches.
    *   `0x14-0x15` (Segment Count N): `03 01` (`0x0103` = 259). Matches.
    *   `0x16-0x17` (Field 0x16 from Dur0=100): `01 00` (Value 1). Matches Hypothesis 8.
    *   `0x1A-0x1B` (RGB Data Start Offset): `59 13` (`0x1359` = 4953). Formula `32 + 259*19 = 32 + 4921 = 4953`. Matches.
    *   `0x1E-0x1F` (Field 0x1E from Dur0=100): `00 00` (Value 0). Matches Hypothesis 8.
*   Duration Block Analysis (e.g., First block at `0x0020` for Segment 0, Second block at `0x0033` for Segment 1):
    *   `+0x00` Pixel Count: `04 00` (4 pixels).
    *   `+0x05` Current Segment Duration is `64 00` (100 units) for all segments.
    *   `+0x09` (Field `+0x09`):
        *   For Block 0 (idx=0): `01 00 64 00` (`field_09_part1=1`, `field_09_part2=100`). `part1` is `idx+1`.
        *   For Block 1 (idx=1, CurrentDur=100, PrevDur=100): `01 00 64 00` (`field_09_part1=1`, `field_09_part2=100`). `part1` is `1` because durations are equal. This supports "Hypothesis I" for `field_09_part1`.
    *   `+0x11` Next Segment Info (Dur of next segment): `00 00` (0 units) for initial blocks when the next segment's duration is 100ms. This supports the re-confirmed "Hypothesis F" (where `Field+0x11 = 0` if `Dur_k+1 == 100`).
*   Observation: This official app file appears to contain 259 segments, each 100 units (100ms) long, without inserted black gaps.

## Deduced Logic for Header Fields 0x16 and 0x1E (Hypothesis 8 - Current Best as of 2025-06-01 10:25)

This logic applies universally across different PRG refresh rates and segment counts, based on all provided official app samples.

It's also important to note the structure of certain fields within **Intermediate Duration Blocks** (i.e., not the last duration block):

*   **Field `+0x09` (Segment Index & Duration) (Revised 2025-06-01):**
    This 4-byte field consists of two 2-byte Little Endian values:
    1.  `field_09_part1`:
        *   If it's the first duration block (`current_block_index == 0`): This is `1` (`01 00`).
        *   If `current_block_index > 0` AND `CurrentSegmentDurationUnits == PreviousSegmentDurationUnits`: This value is `CurrentSegmentDurationUnits`.
        *   Else (`current_block_index > 0` AND `CurrentSegmentDurationUnits != PreviousSegmentDurationUnits`): This value is `current_block_index + 1`.
    2.  `field_09_part2`: This is always `CurrentSegmentDurationUnits`.

*   **Field `+0x11` (Next Segment Info) (Revised 2025-06-01):**
    Let `Dur_k` be current segment's duration, `Dur_k+1` be next segment's duration.
    1.  If `Dur_k+1 < 100`: value is `Dur_k+1`.
    2.  Else if `Dur_k+1 == 100`:
        *   If `Dur_k == 100`: value is `Dur_k+1` (i.e., 100).
        *   Else (`Dur_k != 100`): value is `0`.
    3.  Else (`Dur_k+1 > 100`): value is `Dur_k+1`.

This was refined based on the `R0.1_B0.1_G10_1000hz.prg` comparison on 2025-06-01.

Let:
*   `Dur0Units_actual`: The duration of the first PRG segment (Segment 0) in PRG time units.
*   `NominalBase = 100`. This constant is used in the calculations.
*   `val_0x16_dec`: The decimal value calculated for field `0x16`.
*   `val_0x1E_dec`: The decimal value calculated for field `0x1E`.

**Field `0x16` (Header First Segment Info):**
  `val_0x16_dec = floor(Dur0Units_actual / NominalBase)`

**Field `0x1E` (Header First Segment Duration (Conditional)):**
  `val_0x16_for_0x1E_calc = floor(Dur0Units_actual / NominalBase)` (This is the same as `val_0x16_dec`)
  `calculated_remainder = Dur0Units_actual - (val_0x16_for_0x1E_calc * NominalBase)`

  If `calculated_remainder == 0`:
    If `Dur0Units_actual == NominalBase` (i.e., `Dur0Units_actual` is exactly 100):
      `val_0x1E_dec = 0`
    Else (`Dur0Units_actual` is a multiple of 100, but not 100 itself, e.g., 200, 500, 1000):
      `val_0x1E_dec = Dur0Units_actual`
  Else (`calculated_remainder != 0`):
    `val_0x1E_dec = calculated_remainder`

The byte values written to the file are `struct.pack('<H', val_0x16_dec)` and `struct.pack('<H', val_0x1E_dec & 0xFFFF)`.

This logic correctly predicts header fields `0x16` and `0x1E` for all 1Hz and 1000Hz examples provided by the user.

(Old analysis based on Hypothesis 4 removed for clarity)